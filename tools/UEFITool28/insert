ffs.cpp:http://opensource.org/licenses/bsd-license.php
ffs.cpp:    while (bufferSize--)
ffs.cpp:    return (UINT8)0x100 - calculateSum8(buffer, bufferSize);
ffs.cpp:    return (UINT16)0x10000 - counter;
ffs.cpp:    return QString("%1-%2-%3-%4%5-%6%7%8%9%10%11")
ffs.cpp:    case EFI_SECTION_COMPATIBILITY16:           return QObject::tr("16-bit image");
ffs.cpp:    if (uint24ToUint32(header->Size) == EFI_SECTION2_IS_USED) {
ffs.cpp:    switch (header->Type)
ffs.cpp:            if (QByteArray((const char*)&gdsHeader->SectionDefinitionGuid, sizeof(EFI_GUID)) == EFI_FIRMWARE_CONTENTS_SIGNED_GUID) {
ffs.cpp:                return gdsHeader->DataOffset + certificateHeader->Length;
ffs.cpp:            return gdsHeader->DataOffset;
ffs.cpp:            if (QByteArray((const char*)&gdsHeader->SectionDefinitionGuid, sizeof(EFI_GUID)) == EFI_FIRMWARE_CONTENTS_SIGNED_GUID) {
ffs.cpp:                return gdsHeader->DataOffset + certificateHeader->Length;
ffs.cpp:            return gdsHeader->DataOffset;
types.cpp:http://opensource.org/licenses/bsd-license.php
types.cpp:            return QObject::tr("Non-empty");
uefitool.cpp:  http://opensource.org/licenses/bsd-license.php
uefitool.cpp:    ui->setupUi(this);
uefitool.cpp:    this->setWindowTitle(tr("UEFITool %1").arg(version));
uefitool.cpp:    connect(ui->actionOpenImageFile, SIGNAL(triggered()), this, SLOT(openImageFile()));
uefitool.cpp:    connect(ui->actionOpenImageFileInNewWindow, SIGNAL(triggered()), this, SLOT(openImageFileInNewWindow()));
uefitool.cpp:    connect(ui->actionSaveImageFile, SIGNAL(triggered()), this, SLOT(saveImageFile()));
uefitool.cpp:    connect(ui->actionSearch, SIGNAL(triggered()), this, SLOT(search()));
uefitool.cpp:    connect(ui->actionExtract, SIGNAL(triggered()), this, SLOT(extractAsIs()));
uefitool.cpp:    connect(ui->actionExtractBody, SIGNAL(triggered()), this, SLOT(extractBody()));
uefitool.cpp:    connect(ui->actionInsertInto, SIGNAL(triggered()), this, SLOT(insertInto()));
uefitool.cpp:    connect(ui->actionInsertBefore, SIGNAL(triggered()), this, SLOT(insertBefore()));
uefitool.cpp:    connect(ui->actionInsertAfter, SIGNAL(triggered()), this, SLOT(insertAfter()));
uefitool.cpp:    connect(ui->actionReplace, SIGNAL(triggered()), this, SLOT(replaceAsIs()));
uefitool.cpp:    connect(ui->actionReplaceBody, SIGNAL(triggered()), this, SLOT(replaceBody()));
uefitool.cpp:    connect(ui->actionRemove, SIGNAL(triggered()), this, SLOT(remove()));
uefitool.cpp:    connect(ui->actionRebuild, SIGNAL(triggered()), this, SLOT(rebuild()));
uefitool.cpp:	connect(ui->actionDoNotRebuild, SIGNAL(triggered()), this, SLOT(doNotRebuild()));
uefitool.cpp:    connect(ui->actionMessagesCopy, SIGNAL(triggered()), this, SLOT(copyMessage()));
uefitool.cpp:    connect(ui->actionMessagesCopyAll, SIGNAL(triggered()), this, SLOT(copyAllMessages()));
uefitool.cpp:    connect(ui->actionMessagesClear, SIGNAL(triggered()), this, SLOT(clearMessages()));
uefitool.cpp:    connect(ui->actionAbout, SIGNAL(triggered()), this, SLOT(about()));
uefitool.cpp:    connect(ui->actionAboutQt, SIGNAL(triggered()), this, SLOT(aboutQt()));
uefitool.cpp:    connect(ui->actionQuit, SIGNAL(triggered()), this, SLOT(exit()));
uefitool.cpp:    // Enable Drag-and-Drop actions
uefitool.cpp:    this->setAcceptDrops(true);
uefitool.cpp:    ui->infoEdit->setFont(font);
uefitool.cpp:    ui->messageListWidget->setFont(font);
uefitool.cpp:    ui->structureTreeView->setFont(font);
uefitool.cpp:    searchDialog->ui->guidEdit->setFont(font);
uefitool.cpp:    searchDialog->ui->hexEdit->setFont(font);
uefitool.cpp:    // Initialize non-persistent data
uefitool.cpp:    ui->messageListWidget->clear();
uefitool.cpp:    ui->infoEdit->clear();
uefitool.cpp:    this->setWindowTitle(tr("UEFITool %1").arg(version));
uefitool.cpp:    ui->menuCapsuleActions->setDisabled(true);
uefitool.cpp:    ui->menuImageActions->setDisabled(true);
uefitool.cpp:    ui->menuRegionActions->setDisabled(true);
uefitool.cpp:    ui->menuPaddingActions->setDisabled(true);
uefitool.cpp:    ui->menuVolumeActions->setDisabled(true);
uefitool.cpp:    ui->menuFileActions->setDisabled(true);
uefitool.cpp:    ui->menuSectionActions->setDisabled(true);
uefitool.cpp:    ui->actionMessagesCopy->setDisabled(true);
uefitool.cpp:    ui->actionMessagesCopyAll->setDisabled(true);
uefitool.cpp:    ui->structureTreeView->setModel(ffsEngine->treeModel());
uefitool.cpp:    connect(ui->structureTreeView->selectionModel(), SIGNAL(currentChanged(const QModelIndex &, const QModelIndex &)),
uefitool.cpp:    connect(ui->messageListWidget, SIGNAL(itemDoubleClicked(QListWidgetItem*)), this, SLOT(scrollTreeView(QListWidgetItem*)));
uefitool.cpp:    connect(ui->messageListWidget, SIGNAL(itemEntered(QListWidgetItem*)), this, SLOT(enableMessagesCopyActions(QListWidgetItem*)));
uefitool.cpp:    TreeModel* model = ffsEngine->treeModel();
uefitool.cpp:    UINT8 type = model->type(current);
uefitool.cpp:    UINT8 subtype = model->subtype(current);
uefitool.cpp:    ui->infoEdit->setPlainText(model->info(current));
uefitool.cpp:    ui->menuCapsuleActions->setEnabled(type == Types::Capsule);
uefitool.cpp:    ui->menuImageActions->setEnabled(type == Types::Image);
uefitool.cpp:    ui->menuRegionActions->setEnabled(type == Types::Region);
uefitool.cpp:    ui->menuPaddingActions->setEnabled(type == Types::Padding);
uefitool.cpp:    ui->menuVolumeActions->setEnabled(type == Types::Volume);
uefitool.cpp:    ui->menuFileActions->setEnabled(type == Types::File);
uefitool.cpp:    ui->menuSectionActions->setEnabled(type == Types::Section);
uefitool.cpp:    ui->actionExtract->setDisabled(model->hasEmptyHeader(current) && model->hasEmptyBody(current));
uefitool.cpp:    ui->actionRebuild->setEnabled(type == Types::Volume || type == Types::File || type == Types::Section);
uefitool.cpp:	ui->actionDoNotRebuild->setEnabled(type== Types::Region || type == Types::Volume || type == Types::File || type == Types::Section);
uefitool.cpp:    ui->actionExtractBody->setDisabled(model->hasEmptyBody(current));
uefitool.cpp:    ui->actionRemove->setEnabled(type == Types::Volume || type == Types::File || type == Types::Section);
uefitool.cpp:    ui->actionInsertInto->setEnabled((type == Types::Volume && subtype != Subtypes::UnknownVolume) ||
uefitool.cpp:    ui->actionInsertBefore->setEnabled(type == Types::File || type == Types::Section);
uefitool.cpp:    ui->actionInsertAfter->setEnabled(type == Types::File || type == Types::Section);
uefitool.cpp:    ui->actionReplace->setEnabled((type == Types::Region && subtype != Subtypes::DescriptorRegion) || type == Types::Padding || type == Types::Volume || type == Types::File || type == Types::Section);
uefitool.cpp:    ui->actionReplaceBody->setEnabled(type == Types::Volume || type == Types::File || type == Types::Section);
uefitool.cpp:    ui->actionMessagesCopy->setEnabled(false);
uefitool.cpp:    if (searchDialog->exec() != QDialog::Accepted)
uefitool.cpp:    QModelIndex rootIndex = ffsEngine->treeModel()->index(0, 0);
uefitool.cpp:    int index = searchDialog->ui->tabWidget->currentIndex();
uefitool.cpp:        searchDialog->ui->hexEdit->setFocus();
uefitool.cpp:        QByteArray pattern = searchDialog->ui->hexEdit->text().toLatin1().replace(" ", "");
uefitool.cpp:        if (searchDialog->ui->hexScopeHeaderRadioButton->isChecked())
uefitool.cpp:        else if (searchDialog->ui->hexScopeBodyRadioButton->isChecked())
uefitool.cpp:        ffsEngine->findHexPattern(rootIndex, pattern, mode);
uefitool.cpp:        searchDialog->ui->guidEdit->setFocus();
uefitool.cpp:        searchDialog->ui->guidEdit->setCursorPosition(0);
uefitool.cpp:        QByteArray pattern = searchDialog->ui->guidEdit->text().toLatin1();
uefitool.cpp:        if (searchDialog->ui->guidScopeHeaderRadioButton->isChecked())
uefitool.cpp:        else if (searchDialog->ui->guidScopeBodyRadioButton->isChecked())
uefitool.cpp:        ffsEngine->findGuidPattern(rootIndex, pattern, mode);
uefitool.cpp:        searchDialog->ui->textEdit->setFocus();
uefitool.cpp:        QString pattern = searchDialog->ui->textEdit->text();
uefitool.cpp:        ffsEngine->findTextPattern(rootIndex, pattern, searchDialog->ui->textUnicodeCheckBox->isChecked(),
uefitool.cpp:            (Qt::CaseSensitivity) searchDialog->ui->textCaseSensitiveCheckBox->isChecked());
uefitool.cpp:    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
uefitool.cpp:    UINT8 result = ffsEngine->rebuild(index);
uefitool.cpp:        ui->actionSaveImageFile->setEnabled(true);
uefitool.cpp:	QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
uefitool.cpp:	UINT8 result = ffsEngine->doNotRebuild(index);
uefitool.cpp:		ui->actionSaveImageFile->setEnabled(true);
uefitool.cpp:    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
uefitool.cpp:    UINT8 result = ffsEngine->remove(index);
uefitool.cpp:        ui->actionSaveImageFile->setEnabled(true);
uefitool.cpp:    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
uefitool.cpp:    TreeModel* model = ffsEngine->treeModel();
uefitool.cpp:        type = model->type(index.parent());
uefitool.cpp:        type = model->type(index);
uefitool.cpp:        ui->statusBar->showMessage(tr("Please select existing file"));
uefitool.cpp:    UINT8 result = ffsEngine->insert(index, buffer, mode);
uefitool.cpp:    ui->actionSaveImageFile->setEnabled(true);
uefitool.cpp:    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
uefitool.cpp:    TreeModel* model = ffsEngine->treeModel();
uefitool.cpp:    if (model->type(index) == Types::Region) {
uefitool.cpp:    else if (model->type(index) == Types::Padding) {
uefitool.cpp:    else if (model->type(index) == Types::Volume) {
uefitool.cpp:    else if (model->type(index) == Types::File) {
uefitool.cpp:            if (model->subtype(index) == EFI_FV_FILETYPE_ALL || model->subtype(index) == EFI_FV_FILETYPE_RAW)
uefitool.cpp:            else if (model->subtype(index) == EFI_FV_FILETYPE_PAD) // Pad file body can't be replaced
uefitool.cpp:                //!TODO: handle non-empty pad files
uefitool.cpp:    else if (model->type(index) == Types::Section) {
uefitool.cpp:            if (model->subtype(index) == EFI_SECTION_COMPRESSION || model->subtype(index) == EFI_SECTION_GUID_DEFINED || model->subtype(index) == EFI_SECTION_DISPOSABLE)
uefitool.cpp:            else if (model->subtype(index) == EFI_SECTION_FIRMWARE_VOLUME_IMAGE)
uefitool.cpp:            else if (model->subtype(index) == EFI_SECTION_RAW)
uefitool.cpp:            else if (model->subtype(index) == EFI_SECTION_PE32 || model->subtype(index) == EFI_SECTION_TE || model->subtype(index) == EFI_SECTION_PIC)
uefitool.cpp:        ui->statusBar->showMessage(tr("Please select existing file"));
uefitool.cpp:    UINT8 result = ffsEngine->replace(index, buffer, mode);
uefitool.cpp:    ui->actionSaveImageFile->setEnabled(true);
uefitool.cpp:    QModelIndex index = ui->structureTreeView->selectionModel()->currentIndex();
uefitool.cpp:    TreeModel* model = ffsEngine->treeModel();
uefitool.cpp:    UINT8 type = model->type(index);
uefitool.cpp:            if (model->subtype(index) == EFI_FV_FILETYPE_ALL || model->subtype(index) == EFI_FV_FILETYPE_RAW)
uefitool.cpp:            if (model->subtype(index) == EFI_SECTION_COMPRESSION || model->subtype(index) == EFI_SECTION_GUID_DEFINED || model->subtype(index) == EFI_SECTION_DISPOSABLE)
uefitool.cpp:            else if (model->subtype(index) == EFI_SECTION_FIRMWARE_VOLUME_IMAGE)
uefitool.cpp:            else if (model->subtype(index) == EFI_SECTION_RAW)
uefitool.cpp:    UINT8 result = ffsEngine->extract(index, extracted, mode);
uefitool.cpp:        "The full text of the license may be found at <a href=http://opensource.org/licenses/bsd-license.php>OpenSource.org</a>.<br><br>"
uefitool.cpp:    UINT8 result = ffsEngine->reconstructImageFile(reconstructed);
uefitool.cpp:        ui->statusBar->showMessage(tr("Please select existing file"));
uefitool.cpp:    this->setWindowTitle(tr("UEFITool %1 - %2").arg(version).arg(fileInfo.fileName()));
uefitool.cpp:    UINT8 result = ffsEngine->parseImageFile(buffer);
uefitool.cpp:        ui->statusBar->showMessage(tr("Opened: %1").arg(fileInfo.fileName()));
uefitool.cpp:    ui->actionSearch->setEnabled(true);
uefitool.cpp:    clipboard->clear();
uefitool.cpp:    clipboard->setText(ui->messageListWidget->currentItem()->text());
uefitool.cpp:    clipboard->clear();
uefitool.cpp:    for(INT32 i = 0; i < ui->messageListWidget->count(); i++)
uefitool.cpp:        text.append(ui->messageListWidget->item(i)->text()).append("\n");
uefitool.cpp:    clipboard->clear();
uefitool.cpp:    clipboard->setText(text);
uefitool.cpp:    ui->actionMessagesCopy->setEnabled(item != NULL);
uefitool.cpp:    ui->actionMessagesCopyAll->setEnabled(item != NULL);
uefitool.cpp:    ffsEngine->clearMessages();
uefitool.cpp:    ui->messageListWidget->clear();
uefitool.cpp:    ui->actionMessagesCopy->setEnabled(false);
uefitool.cpp:    ui->actionMessagesCopyAll->setEnabled(false);
uefitool.cpp:    if (event->mimeData()->hasFormat("text/uri-list"))
uefitool.cpp:        event->acceptProposedAction();
uefitool.cpp:    QString path = event->mimeData()->urls().at(0).toLocalFile();
uefitool.cpp:    ui->messageListWidget->clear();
uefitool.cpp:    messageItems = ffsEngine->messages();
uefitool.cpp:        ui->messageListWidget->addItem(new MessageListItem(messageItems.at(i)));
uefitool.cpp:    ui->messageListWidget->scrollToBottom();
uefitool.cpp:    QModelIndex index = messageItem->index();
uefitool.cpp:        ui->structureTreeView->scrollTo(index, QAbstractItemView::PositionAtCenter);
uefitool.cpp:        ui->structureTreeView->selectionModel()->clearSelection();
uefitool.cpp:        ui->structureTreeView->selectionModel()->select(index, QItemSelectionModel::Select);
uefitool.cpp:    if (ui->messageListWidget->underMouse()) {
uefitool.cpp:        ui->menuMessages->exec(event->globalPos());
uefitool.cpp:    if (!ui->structureTreeView->underMouse())
uefitool.cpp:    QPoint pt = event->pos();
uefitool.cpp:    QModelIndex index = ui->structureTreeView->indexAt(ui->structureTreeView->viewport()->mapFrom(this, pt));
uefitool.cpp:    TreeModel* model = ffsEngine->treeModel();
uefitool.cpp:    switch (model->type(index))
uefitool.cpp:        ui->menuCapsuleActions->exec(event->globalPos());
uefitool.cpp:        ui->menuImageActions->exec(event->globalPos());
uefitool.cpp:        ui->menuRegionActions->exec(event->globalPos());
uefitool.cpp:        ui->menuPaddingActions->exec(event->globalPos());
uefitool.cpp:        ui->menuVolumeActions->exec(event->globalPos());
uefitool.cpp:        ui->menuFileActions->exec(event->globalPos());
uefitool.cpp:        ui->menuSectionActions->exec(event->globalPos());
uefitool.cpp:    ui->infoSplitter->setSizes(horList);
uefitool.cpp:    ui->messagesSplitter->setSizes(vertList);
uefitool.cpp:    ui->structureTreeView->setColumnWidth(0, settings.value("tree/columnWidth0", ui->structureTreeView->columnWidth(0)).toInt());
uefitool.cpp:    ui->structureTreeView->setColumnWidth(1, settings.value("tree/columnWidth1", ui->structureTreeView->columnWidth(1)).toInt());
uefitool.cpp:    ui->structureTreeView->setColumnWidth(2, settings.value("tree/columnWidth2", ui->structureTreeView->columnWidth(2)).toInt());
uefitool.cpp:    ui->structureTreeView->setColumnWidth(3, settings.value("tree/columnWidth3", ui->structureTreeView->columnWidth(3)).toInt());
uefitool.cpp:    settings.setValue("mainWindow/treeWidth", ui->structureGroupBox->width());
uefitool.cpp:    settings.setValue("mainWindow/infoWidth", ui->infoGroupBox->width());
uefitool.cpp:    settings.setValue("mainWindow/treeHeight", ui->structureGroupBox->height());
uefitool.cpp:    settings.setValue("mainWindow/messageHeight", ui->messageGroupBox->height());
uefitool.cpp:    settings.setValue("tree/columnWidth0", ui->structureTreeView->columnWidth(0));
uefitool.cpp:    settings.setValue("tree/columnWidth1", ui->structureTreeView->columnWidth(1));
uefitool.cpp:    settings.setValue("tree/columnWidth2", ui->structureTreeView->columnWidth(2));
uefitool.cpp:    settings.setValue("tree/columnWidth3", ui->structureTreeView->columnWidth(3));
types.h:http://opensource.org/licenses/bsd-license.php
uefitool.ui:<?xml version="1.0" encoding="UTF-8"?>
ffsengine.cpp:http://opensource.org/licenses/bsd-license.php
ffsengine.cpp:        capsuleHeaderSize = capsuleHeader->HeaderSize;
ffsengine.cpp:        QByteArray body = buffer.right(buffer.size() - capsuleHeaderSize);
ffsengine.cpp:            .arg(guidToQString(capsuleHeader->CapsuleGuid))
ffsengine.cpp:            .hexarg(capsuleHeader->HeaderSize).arg(capsuleHeader->HeaderSize)
ffsengine.cpp:            .hexarg(capsuleHeader->CapsuleImageSize).arg(capsuleHeader->CapsuleImageSize)
ffsengine.cpp:            .hexarg2(capsuleHeader->Flags, 8);
ffsengine.cpp:        index = model->addItem(Types::Capsule, Subtypes::UefiCapsule, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body);
ffsengine.cpp:        capsuleHeaderSize = capsuleHeader->HeaderSize;
ffsengine.cpp:        QByteArray body = buffer.right(buffer.size() - capsuleHeaderSize);
ffsengine.cpp:            .arg(guidToQString(capsuleHeader->CapsuleGuid))
ffsengine.cpp:            .hexarg(capsuleHeader->HeaderSize).arg(capsuleHeader->HeaderSize)
ffsengine.cpp:            .hexarg(capsuleHeader->FullSize - capsuleHeader->HeaderSize).arg(capsuleHeader->FullSize - capsuleHeader->HeaderSize)
ffsengine.cpp:            .hexarg2(capsuleHeader->Flags, 8);
ffsengine.cpp:        index = model->addItem(Types::Capsule, Subtypes::ToshibaCapsule, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body);
ffsengine.cpp:        capsuleHeaderSize = capsuleHeader->RomImageOffset;
ffsengine.cpp:        QByteArray body = buffer.right(buffer.size() - capsuleHeaderSize);
ffsengine.cpp:            .arg(guidToQString(capsuleHeader->CapsuleHeader.CapsuleGuid))
ffsengine.cpp:            .hexarg(capsuleHeader->CapsuleHeader.CapsuleImageSize - capsuleHeaderSize).arg(capsuleHeader->CapsuleHeader.CapsuleImageSize - capsuleHeaderSize)
ffsengine.cpp:            .hexarg2(capsuleHeader->CapsuleHeader.Flags, 8);
ffsengine.cpp:        index = model->addItem(Types::Capsule, signedCapsule ? Subtypes::AptioSignedCapsule : Subtypes::AptioUnsignedCapsule, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body);
ffsengine.cpp:    QByteArray flashImage = buffer.right(buffer.size() - capsuleHeaderSize);
ffsengine.cpp:    if (descriptorHeader->Signature == FLASH_DESCRIPTOR_SIGNATURE) {
ffsengine.cpp:    index = model->addItem(Types::Image, Subtypes::UefiImage, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), flashImage, index);
ffsengine.cpp:    if (descriptorMap->MasterBase > FLASH_DESCRIPTOR_MAX_BASE
ffsengine.cpp:        || descriptorMap->MasterBase == descriptorMap->RegionBase
ffsengine.cpp:        || descriptorMap->MasterBase == descriptorMap->ComponentBase) {
ffsengine.cpp:        msg(tr("parseIntelImage: invalid descriptor master base %1h").hexarg2(descriptorMap->MasterBase, 2));
ffsengine.cpp:    if (descriptorMap->RegionBase > FLASH_DESCRIPTOR_MAX_BASE
ffsengine.cpp:        || descriptorMap->RegionBase == descriptorMap->ComponentBase) {
ffsengine.cpp:        msg(tr("parseIntelImage: invalid descriptor region base %1h").hexarg2(descriptorMap->RegionBase, 2));
ffsengine.cpp:    if (descriptorMap->ComponentBase > FLASH_DESCRIPTOR_MAX_BASE) {
ffsengine.cpp:        msg(tr("parseIntelImage: invalid descriptor component base %1h").hexarg2(descriptorMap->ComponentBase, 2));
ffsengine.cpp:    const FLASH_DESCRIPTOR_REGION_SECTION* regionSection = (const FLASH_DESCRIPTOR_REGION_SECTION*)calculateAddress8(descriptor, descriptorMap->RegionBase);
ffsengine.cpp:    const FLASH_DESCRIPTOR_COMPONENT_SECTION* componentSection = (const FLASH_DESCRIPTOR_COMPONENT_SECTION*)calculateAddress8(descriptor, descriptorMap->ComponentBase);
ffsengine.cpp:    if (componentSection->FlashParameters.ReadClockFrequency == FLASH_FREQUENCY_20MHZ)  // Legacy descriptor
ffsengine.cpp:    if (regionSection->MeLimit) {
ffsengine.cpp:        meBegin = calculateRegionOffset(regionSection->MeBase);
ffsengine.cpp:        meEnd = calculateRegionSize(regionSection->MeBase, regionSection->MeLimit);
ffsengine.cpp:    if (regionSection->BiosLimit) {
ffsengine.cpp:        biosBegin = calculateRegionOffset(regionSection->BiosBase);
ffsengine.cpp:        biosEnd = calculateRegionSize(regionSection->BiosBase, regionSection->BiosLimit);
ffsengine.cpp:        if (biosEnd - biosBegin == (UINT32)intelImage.size()) {
ffsengine.cpp:                msg(tr("parseIntelImage: can't determine BIOS region start from Gigabyte-specific descriptor"));
ffsengine.cpp:    if (regionSection->GbeLimit) {
ffsengine.cpp:        gbeBegin = calculateRegionOffset(regionSection->GbeBase);
ffsengine.cpp:        gbeEnd = calculateRegionSize(regionSection->GbeBase, regionSection->GbeLimit);
ffsengine.cpp:    if (regionSection->PdrLimit) {
ffsengine.cpp:        pdrBegin = calculateRegionOffset(regionSection->PdrBase);
ffsengine.cpp:        pdrEnd = calculateRegionSize(regionSection->PdrBase, regionSection->PdrLimit);
ffsengine.cpp:        if (regionSection->EcLimit) {
ffsengine.cpp:            ecBegin = calculateRegionOffset(regionSection->EcBase);
ffsengine.cpp:            ecEnd = calculateRegionSize(regionSection->EcBase, regionSection->EcLimit);
ffsengine.cpp:        .arg(descriptorMap->NumberOfFlashChips + 1)
ffsengine.cpp:        .arg(descriptorMap->NumberOfMasters + 1)
ffsengine.cpp:        .arg(descriptorMap->NumberOfPchStraps)
ffsengine.cpp:        .arg(descriptorMap->NumberOfProcStraps);
ffsengine.cpp:    index = model->addItem(Types::Image, Subtypes::IntelImage, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), intelImage, parent);
ffsengine.cpp:    if (regionSection->GbeLimit) {
ffsengine.cpp:    if (regionSection->MeLimit) {
ffsengine.cpp:    if (regionSection->BiosLimit) {
ffsengine.cpp:    if (regionSection->PdrLimit) {
ffsengine.cpp:    if (descriptorVersion == 2 && regionSection->EcLimit) {
ffsengine.cpp:        const FLASH_DESCRIPTOR_MASTER_SECTION* masterSection = (const FLASH_DESCRIPTOR_MASTER_SECTION*)calculateAddress8(descriptor, descriptorMap->MasterBase);
ffsengine.cpp:            .hexarg2(masterSection->BiosRead, 2)
ffsengine.cpp:            .hexarg2(masterSection->BiosWrite, 2)
ffsengine.cpp:            .hexarg2(masterSection->MeRead, 2)
ffsengine.cpp:            .hexarg2(masterSection->MeWrite, 2)
ffsengine.cpp:            .hexarg2(masterSection->GbeRead, 2)
ffsengine.cpp:            .hexarg2(masterSection->GbeWrite, 2);
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_ME ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_ME ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_GBE ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_GBE ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_PDR ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_PDR ? "Yes " : "No  ");
ffsengine.cpp:        const FLASH_DESCRIPTOR_MASTER_SECTION_V2* masterSection = (const FLASH_DESCRIPTOR_MASTER_SECTION_V2*)calculateAddress8(descriptor, descriptorMap->MasterBase);
ffsengine.cpp:            .hexarg2(masterSection->BiosRead, 3)
ffsengine.cpp:            .hexarg2(masterSection->BiosWrite, 3)
ffsengine.cpp:            .hexarg2(masterSection->MeRead, 3)
ffsengine.cpp:            .hexarg2(masterSection->MeWrite, 3)
ffsengine.cpp:            .hexarg2(masterSection->GbeRead, 3)
ffsengine.cpp:            .hexarg2(masterSection->GbeWrite, 3)
ffsengine.cpp:            .hexarg2(masterSection->EcRead, 3)
ffsengine.cpp:            .hexarg2(masterSection->EcWrite, 3);
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_DESC ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_ME ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_ME ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_GBE ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_GBE ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_PDR ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_PDR ? "Yes " : "No  ");
ffsengine.cpp:            .arg(masterSection->BiosRead  & FLASH_DESCRIPTOR_REGION_ACCESS_EC ? "Yes " : "No  ")
ffsengine.cpp:            .arg(masterSection->BiosWrite & FLASH_DESCRIPTOR_REGION_ACCESS_EC ? "Yes " : "No  ");
ffsengine.cpp:        if (descriptorMap->DescriptorVersion != FLASH_DESCRIPTOR_VERSION_INVALID) {
ffsengine.cpp:            const FLASH_DESCRIPTOR_VERSION* version = (const FLASH_DESCRIPTOR_VERSION*)&descriptorMap->DescriptorVersion;
ffsengine.cpp:            QString versionStr = tr("Flash descriptor version: %1.%2").arg(version->Major).arg(version->Minor);
ffsengine.cpp:            if (version->Major != FLASH_DESCRIPTOR_VERSION_MAJOR || version->Minor != FLASH_DESCRIPTOR_VERSION_MINOR) {
ffsengine.cpp:                msg(tr("parseIntelImage: unknown flash descriptor version %1.%2").arg(version->Major).arg(version->Minor));
ffsengine.cpp:    const VSCC_TABLE_ENTRY* vsccTableEntry = (const VSCC_TABLE_ENTRY*)(descriptor + ((UINT16)upperMap->VsccTableBase << 4));
ffsengine.cpp:    UINT8 vsscTableSize = upperMap->VsccTableSize * sizeof(UINT32) / sizeof(VSCC_TABLE_ENTRY);
ffsengine.cpp:            .hexarg2(vsccTableEntry->VendorId, 2)
ffsengine.cpp:            .hexarg2(vsccTableEntry->DeviceId0, 2)
ffsengine.cpp:            .hexarg2(vsccTableEntry->DeviceId1, 2);
ffsengine.cpp:    model->addItem(Types::Region, Subtypes::DescriptorRegion, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), body, index);
ffsengine.cpp:        model->addItem(Types::Padding, getPaddingType(padding), COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), padding, index);
ffsengine.cpp:        .hexarg2(mac->vendor[0], 2)
ffsengine.cpp:        .hexarg2(mac->vendor[1], 2)
ffsengine.cpp:        .hexarg2(mac->vendor[2], 2)
ffsengine.cpp:        .hexarg2(mac->device[0], 2)
ffsengine.cpp:        .hexarg2(mac->device[1], 2)
ffsengine.cpp:        .hexarg2(mac->device[2], 2)
ffsengine.cpp:        .arg(version->major)
ffsengine.cpp:        .arg(version->minor);
ffsengine.cpp:    index = model->addItem(Types::Region, Subtypes::GbeRegion, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), gbe, parent, mode);
ffsengine.cpp:                .arg(version->major)
ffsengine.cpp:                .arg(version->minor)
ffsengine.cpp:                .arg(version->bugfix)
ffsengine.cpp:                .arg(version->build);
ffsengine.cpp:    index = model->addItem(Types::Region, Subtypes::MeRegion, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), me, parent, mode);
ffsengine.cpp:    index = model->addItem(Types::Region, Subtypes::PdrRegion, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), pdr, parent, mode);
ffsengine.cpp:    index = model->addItem(Types::Region, Subtypes::EcRegion, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), ec, parent, mode);
ffsengine.cpp:    index = model->addItem(Types::Region, Subtypes::BiosRegion, COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), bios, parent, mode);
ffsengine.cpp:        model->addItem(Types::Padding, getPaddingType(padding), COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), padding, parent);
ffsengine.cpp:            UINT32 paddingSize = volumeOffset - prevVolumeOffset - prevVolumeSize;
ffsengine.cpp:            model->addItem(Types::Padding, getPaddingType(padding), COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), padding, parent);
ffsengine.cpp:        if (volumeHeader->Revision == 1) {
ffsengine.cpp:            bool alignmentCap = volumeHeader->Attributes & EFI_FVB_ALIGNMENT_CAP;
ffsengine.cpp:                if (volumeHeader->Attributes & 0xFFFF0000)
ffsengine.cpp:        else if (volumeHeader->Revision == 2) {
ffsengine.cpp:            alignment = (UINT32)(1UL << ((volumeHeader->Attributes & EFI_FVB2_ALIGNMENT) >> 16));
ffsengine.cpp:            msg(tr("parseBios: unknown volume revision %1").arg(volumeHeader->Revision), index);
ffsengine.cpp:            UINT32 endPaddingSize = bios.size() - prevVolumeOffset - prevVolumeSize;
ffsengine.cpp:                model->addItem(Types::Padding, getPaddingType(padding), COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), padding, parent);
ffsengine.cpp:    nextVolumeOffset = nextIndex - EFI_FV_SIGNATURE_OFFSET;
ffsengine.cpp:    if (QByteArray((const char*)&volumeHeader->Signature, sizeof(volumeHeader->Signature)) != EFI_FV_SIGNATURE)
ffsengine.cpp:    while (entry->NumBlocks != 0 && entry->Length != 0) {
ffsengine.cpp:        calcVolumeSize += entry->NumBlocks * entry->Length;
ffsengine.cpp:    volumeSize = volumeHeader->FvLength;
ffsengine.cpp:    if (ALIGN8(volumeHeader->HeaderLength) > volume.size()) {
ffsengine.cpp:    if (volumeHeader->ExtHeaderOffset > 0
ffsengine.cpp:        && (UINT32)volume.size() < ALIGN8(volumeHeader->ExtHeaderOffset + sizeof(EFI_FIRMWARE_VOLUME_EXT_HEADER))) {
ffsengine.cpp:    if (volumeHeader->Revision > 1 && volumeHeader->ExtHeaderOffset) {
ffsengine.cpp:        const EFI_FIRMWARE_VOLUME_EXT_HEADER* extendedHeader = (const EFI_FIRMWARE_VOLUME_EXT_HEADER*)(volume.constData() + volumeHeader->ExtHeaderOffset);
ffsengine.cpp:        headerSize = volumeHeader->ExtHeaderOffset + extendedHeader->ExtHeaderSize;
ffsengine.cpp:        headerSize = volumeHeader->HeaderLength;
ffsengine.cpp:    if (FFSv2Volumes.contains(QByteArray::fromRawData((const char*)volumeHeader->FileSystemGuid.Data, sizeof(EFI_GUID)))){
ffsengine.cpp:	else if (FFSv3Volumes.contains(QByteArray::fromRawData((const char*)volumeHeader->FileSystemGuid.Data, sizeof(EFI_GUID)))) {
ffsengine.cpp:    char empty = volumeHeader->Attributes & EFI_FVB_ERASE_POLARITY ? '\xFF' : '\x00';
ffsengine.cpp:        UINT32 crc = crc32(0, (const UINT8*)(volume.constData() + volumeHeader->HeaderLength), volumeSize - volumeHeader->HeaderLength);
ffsengine.cpp:    if (calculateChecksum16((const UINT16*)volumeHeader, volumeHeader->HeaderLength))
ffsengine.cpp:    QString name = guidToQString(volumeHeader->FileSystemGuid);
ffsengine.cpp:        .hexarg2(volumeHeader->ZeroVector[0], 2).hexarg2(volumeHeader->ZeroVector[1], 2).hexarg2(volumeHeader->ZeroVector[2], 2).hexarg2(volumeHeader->ZeroVector[3], 2)
ffsengine.cpp:        .hexarg2(volumeHeader->ZeroVector[4], 2).hexarg2(volumeHeader->ZeroVector[5], 2).hexarg2(volumeHeader->ZeroVector[6], 2).hexarg2(volumeHeader->ZeroVector[7], 2)
ffsengine.cpp:        .hexarg2(volumeHeader->ZeroVector[8], 2).hexarg2(volumeHeader->ZeroVector[9], 2).hexarg2(volumeHeader->ZeroVector[10], 2).hexarg2(volumeHeader->ZeroVector[11], 2)
ffsengine.cpp:        .hexarg2(volumeHeader->ZeroVector[12], 2).hexarg2(volumeHeader->ZeroVector[13], 2).hexarg2(volumeHeader->ZeroVector[14], 2).hexarg2(volumeHeader->ZeroVector[15], 2)
ffsengine.cpp:        .arg(guidToQString(volumeHeader->FileSystemGuid))
ffsengine.cpp:        .hexarg(volumeSize - headerSize).arg(volumeSize - headerSize)
ffsengine.cpp:        .arg(volumeHeader->Revision)
ffsengine.cpp:        .hexarg2(volumeHeader->Attributes, 8)
ffsengine.cpp:    if (volumeHeader->Revision > 1 && volumeHeader->ExtHeaderOffset) {
ffsengine.cpp:        const EFI_FIRMWARE_VOLUME_EXT_HEADER* extendedHeader = (const EFI_FIRMWARE_VOLUME_EXT_HEADER*)(volume.constData() + volumeHeader->ExtHeaderOffset);
ffsengine.cpp:            .hexarg(extendedHeader->ExtHeaderSize).arg(extendedHeader->ExtHeaderSize)
ffsengine.cpp:            .arg(guidToQString(extendedHeader->FvName));
ffsengine.cpp:    QByteArray  body = volume.mid(headerSize, volumeSize - headerSize);
ffsengine.cpp:    index = model->addItem(Types::Volume, subtype, COMPRESSION_ALGORITHM_NONE, name, text, info, header, body, parent, mode);
ffsengine.cpp:        msg(tr("parseVolume: unknown file system %1").arg(guidToQString(volumeHeader->FileSystemGuid)), index);
ffsengine.cpp:        if (volumeSize - fileOffset < sizeof(EFI_FFS_FILE_HEADER)) {
ffsengine.cpp:            // All the rest is either free space or non-UEFI data
ffsengine.cpp:            QByteArray rest = volume.right(volumeSize - fileOffset);
ffsengine.cpp:                model->addItem(Types::FreeSpace, 0, COMPRESSION_ALGORITHM_NONE, tr("Volume free space"), "", tr("Full size: %1h (%2)").hexarg(rest.size()).arg(rest.size()), QByteArray(), rest, index);
ffsengine.cpp:            else { //It's non-UEFI data
ffsengine.cpp:                QModelIndex dataIndex = model->addItem(Types::Padding, Subtypes::DataPadding, COMPRESSION_ALGORITHM_NONE, tr("Non-UEFI data"), "", tr("Full size: %1h (%2)").hexarg(rest.size()).arg(rest.size()), QByteArray(), rest, index);
ffsengine.cpp:                msg(tr("parseVolume: non-UEFI data found in volume's free space"), dataIndex);
ffsengine.cpp:        fileSize = uint24ToUint32(tempFileHeader->Size);
ffsengine.cpp:        if (volumeHeader->Revision > 1 && (tempFileHeader->Attributes & FFS_ATTRIB_LARGE_FILE)) {
ffsengine.cpp:            if (volumeSize - fileOffset < sizeof(EFI_FFS_FILE_HEADER2)) {
ffsengine.cpp:                // All the rest is either free space or non-UEFI data
ffsengine.cpp:                QByteArray rest = volume.right(volumeSize - fileOffset);
ffsengine.cpp:                    model->addItem(Types::FreeSpace, 0, COMPRESSION_ALGORITHM_NONE, tr("Volume free space"), "", tr("Full size: %1h (%2)").hexarg(rest.size()).arg(rest.size()), QByteArray(), rest, index);
ffsengine.cpp:                else { //It's non-UEFI data
ffsengine.cpp:                    QModelIndex dataIndex = model->addItem(Types::Padding, Subtypes::DataPadding, COMPRESSION_ALGORITHM_NONE, tr("Non-UEFI data"), "", tr("Full size: %1h (%2)").hexarg(rest.size()).arg(rest.size()), QByteArray(), rest, index);
ffsengine.cpp:                    msg(tr("parseVolume: non-UEFI data found in volume's free space"), dataIndex);
ffsengine.cpp:            fileSize = (UINT32)tempFileHeader2->ExtendedSize;
ffsengine.cpp:                // Search for the first non-empty byte
ffsengine.cpp:                    i = ALIGN8(i) - 8;
ffsengine.cpp:                    model->addItem(Types::FreeSpace, 0, COMPRESSION_ALGORITHM_NONE, tr("Volume free space"), "", tr("Full size: %1h (%2)").hexarg(free.size()).arg(free.size()), QByteArray(), free, index);
ffsengine.cpp:                QModelIndex dataIndex = model->addItem(Types::Padding, Subtypes::DataPadding, COMPRESSION_ALGORITHM_NONE, tr("Non-UEFI data"), "", tr("Full size: %1h (%2)").hexarg(padding.size()).arg(padding.size()), QByteArray(), padding, index);
ffsengine.cpp:                msg(tr("parseVolume: non-UEFI data found in volume's free space"), dataIndex);
ffsengine.cpp:                model->addItem(Types::FreeSpace, 0, COMPRESSION_ALGORITHM_NONE, tr("Volume free space"), "", tr("Full size: %1h (%2)").hexarg(freeSpace.size()).arg(freeSpace.size()), QByteArray(), freeSpace, index);
ffsengine.cpp:        UINT8 alignmentPower = ffsAlignmentTable[(fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT) >> 3];
ffsengine.cpp:        if (volumeHeader->Revision > 1 && (fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT2))
ffsengine.cpp:            alignmentPower = ffsAlignment2Table[(fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT) >> 3];
ffsengine.cpp:        if (fileHeader->Type != EFI_FV_FILETYPE_PAD && files.indexOf(header.left(sizeof(EFI_GUID))) != -1)
ffsengine.cpp:        result = parseFile(file, fileIndex, volumeHeader->Revision, empty == '\xFF' ? ERASE_POLARITY_TRUE : ERASE_POLARITY_FALSE, index);
ffsengine.cpp:            msg(tr("parseVolume: unaligned file %1").arg(guidToQString(fileHeader->Name)), fileIndex);
ffsengine.cpp:            msg(tr("parseVolume: file with duplicate GUID %1").arg(guidToQString(fileHeader->Name)), fileIndex);
ffsengine.cpp:    if (revision > 1 && (fileHeader->Attributes & FFS_ATTRIB_LARGE_FILE)) {
ffsengine.cpp:    UINT8 calculatedHeader = 0x100 - (calculateSum8((const UINT8*)header.constData(), header.size()) - fileHeader->IntegrityCheck.Checksum.Header - fileHeader->IntegrityCheck.Checksum.File - fileHeader->State);
ffsengine.cpp:    if (fileHeader->IntegrityCheck.Checksum.Header != calculatedHeader)
ffsengine.cpp:    if (revision == 1 && fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT) {
ffsengine.cpp:        if (fileHeader->IntegrityCheck.TailReference != (UINT16)~tailValue)
ffsengine.cpp:        body = body.left(body.size() - sizeof(UINT16));
ffsengine.cpp:    if (fileHeader->Attributes & FFS_ATTRIB_CHECKSUM) {
ffsengine.cpp:    if (fileHeader->IntegrityCheck.Checksum.File != calculatedData)
ffsengine.cpp:    switch (fileHeader->Type) {
ffsengine.cpp:    // Check for non-empty pad file
ffsengine.cpp:    else if (fileHeader->Type == EFI_FV_FILETYPE_PAD) {
ffsengine.cpp:    if (fileHeader->Type != EFI_FV_FILETYPE_PAD)
ffsengine.cpp:        name = guidToQString(fileHeader->Name);
ffsengine.cpp:        name = parseAsNonEmptyPadFile ? tr("Non-empty pad-file") : tr("Pad-file");
ffsengine.cpp:        .arg(guidToQString(fileHeader->Name))
ffsengine.cpp:        .hexarg2(fileHeader->Type, 2)
ffsengine.cpp:        .hexarg2(fileHeader->Attributes, 2)
ffsengine.cpp:        .hexarg2(fileHeader->State, 2)
ffsengine.cpp:        .hexarg2(fileHeader->IntegrityCheck.Checksum.Header, 2)
ffsengine.cpp:        .hexarg2(fileHeader->IntegrityCheck.Checksum.File, 2);
ffsengine.cpp:    index = model->addItem(Types::File, fileHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:        msg(tr("parseFile: invalid header checksum %1h, should be %2h").hexarg2(fileHeader->IntegrityCheck.Checksum.Header, 2).hexarg2(calculatedHeader, 2), index);
ffsengine.cpp:        msg(tr("parseFile: invalid data checksum %1h, should be %2h").hexarg2(fileHeader->IntegrityCheck.Checksum.File, 2).hexarg2(calculatedData, 2), index);
ffsengine.cpp:        msg(tr("parseFile: unknown file type %1h").arg(fileHeader->Type, 2), index);
ffsengine.cpp:    // Parse non-empty pad file
ffsengine.cpp:        // Search for the first non-empty byte
ffsengine.cpp:            model->addItem(Types::FreeSpace, 0, COMPRESSION_ALGORITHM_NONE, tr("Free space"), "", tr("Full size: %1h (%2)").hexarg(free.size()).arg(free.size()), QByteArray(), free, index, mode);
ffsengine.cpp:        QModelIndex dataIndex = model->addItem(Types::Padding, Subtypes::DataPadding, COMPRESSION_ALGORITHM_NONE, tr("Non-UEFI data"), "", tr("Full size: %1h (%2)").hexarg(padding.size()).arg(padding.size()), QByteArray(), padding, index, mode);
ffsengine.cpp:        msg(tr("parseFile: non-empty pad-file contents will be destroyed after volume modifications"), dataIndex);
ffsengine.cpp:    sectionSize = uint24ToUint32(sectionHeader->Size);
ffsengine.cpp:    // This may introduce a very rare error with a non-extended section of size equal to 0xFFFFFF
ffsengine.cpp:    sectionSize = sectionHeader2->ExtendedSize;	  
ffsengine.cpp:    while (current - (const UINT8*)body.constData() < body.size()) {
ffsengine.cpp:            if ((UINT32)body.size() - (UINT32)(current - (const UINT8*)body.constData()) <= EFI_DEP_OPCODE_SIZE + sizeof(EFI_GUID)) {
ffsengine.cpp:            if (current - (const UINT8*)body.constData() < body.size()) {
ffsengine.cpp:    QString name = sectionTypeToQString(sectionHeader->Type) + tr(" section");
ffsengine.cpp:    switch (sectionHeader->Type) {
ffsengine.cpp:        result = decompress(body, compressedSectionHeader->CompressionType, decompressed, &algorithm);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:            .hexarg(compressedSectionHeader->UncompressedLength).arg(compressedSectionHeader->UncompressedLength);
ffsengine.cpp:            // Dictionary size is stored in bytes 1-4 of LZMA-compressed data
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, algorithm, name, "", info, header, body, parent, mode);
ffsengine.cpp:        model->setDictionarySize(index, dictionarySize);
ffsengine.cpp:        name = guidToQString(guidDefinedSectionHeader->SectionDefinitionGuid);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:            .hexarg(guidDefinedSectionHeader->DataOffset)
ffsengine.cpp:            .hexarg2(guidDefinedSectionHeader->Attributes, 4);
ffsengine.cpp:        QByteArray parsedGuid = QByteArray((const char*)&guidDefinedSectionHeader->SectionDefinitionGuid, sizeof(EFI_GUID));
ffsengine.cpp:        if (guidDefinedSectionHeader->Attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED) {
ffsengine.cpp:                    // Dictionary size is stored in bytes 1-4 of LZMA-compressed data
ffsengine.cpp:                else if (certificateHeader->CertificateType == WIN_CERT_TYPE_EFI_GUID) {
ffsengine.cpp:                    if (QByteArray((const char*)&guidCertificateHeader->CertType, sizeof(EFI_GUID)) == EFI_CERT_TYPE_RSA2048_SHA256_GUID) {
ffsengine.cpp:                    else if (QByteArray((const char*)&guidCertificateHeader->CertType, sizeof(EFI_GUID)) == EFI_CERT_TYPE_PKCS7_GUID) {
ffsengine.cpp:                else if (certificateHeader->CertificateType == WIN_CERT_TYPE_PKCS_SIGNED_DATA) {
ffsengine.cpp:                if ((UINT32)body.size() < certificateHeader->Length) {
ffsengine.cpp:                    header.append(body.left(certificateHeader->Length));
ffsengine.cpp:                    processed = body = body.mid(certificateHeader->Length);
ffsengine.cpp:        else if (guidDefinedSectionHeader->Attributes & EFI_GUIDED_SECTION_AUTH_STATUS_VALID)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, algorithm, name, "", info, header, body, parent, mode);
ffsengine.cpp:        model->setDictionarySize(index, dictionarySize);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        UINT32 teFixup = 0; //teHeader->StrippedSize - sizeof(EFI_IMAGE_TE_HEADER);
ffsengine.cpp:        if (teHeader->Signature != EFI_IMAGE_TE_SIGNATURE) {
ffsengine.cpp:            info += tr("\nSignature: %1h, invalid").hexarg2(teHeader->Signature, 4);
ffsengine.cpp:                .hexarg2(teHeader->Signature, 4)
ffsengine.cpp:                .arg(machineTypeToQString(teHeader->Machine))
ffsengine.cpp:                .arg(teHeader->NumberOfSections)
ffsengine.cpp:                .hexarg2(teHeader->Subsystem, 2)
ffsengine.cpp:                .hexarg(teHeader->StrippedSize).arg(teHeader->StrippedSize)
ffsengine.cpp:                .hexarg(teHeader->BaseOfCode)
ffsengine.cpp:                .hexarg(teHeader->AddressOfEntryPoint)
ffsengine.cpp:                .hexarg(teHeader->ImageBase)
ffsengine.cpp:                .hexarg(teHeader->ImageBase + teHeader->AddressOfEntryPoint - teFixup);
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:        QModelIndex core = model->findParentOfType(index, Types::File);
ffsengine.cpp:        if (core.isValid() && model->subtype(core) == EFI_FV_FILETYPE_PEI_CORE
ffsengine.cpp:            result = getEntryPoint(model->body(index), oldPeiCoreEntryPoint);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        if (dosHeader->e_magic != EFI_IMAGE_DOS_SIGNATURE) {
ffsengine.cpp:            info += tr("\nDOS signature: %1h, invalid").hexarg2(dosHeader->e_magic, 4);
ffsengine.cpp:            const EFI_IMAGE_PE_HEADER* peHeader = (EFI_IMAGE_PE_HEADER*)(body.constData() + dosHeader->e_lfanew);
ffsengine.cpp:            if ((UINT32)body.size() < dosHeader->e_lfanew + sizeof(EFI_IMAGE_PE_HEADER)) {
ffsengine.cpp:                info += tr("\nDOS lfanew: %1h, invalid").hexarg2(dosHeader->e_lfanew, 8);
ffsengine.cpp:            else if (peHeader->Signature != EFI_IMAGE_PE_SIGNATURE) {
ffsengine.cpp:                info += tr("\nPE signature: %1h, invalid").hexarg2(peHeader->Signature, 8);
ffsengine.cpp:                    .hexarg2(dosHeader->e_magic, 4)
ffsengine.cpp:                    .hexarg2(peHeader->Signature, 8)
ffsengine.cpp:                    .arg(machineTypeToQString(imageFileHeader->Machine))
ffsengine.cpp:                    .arg(imageFileHeader->NumberOfSections)
ffsengine.cpp:                    .hexarg2(imageFileHeader->Characteristics, 4);
ffsengine.cpp:                if (optionalHeader.H32->Magic == EFI_IMAGE_PE_OPTIONAL_HDR32_MAGIC) {
ffsengine.cpp:                        .hexarg2(optionalHeader.H32->Magic, 4)
ffsengine.cpp:                        .hexarg2(optionalHeader.H32->Subsystem, 4)
ffsengine.cpp:                        .hexarg(optionalHeader.H32->AddressOfEntryPoint)
ffsengine.cpp:                        .hexarg(optionalHeader.H32->BaseOfCode)
ffsengine.cpp:                        .hexarg(optionalHeader.H32->ImageBase)
ffsengine.cpp:                        .hexarg(optionalHeader.H32->ImageBase + optionalHeader.H32->AddressOfEntryPoint);
ffsengine.cpp:                else if (optionalHeader.H32->Magic == EFI_IMAGE_PE_OPTIONAL_HDR64_MAGIC) {
ffsengine.cpp:                        .hexarg2(optionalHeader.H64->Magic, 4)
ffsengine.cpp:                        .hexarg2(optionalHeader.H64->Subsystem, 4)
ffsengine.cpp:                        .hexarg(optionalHeader.H64->AddressOfEntryPoint)
ffsengine.cpp:                        .hexarg(optionalHeader.H64->BaseOfCode)
ffsengine.cpp:                        .hexarg(optionalHeader.H64->ImageBase)
ffsengine.cpp:                        .hexarg(optionalHeader.H64->ImageBase + optionalHeader.H64->AddressOfEntryPoint);
ffsengine.cpp:                    info += tr("\nOptional header signature: %1h, unknown").hexarg2(optionalHeader.H64->Magic, 4);
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:        QModelIndex core = model->findParentOfType(index, Types::File);
ffsengine.cpp:        if (core.isValid() && model->subtype(core) == EFI_FV_FILETYPE_PEI_CORE
ffsengine.cpp:            result = getEntryPoint(model->body(index), oldPeiCoreEntryPoint);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(fsgHeader->Type, 2)
ffsengine.cpp:            .arg(guidToQString(fsgHeader->SubTypeGuid));
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:        model->setName(index, guidToQString(fsgHeader->SubTypeGuid));
ffsengine.cpp:            .hexarg2(versionHeader->Type, 2)
ffsengine.cpp:            .arg(versionHeader->BuildNumber)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:        model->setText(model->findParentOfType(parent, Types::File), text);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        QModelIndex parentFile = model->findParentOfType(parent, Types::File);
ffsengine.cpp:        QByteArray parentFileGuid = model->header(parentFile).left(sizeof(EFI_GUID));
ffsengine.cpp:            model->setText(parentFile, tr("PEI apriori file"));
ffsengine.cpp:            model->setText(parentFile, tr("DXE apriori file"));
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(postcodeHeader->Type, 2)
ffsengine.cpp:            .hexarg(postcodeHeader->Postcode);
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:            .hexarg2(sectionHeader->Type, 2)
ffsengine.cpp:        index = model->addItem(Types::Section, sectionHeader->Type, COMPRESSION_ALGORITHM_NONE, name, "", info, header, body, parent, mode);
ffsengine.cpp:        msg(tr("parseSection: section with unknown type %1h").hexarg2(sectionHeader->Type, 2), index);
ffsengine.cpp:        UINT8 type = model->subtype(index);
ffsengine.cpp:        model->setAction(fileIndex, action);
ffsengine.cpp:        QModelIndex fileIndex = model->addItem(Types::Padding, getPaddingType(body), COMPRESSION_ALGORITHM_NONE, name, "", info, QByteArray(), body, index, mode);
ffsengine.cpp:        model->setAction(fileIndex, action);
ffsengine.cpp:            INT32 sizeDiff = model->body(index).size() - body.size();
ffsengine.cpp:                const EFI_FIRMWARE_VOLUME_HEADER* volumeHeader = (const EFI_FIRMWARE_VOLUME_HEADER*)model->header(index).constData();
ffsengine.cpp:                bool erasePolarity = volumeHeader->Attributes & EFI_FVB_ERASE_POLARITY;
ffsengine.cpp:        model->setAction(fileIndex, action);
ffsengine.cpp:        if (model->type(parent) != Types::Volume)
ffsengine.cpp:        const EFI_FIRMWARE_VOLUME_HEADER* volumeHeader = (const EFI_FIRMWARE_VOLUME_HEADER*)model->header(parent).constData();
ffsengine.cpp:        UINT8 revision = volumeHeader->Revision;
ffsengine.cpp:        bool erasePolarity = volumeHeader->Attributes & EFI_FVB_ERASE_POLARITY;
ffsengine.cpp:        if (revision > 1 && (fileHeader->Attributes & FFS_ATTRIB_LARGE_FILE)) {
ffsengine.cpp:        UINT8 tailSize = (revision == 1 && (fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT)) ? sizeof(UINT16) : 0;
ffsengine.cpp:            newBody = newBody.left(newBody.size() - tailSize);
ffsengine.cpp:            uint32ToUint24(headerSize + newBody.size() + tailSize, fileHeader->Size);
ffsengine.cpp:            uint32ToUint24(0xFFFFFF, fileHeader->Size);
ffsengine.cpp:            fileHeader2->ExtendedSize = headerSize + newBody.size() + tailSize;
ffsengine.cpp:        fileHeader->State = state;
ffsengine.cpp:        fileHeader->IntegrityCheck.Checksum.Header = 0;
ffsengine.cpp:        fileHeader->IntegrityCheck.Checksum.File = 0;
ffsengine.cpp:        fileHeader->IntegrityCheck.Checksum.Header = 0x100 - (calculateSum8((const UINT8*)newHeader.constData(), headerSize) - fileHeader->State);
ffsengine.cpp:        if (fileHeader->Attributes & FFS_ATTRIB_CHECKSUM)
ffsengine.cpp:            fileHeader->IntegrityCheck.Checksum.File = calculateChecksum8((const UINT8*)newBody.constData(), newBody.size());
ffsengine.cpp:            fileHeader->IntegrityCheck.Checksum.File = FFS_FIXED_CHECKSUM;
ffsengine.cpp:            fileHeader->IntegrityCheck.Checksum.File = FFS_FIXED_CHECKSUM2;
ffsengine.cpp:            UINT8 ht = ~fileHeader->IntegrityCheck.Checksum.Header;
ffsengine.cpp:            UINT8 ft = ~fileHeader->IntegrityCheck.Checksum.File;
ffsengine.cpp:        model->setAction(fileIndex, action);
ffsengine.cpp:        // Rebase all PEI-files that follow
ffsengine.cpp:        if (model->type(parent) != Types::File && model->type(parent) != Types::Section)
ffsengine.cpp:        if (uint24ToUint32(commonHeader->Size) == EFI_SECTION2_IS_USED) {
ffsengine.cpp:        switch (commonHeader->Type)
ffsengine.cpp:            sectionHeader->UncompressedLength = body.size();
ffsengine.cpp:                sectionHeader->CompressionType = EFI_NOT_COMPRESSED;
ffsengine.cpp:                sectionHeader->CompressionType = EFI_STANDARD_COMPRESSION;
ffsengine.cpp:                sectionHeader->CompressionType = EFI_CUSTOMIZED_COMPRESSION;
ffsengine.cpp:            uint32ToUint24(header.size() + compressed.size(), commonHeader->Size);
ffsengine.cpp:            model->setAction(sectionIndex, action);
ffsengine.cpp:            fileIndex = model->findParentOfType(parent, Types::File);
ffsengine.cpp:            uint32ToUint24(header.size() + compressed.size(), commonHeader->Size);
ffsengine.cpp:            model->setAction(sectionIndex, action);
ffsengine.cpp:            fileIndex = model->findParentOfType(parent, Types::File);
ffsengine.cpp:            uint32ToUint24(header.size() + body.size(), commonHeader->Size);
ffsengine.cpp:            model->setAction(sectionIndex, action);
ffsengine.cpp:            fileIndex = model->findParentOfType(parent, Types::File);
ffsengine.cpp:        // Rebase all PEI-files that follow
ffsengine.cpp:    // Rebase all PE32 and TE sections in PEI-files after modified file
ffsengine.cpp:    for (int i = index.row(); i < model->rowCount(index.parent()); i++) {
ffsengine.cpp:        // PEI-file
ffsengine.cpp:        if (model->subtype(currentFileIndex) == EFI_FV_FILETYPE_PEI_CORE ||
ffsengine.cpp:            model->subtype(currentFileIndex) == EFI_FV_FILETYPE_PEIM ||
ffsengine.cpp:            model->subtype(currentFileIndex) == EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER) {
ffsengine.cpp:            for (int j = 0; j < model->rowCount(currentFileIndex); j++) {
ffsengine.cpp:                if (model->subtype(currentSectionIndex) == EFI_SECTION_PE32 || model->subtype(currentSectionIndex) == EFI_SECTION_TE)
ffsengine.cpp:                    if (model->action(currentSectionIndex) != Actions::Remove)
ffsengine.cpp:                        model->setAction(currentSectionIndex, Actions::Rebase);
ffsengine.cpp:    while (parent.isValid() && model->type(parent) != Types::Volume)
ffsengine.cpp:        for (int i = parent.row() + 1; i < model->rowCount(volumeContainer); i++) {
ffsengine.cpp:            for (int j = 0; j < model->rowCount(currentVolumeIndex); j++) {
ffsengine.cpp:                if (model->header(currentFileIndex).left(sizeof(EFI_GUID)) == EFI_FFS_VOLUME_TOP_FILE_GUID) {
ffsengine.cpp:                    for (int k = 0; k < model->rowCount(currentFileIndex); k++) {
ffsengine.cpp:                        if (model->subtype(currentSectionIndex) == EFI_SECTION_PE32 || model->subtype(currentSectionIndex) == EFI_SECTION_TE)
ffsengine.cpp:                            if (model->action(currentSectionIndex) != Actions::Remove)
ffsengine.cpp:                                model->setAction(currentSectionIndex, Actions::Rebase);
ffsengine.cpp:    if (model->type(parent) == Types::Volume) {
ffsengine.cpp:    else if (model->type(parent) == Types::File) {
ffsengine.cpp:    else if (model->type(parent) == Types::Section) {
ffsengine.cpp:    return create(index, type, object.left(headerSize), object.right(object.size() - headerSize), mode, Actions::Insert);
ffsengine.cpp:    if (model->type(index) == Types::Region) {
ffsengine.cpp:    else if (model->type(index) == Types::Padding) {
ffsengine.cpp:    else if (model->type(index) == Types::Volume) {
ffsengine.cpp:            result = create(index, Types::Volume, model->header(index), object, CREATE_MODE_AFTER, Actions::Replace);
ffsengine.cpp:    else if (model->type(index) == Types::File) {
ffsengine.cpp:            result = create(index, Types::File, object.left(headerSize), object.right(object.size() - headerSize), CREATE_MODE_AFTER, Actions::Replace);
ffsengine.cpp:            result = create(index, Types::File, model->header(index), object, CREATE_MODE_AFTER, Actions::Replace);
ffsengine.cpp:    else if (model->type(index) == Types::Section) {
ffsengine.cpp:            result = create(index, Types::Section, object.left(headerSize), object.right(object.size() - headerSize), CREATE_MODE_AFTER, Actions::Replace);
ffsengine.cpp:            result = create(index, Types::Section, model->header(index), object, CREATE_MODE_AFTER, Actions::Replace, model->compression(index));
ffsengine.cpp:    model->setAction(index, Actions::Remove);
ffsengine.cpp:        extracted.append(model->header(index));
ffsengine.cpp:        extracted.append(model->body(index));
ffsengine.cpp:        if (model->type(index) == Types::File) {
ffsengine.cpp:            QModelIndex parent = model->parent(index);
ffsengine.cpp:            if (parent.isValid() && model->type(parent) == Types::Volume) {
ffsengine.cpp:                const EFI_FIRMWARE_VOLUME_HEADER* volumeHeader = (const EFI_FIRMWARE_VOLUME_HEADER*)model->header(parent).constData();
ffsengine.cpp:                revision = volumeHeader->Revision;
ffsengine.cpp:            const EFI_FFS_FILE_HEADER* fileHeader = (const EFI_FFS_FILE_HEADER*)model->header(index).constData();
ffsengine.cpp:            if (revision == 1 && fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT) {
ffsengine.cpp:                UINT8 ht = ~fileHeader->IntegrityCheck.Checksum.Header;
ffsengine.cpp:                UINT8 ft = ~fileHeader->IntegrityCheck.Checksum.File;
ffsengine.cpp:        if (model->type(index) == Types::Section) {
ffsengine.cpp:            if (model->subtype(index) == EFI_SECTION_COMPRESSION) {
ffsengine.cpp:                const EFI_COMPRESSION_SECTION* compressedHeader = (const EFI_COMPRESSION_SECTION*)model->header(index).constData();
ffsengine.cpp:                result = decompress(model->body(index), compressedHeader->CompressionType, decompressed);
ffsengine.cpp:            else if (model->subtype(index) == EFI_SECTION_GUID_DEFINED) {
ffsengine.cpp:                const EFI_GUID_DEFINED_SECTION* guidDefinedSectionHeader = (const EFI_GUID_DEFINED_SECTION*)model->header(index).constData();
ffsengine.cpp:                if (guidDefinedSectionHeader->Attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED) {
ffsengine.cpp:                    result = decompress(model->body(index), EFI_STANDARD_COMPRESSION, decompressed);
ffsengine.cpp:                        result = decompress(model->body(index), EFI_CUSTOMIZED_COMPRESSION, decompressed);
ffsengine.cpp:        extracted.append(model->body(index));
ffsengine.cpp:    model->setAction(index, Actions::Remove);
ffsengine.cpp:    if (model->type(index) == Types::Volume && model->rowCount(index) > 0)
ffsengine.cpp:    else if (model->type(index) == Types::File)
ffsengine.cpp:    else if (model->type(index) == Types::Section)
ffsengine.cpp:        fileIndex = model->findParentOfType(index, Types::File);
ffsengine.cpp:    // Rebase all PEI-files that follow
ffsengine.cpp:    model->setAction(index, Actions::Rebuild);
ffsengine.cpp:    if (model->type(index) == Types::Volume && model->rowCount(index) > 0)
ffsengine.cpp:    else if (model->type(index) == Types::File)
ffsengine.cpp:    else if (model->type(index) == Types::Section)
ffsengine.cpp:        fileIndex = model->findParentOfType(index, Types::File);
ffsengine.cpp:    // Rebase all PEI-files that follow
ffsengine.cpp:    model->setAction(index, Actions::DoNotRebuild);
ffsengine.cpp:        if (header->CompSize + sizeof(EFI_TIANO_HEADER) != dataSize)
ffsengine.cpp:            // We must determine section header size by checking it's type before we can unpack that non-standard compressed section
ffsengine.cpp:    pad = QByteArray(size - guid.size(), erasePolarity == ERASE_POLARITY_TRUE ? '\xFF' : '\x00');
ffsengine.cpp:    uint32ToUint24(size, header->Size);
ffsengine.cpp:    header->Attributes = 0x00;
ffsengine.cpp:    header->Type = EFI_FV_FILETYPE_PAD;
ffsengine.cpp:    header->State = EFI_FILE_HEADER_CONSTRUCTION | EFI_FILE_HEADER_VALID | EFI_FILE_DATA_VALID;
ffsengine.cpp:        header->State = ~header->State;
ffsengine.cpp:    header->IntegrityCheck.Checksum.Header = 0;
ffsengine.cpp:    header->IntegrityCheck.Checksum.File = 0;
ffsengine.cpp:    header->IntegrityCheck.Checksum.Header = calculateChecksum8((const UINT8*)header, sizeof(EFI_FFS_FILE_HEADER) - 1);
ffsengine.cpp:        header->IntegrityCheck.Checksum.File = FFS_FIXED_CHECKSUM;
ffsengine.cpp:        header->IntegrityCheck.Checksum.File = FFS_FIXED_CHECKSUM2;
ffsengine.cpp:    if (model->action(index) == Actions::NoAction || model->action(index) == Actions::DoNotRebuild) {
ffsengine.cpp:        reconstructed = model->header(index).append(model->body(index));
ffsengine.cpp:    else if (model->action(index) == Actions::Rebuild) {
ffsengine.cpp:        if (descriptorMap->MasterBase > FLASH_DESCRIPTOR_MAX_BASE
ffsengine.cpp:            || descriptorMap->MasterBase == descriptorMap->RegionBase
ffsengine.cpp:            || descriptorMap->MasterBase == descriptorMap->ComponentBase) {
ffsengine.cpp:            msg(tr("reconstructIntelImage: invalid descriptor master base %1h").hexarg2(descriptorMap->MasterBase, 2));
ffsengine.cpp:        if (descriptorMap->RegionBase > FLASH_DESCRIPTOR_MAX_BASE
ffsengine.cpp:            || descriptorMap->RegionBase == descriptorMap->ComponentBase) {
ffsengine.cpp:            msg(tr("reconstructIntelImage: invalid descriptor region base %1h").hexarg2(descriptorMap->RegionBase, 2));
ffsengine.cpp:        if (descriptorMap->ComponentBase > FLASH_DESCRIPTOR_MAX_BASE) {
ffsengine.cpp:            msg(tr("reconstructIntelImage: invalid descriptor component base %1h").hexarg2(descriptorMap->ComponentBase, 2));
ffsengine.cpp:        const FLASH_DESCRIPTOR_REGION_SECTION* regionSection = (const FLASH_DESCRIPTOR_REGION_SECTION*)calculateAddress8((const UINT8*)descriptor.constData(), descriptorMap->RegionBase);
ffsengine.cpp:        UINT32 gbeBegin = calculateRegionOffset(regionSection->GbeBase);
ffsengine.cpp:        UINT32 gbeEnd = gbeBegin + calculateRegionSize(regionSection->GbeBase, regionSection->GbeLimit);
ffsengine.cpp:        UINT32 meBegin = calculateRegionOffset(regionSection->MeBase);
ffsengine.cpp:        UINT32 meEnd = meBegin + calculateRegionSize(regionSection->MeBase, regionSection->MeLimit);
ffsengine.cpp:        UINT32 biosBegin = calculateRegionOffset(regionSection->BiosBase);
ffsengine.cpp:        UINT32 biosEnd = calculateRegionSize(regionSection->BiosBase, regionSection->BiosLimit);
ffsengine.cpp:        if (biosEnd - biosBegin == (UINT32)(model->header(index).size() + model->body(index).size())) {
ffsengine.cpp:            biosEnd = model->header(index).size() + model->body(index).size();
ffsengine.cpp:        UINT32 pdrBegin = calculateRegionOffset(regionSection->PdrBase);
ffsengine.cpp:        UINT32 pdrEnd = pdrBegin + calculateRegionSize(regionSection->PdrBase, regionSection->PdrLimit);
ffsengine.cpp:        const FLASH_DESCRIPTOR_COMPONENT_SECTION* componentSection = (const FLASH_DESCRIPTOR_COMPONENT_SECTION*)calculateAddress8((const UINT8*)descriptor.constData(), descriptorMap->ComponentBase);
ffsengine.cpp:        if (componentSection->FlashParameters.ReadClockFrequency == FLASH_FREQUENCY_20MHZ) // Legacy descriptor
ffsengine.cpp:        if (descriptorVersion == 2 && descriptorMap->DescriptorVersion != FLASH_DESCRIPTOR_VERSION_INVALID) {
ffsengine.cpp:            const FLASH_DESCRIPTOR_VERSION *version = (const FLASH_DESCRIPTOR_VERSION *)&descriptorMap->DescriptorVersion;
ffsengine.cpp:            if (version->Major != FLASH_DESCRIPTOR_VERSION_MAJOR || version->Minor != FLASH_DESCRIPTOR_VERSION_MINOR)
ffsengine.cpp:                    .arg(version->Major).arg(version->Minor));
ffsengine.cpp:            ecBegin = calculateRegionOffset(regionSection->EcBase);
ffsengine.cpp:            ecEnd = ecBegin + calculateRegionSize(regionSection->EcBase, regionSection->EcLimit);
ffsengine.cpp:        for (int i = 1; i < model->rowCount(index); i++) {
ffsengine.cpp:            if (model->type(index.child(i, 0)) == Types::Padding) {
ffsengine.cpp:                region = model->body(index.child(i, 0));
ffsengine.cpp:            switch (model->subtype(index.child(i, 0)))
ffsengine.cpp:                    reconstructed.append(QByteArray(gbeBegin - offset, empty));
ffsengine.cpp:                    reconstructed.append(QByteArray(meBegin - offset, empty));
ffsengine.cpp:                    reconstructed.append(QByteArray(biosBegin - offset, empty));
ffsengine.cpp:                    reconstructed.append(QByteArray(pdrBegin - offset, empty));
ffsengine.cpp:                    reconstructed.append(QByteArray(ecBegin - offset, empty));
ffsengine.cpp:        if ((UINT32)model->body(index).size() > offset)
ffsengine.cpp:            reconstructed.append(QByteArray((UINT32)model->body(index).size() - offset, empty));
ffsengine.cpp:        if (reconstructed.size() > model->body(index).size()) {
ffsengine.cpp:                .hexarg(model->body(index).size()).arg(model->body(index).size()),
ffsengine.cpp:        else if (reconstructed.size() < model->body(index).size()) {
ffsengine.cpp:                .hexarg(model->body(index).size()).arg(model->body(index).size()),
ffsengine.cpp:    if (model->action(index) == Actions::NoAction || model->action(index) == Actions::DoNotRebuild) {
ffsengine.cpp:        reconstructed = model->header(index).append(model->body(index));
ffsengine.cpp:    else if (model->action(index) == Actions::Remove) {
ffsengine.cpp:    else if (model->action(index) == Actions::Rebuild ||
ffsengine.cpp:        model->action(index) == Actions::Replace) {
ffsengine.cpp:        if (model->rowCount(index)) {
ffsengine.cpp:            for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:            reconstructed = model->body(index);
ffsengine.cpp:        if (reconstructed.size() > model->body(index).size()) {
ffsengine.cpp:                .hexarg(model->body(index).size()).arg(model->body(index).size()),
ffsengine.cpp:        else if (reconstructed.size() < model->body(index).size()) {
ffsengine.cpp:                .hexarg(model->body(index).size()).arg(model->body(index).size()),
ffsengine.cpp:            reconstructed = model->header(index).append(reconstructed);
ffsengine.cpp:    if (model->action(index) == Actions::NoAction || model->action(index) == Actions::DoNotRebuild) {
ffsengine.cpp:        reconstructed = model->body(index);
ffsengine.cpp:    else if (model->action(index) == Actions::Remove) {
ffsengine.cpp:    else if (model->action(index) == Actions::Rebuild ||
ffsengine.cpp:        model->action(index) == Actions::Replace) {
ffsengine.cpp:        reconstructed = model->body(index);
ffsengine.cpp:        if (reconstructed.size() > model->body(index).size()) {
ffsengine.cpp:                .hexarg(model->body(index).size()).arg(model->body(index).size()),
ffsengine.cpp:        else if (reconstructed.size() < model->body(index).size()) {
ffsengine.cpp:                .hexarg(model->body(index).size()).arg(model->body(index).size()),
ffsengine.cpp:    if (model->action(index) == Actions::NoAction || model->action(index) == Actions::DoNotRebuild) {
ffsengine.cpp:        reconstructed = model->header(index).append(model->body(index));
ffsengine.cpp:    else if (model->action(index) == Actions::Remove) {
ffsengine.cpp:    else if (model->action(index) == Actions::Replace ||
ffsengine.cpp:        model->action(index) == Actions::Rebuild) {
ffsengine.cpp:        QByteArray header = model->header(index);
ffsengine.cpp:        QByteArray body = model->body(index);
ffsengine.cpp:        if (volumeHeader->HeaderLength > header.size()) {
ffsengine.cpp:        volumeHeader->Checksum = 0;
ffsengine.cpp:        volumeHeader->Checksum = calculateChecksum16((const UINT16*)volumeHeader, volumeHeader->HeaderLength);
ffsengine.cpp:        if (model->rowCount(index)) {
ffsengine.cpp:            UINT8 polarity = volumeHeader->Attributes & EFI_FVB_ERASE_POLARITY ? ERASE_POLARITY_TRUE : ERASE_POLARITY_FALSE;
ffsengine.cpp:            char empty = volumeHeader->Attributes & EFI_FVB_ERASE_POLARITY ? '\xFF' : '\x00';
ffsengine.cpp:            for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:                file = model->header(index.child(i, 0));
ffsengine.cpp:                    volumeBase = (UINT32)(0x100000000 - volumeSize);
ffsengine.cpp:                for (QModelIndex parentIndex = index.parent(); model->type(parentIndex) != Types::Root; parentIndex = parentIndex.parent())
ffsengine.cpp:                    if (model->compression(parentIndex) != COMPRESSION_ALGORITHM_NONE) {
ffsengine.cpp:                // Search for first PEI-file and use it as base source
ffsengine.cpp:                for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:                    if ((model->subtype(index.child(i, 0)) == EFI_FV_FILETYPE_PEI_CORE ||
ffsengine.cpp:                        model->subtype(index.child(i, 0)) == EFI_FV_FILETYPE_PEIM ||
ffsengine.cpp:                        model->subtype(index.child(i, 0)) == EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER)){
ffsengine.cpp:                        for (int j = 0; j < model->rowCount(peiFile); j++) {
ffsengine.cpp:                            if (model->subtype(peiFile.child(j, 0)) == EFI_SECTION_PE32 ||
ffsengine.cpp:                                model->subtype(peiFile.child(j, 0)) == EFI_SECTION_TE) {
ffsengine.cpp:                                if (model->action(image) == Actions::Remove || model->action(image) == Actions::Insert)
ffsengine.cpp:                                UINT32 relbase = fileOffset + sectionOffset + model->header(image).size();
ffsengine.cpp:                                result = getBase(model->body(image), imagebase); // imagebase passed by reference
ffsengine.cpp:                                    volumeBase = imagebase - relbase;
ffsengine.cpp:                            sectionOffset += model->header(peiFile.child(j, 0)).size() + model->body(peiFile.child(j, 0)).size();
ffsengine.cpp:                    fileOffset += model->header(index.child(i, 0)).size() + model->body(index.child(i, 0)).size();
ffsengine.cpp:            for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:                // Inside a volume can be files, free space or padding with non-UEFI data
ffsengine.cpp:                if (model->type(index.child(i, 0)) == Types::File) { // Next item is a file
ffsengine.cpp:                        alignment = 8 - alignment;
ffsengine.cpp:                    result = reconstructFile(index.child(i, 0), volumeHeader->Revision, polarity, fileBase, file);
ffsengine.cpp:                    if (volumeHeader->Revision > 1 && (fileHeader->Attributes & FFS_ATTRIB_LARGE_FILE))
ffsengine.cpp:                    if (fileHeader->Type == EFI_FV_FILETYPE_PAD) {
ffsengine.cpp:                        if (model->action(index.child(i, 0)) == Actions::DoNotRebuild) {
ffsengine.cpp:                        // Parse non-empty pad file
ffsengine.cpp:                        else if (model->rowCount(index.child(i, 0))) {
ffsengine.cpp:                        // Skip empty pad-file
ffsengine.cpp:                    UINT8 alignmentPower = ffsAlignmentTable[(fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT) >> 3];
ffsengine.cpp:                        UINT32 size = alignment - (alignmentBase % alignment);
ffsengine.cpp:                        result = constructPadFile(padFileGuid, size, volumeHeader->Revision, polarity, pad);
ffsengine.cpp:                else if (model->type(index.child(i, 0)) == Types::FreeSpace) { //Next item is a free space
ffsengine.cpp:                    if (offset + (UINT32)model->body(index.child(i, 0)).size() < (UINT32)model->body(index).size()) {
ffsengine.cpp:                        // Get non-UEFI data and it's offset
ffsengine.cpp:                        nonUefiData = model->body(index.child(i + 1, 0));
ffsengine.cpp:                        nonUefiDataOffset = body.size() - nonUefiData.size();
ffsengine.cpp:                msg(tr("reconstructVolume: both VTF and non-UEFI data found in the volume, reconstruction is not possible"), index);
ffsengine.cpp:            if (model->text(index).contains("AppleFSO ")) {
ffsengine.cpp:                freeSpaceOffset = model->header(index).size() + offset;
ffsengine.cpp:                    alignment = 8 - alignment;
ffsengine.cpp:            // Insert VTF or non-UEFI data to it's correct place
ffsengine.cpp:                UINT32 vtfOffset = model->body(index).size() - vtf.size();
ffsengine.cpp:                    UINT32 size = vtfOffset - offset;
ffsengine.cpp:                    result = constructPadFile(padFileGuid, size, volumeHeader->Revision, polarity, pad);
ffsengine.cpp:                        .hexarg(offset - vtfOffset).arg(offset - vtfOffset), index);
ffsengine.cpp:                result = reconstructFile(vtfIndex, volumeHeader->Revision, polarity, vtfBase, vtf);
ffsengine.cpp:            else if (!nonUefiData.isEmpty()) { //Non-UEFI data found
ffsengine.cpp:                    msg(tr("reconstructVolume: no space left to insert non-UEFI data, need %1h (%2) byte(s) more")
ffsengine.cpp:                        .hexarg(offset - nonUefiDataOffset).arg(offset - nonUefiDataOffset), index);
ffsengine.cpp:                    reconstructed.append(QByteArray(nonUefiDataOffset - offset, empty));
ffsengine.cpp:                    reconstructed.append(QByteArray(body.size() - reconstructed.size(), empty));
ffsengine.cpp:                    UINT8 parentType = model->type(index.parent());
ffsengine.cpp:                    reconstructed.append(QByteArray(newSize - header.size() - reconstructed.size(), empty));
ffsengine.cpp:            reconstructed = model->body(index);
ffsengine.cpp:        if (model->text(index).contains("AppleCRC32 ")) {
ffsengine.cpp:            UINT32 crc = crc32(0, (const UINT8*)reconstructed.constData() + volumeHeader->HeaderLength, reconstructed.size() - volumeHeader->HeaderLength);
ffsengine.cpp:                volumeHeader->Checksum = 0;
ffsengine.cpp:                volumeHeader->Checksum = calculateChecksum16((const UINT16*)volumeHeader, volumeHeader->HeaderLength);
ffsengine.cpp:        if (model->text(index).contains("AppleFSO ")) {
ffsengine.cpp:                volumeHeader->Checksum = 0;
ffsengine.cpp:                volumeHeader->Checksum = calculateChecksum16((const UINT16*)volumeHeader, volumeHeader->HeaderLength);
ffsengine.cpp:    if (model->action(index) == Actions::NoAction || model->action(index) == Actions::DoNotRebuild) {
ffsengine.cpp:        reconstructed = model->header(index).append(model->body(index));
ffsengine.cpp:        const EFI_FFS_FILE_HEADER* fileHeader = (const EFI_FFS_FILE_HEADER*)model->header(index).constData();
ffsengine.cpp:        if (fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT) {
ffsengine.cpp:            UINT8 ht = ~fileHeader->IntegrityCheck.Checksum.Header;
ffsengine.cpp:            UINT8 ft = ~fileHeader->IntegrityCheck.Checksum.File;
ffsengine.cpp:    else if (model->action(index) == Actions::Remove) {
ffsengine.cpp:    else if (model->action(index) == Actions::Insert ||
ffsengine.cpp:        model->action(index) == Actions::Replace ||
ffsengine.cpp:        model->action(index) == Actions::Rebuild) {
ffsengine.cpp:        QByteArray header = model->header(index);
ffsengine.cpp:        UINT8 state = fileHeader->State;
ffsengine.cpp:        if (model->rowCount(index)) {
ffsengine.cpp:            if (model->subtype(index) == EFI_FV_FILETYPE_ALL || model->subtype(index) == EFI_FV_FILETYPE_RAW) {
ffsengine.cpp:                if (revision > 1 && (fileHeader->Attributes & FFS_ATTRIB_LARGE_FILE)) {
ffsengine.cpp:                for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:                        alignment = 4 - alignment;
ffsengine.cpp:                    UINT8 alignmentPower = ffsAlignmentTable[(fileHeader->Attributes & FFS_ATTRIB_DATA_ALIGNMENT) >> 3];
ffsengine.cpp:                        UINT32 size = fileAlignment - (alignmentBase % fileAlignment);
ffsengine.cpp:            reconstructed = model->body(index);
ffsengine.cpp:        UINT8 tailSize = (revision == 1 && (fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT)) ? sizeof(UINT16) : 0;
ffsengine.cpp:        if (revision > 1 && (fileHeader->Attributes & FFS_ATTRIB_LARGE_FILE)) {
ffsengine.cpp:            uint32ToUint24(EFI_SECTION2_IS_USED, fileHeader->Size);
ffsengine.cpp:            fileHeader2->ExtendedSize = sizeof(EFI_FFS_FILE_HEADER2) + reconstructed.size() + tailSize;
ffsengine.cpp:            uint32ToUint24(sizeof(EFI_FFS_FILE_HEADER) + reconstructed.size() + tailSize, fileHeader->Size);
ffsengine.cpp:        fileHeader->IntegrityCheck.Checksum.Header = 0;
ffsengine.cpp:        fileHeader->IntegrityCheck.Checksum.File = 0;
ffsengine.cpp:        fileHeader->IntegrityCheck.Checksum.Header = 0x100 - (calculateSum8((const UINT8*)header.constData(), header.size()) - fileHeader->State);
ffsengine.cpp:        if (fileHeader->Attributes & FFS_ATTRIB_CHECKSUM) {
ffsengine.cpp:            fileHeader->IntegrityCheck.Checksum.File = calculateChecksum8((const UINT8*)reconstructed.constData(), reconstructed.size());
ffsengine.cpp:            fileHeader->IntegrityCheck.Checksum.File = FFS_FIXED_CHECKSUM;
ffsengine.cpp:            fileHeader->IntegrityCheck.Checksum.File = FFS_FIXED_CHECKSUM2;
ffsengine.cpp:        if (revision == 1 && fileHeader->Attributes & FFS_ATTRIB_TAIL_PRESENT) {
ffsengine.cpp:            UINT8 ht = ~fileHeader->IntegrityCheck.Checksum.Header;
ffsengine.cpp:            UINT8 ft = ~fileHeader->IntegrityCheck.Checksum.File;
ffsengine.cpp:        fileHeader->State = state;
ffsengine.cpp:    if (model->action(index) == Actions::NoAction || model->action(index) == Actions::DoNotRebuild) {
ffsengine.cpp:        reconstructed = model->header(index).append(model->body(index));
ffsengine.cpp:    else if (model->action(index) == Actions::Remove) {
ffsengine.cpp:    else if (model->action(index) == Actions::Insert ||
ffsengine.cpp:        model->action(index) == Actions::Replace ||
ffsengine.cpp:        model->action(index) == Actions::Rebuild ||
ffsengine.cpp:        model->action(index) == Actions::Rebase) {
ffsengine.cpp:        QByteArray header = model->header(index);
ffsengine.cpp:        if (uint24ToUint32(commonHeader->Size) == 0xFFFFFF) {
ffsengine.cpp:        if (model->rowCount(index)) {
ffsengine.cpp:            for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:                    alignment = 4 - alignment;
ffsengine.cpp:            if (model->subtype(index) == EFI_SECTION_COMPRESSION) {
ffsengine.cpp:                compessionHeader->UncompressedLength = reconstructed.size();
ffsengine.cpp:                if (model->compression(index) == COMPRESSION_ALGORITHM_NONE) {
ffsengine.cpp:                    compessionHeader->CompressionType = EFI_NOT_COMPRESSED;
ffsengine.cpp:                else if (model->compression(index) == COMPRESSION_ALGORITHM_EFI11 || model->compression(index) == COMPRESSION_ALGORITHM_TIANO) {
ffsengine.cpp:                    compessionHeader->CompressionType = EFI_STANDARD_COMPRESSION;
ffsengine.cpp:                else if (model->compression(index) == COMPRESSION_ALGORITHM_LZMA) {
ffsengine.cpp:                    compessionHeader->CompressionType = EFI_CUSTOMIZED_COMPRESSION;
ffsengine.cpp:                else if (model->compression(index) == COMPRESSION_ALGORITHM_IMLZMA) {
ffsengine.cpp:                    compessionHeader->CompressionType = EFI_CUSTOMIZED_COMPRESSION;
ffsengine.cpp:                result = compress(reconstructed, model->compression(index), model->dictionarySize(index), compressed);
ffsengine.cpp:            else if (model->subtype(index) == EFI_SECTION_GUID_DEFINED) {
ffsengine.cpp:                if (QByteArray((const char*)&guidDefinedHeader->SectionDefinitionGuid, sizeof(EFI_GUID)) == EFI_GUIDED_SECTION_LZMAF86) {
ffsengine.cpp:                result = compress(reconstructed, model->compression(index), model->dictionarySize(index), compressed);
ffsengine.cpp:                if (guidDefinedHeader->Attributes & EFI_GUIDED_SECTION_AUTH_STATUS_VALID) {
ffsengine.cpp:                    if (QByteArray((const char*)&guidDefinedHeader->SectionDefinitionGuid, sizeof(EFI_GUID)) == EFI_GUIDED_SECTION_CRC32) {
ffsengine.cpp:                            .arg(guidToQString(guidDefinedHeader->SectionDefinitionGuid)), index);
ffsengine.cpp:                if (guidDefinedHeader->Attributes & EFI_GUIDED_SECTION_PROCESSING_REQUIRED
ffsengine.cpp:                    && QByteArray((const char*)&guidDefinedHeader->SectionDefinitionGuid, sizeof(EFI_GUID)) == EFI_FIRMWARE_CONTENTS_SIGNED_GUID) {
ffsengine.cpp:                        .arg(guidToQString(guidDefinedHeader->SectionDefinitionGuid)), index);
ffsengine.cpp:            else if (model->compression(index) != COMPRESSION_ALGORITHM_NONE) {
ffsengine.cpp:                    .arg(model->subtype(index)), index);
ffsengine.cpp:            reconstructed = model->body(index);
ffsengine.cpp:            extHeader->ExtendedSize = header.size() + reconstructed.size();
ffsengine.cpp:            uint32ToUint24(0xFFFFFF, commonHeader->Size);
ffsengine.cpp:            uint32ToUint24(header.size() + reconstructed.size(), commonHeader->Size);
ffsengine.cpp:        if ((model->subtype(index) == EFI_SECTION_PE32 || model->subtype(index) == EFI_SECTION_TE) &&
ffsengine.cpp:            (model->subtype(index.parent()) == EFI_FV_FILETYPE_PEI_CORE ||
ffsengine.cpp:                model->subtype(index.parent()) == EFI_FV_FILETYPE_PEIM ||
ffsengine.cpp:                model->subtype(index.parent()) == EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER)) {
ffsengine.cpp:            //if (model->subtype(index) == EFI_SECTION_TE) {
ffsengine.cpp:            //  const EFI_IMAGE_TE_HEADER* teHeader = (const EFI_IMAGE_TE_HEADER*)model->body(index).constData();
ffsengine.cpp:            //  teFixup = teHeader->StrippedSize - sizeof(EFI_IMAGE_TE_HEADER);
ffsengine.cpp:                result = rebase(reconstructed, base - teFixup + header.size(), index);
ffsengine.cpp:                if (model->subtype(index.parent()) == EFI_FV_FILETYPE_PEI_CORE) {
ffsengine.cpp:    switch (model->type(index)) {
ffsengine.cpp:        if (model->subtype(index) == Subtypes::IntelImage) {
ffsengine.cpp:        msg(tr("reconstruct: call of generic function is not supported for files").arg(model->type(index)), index);
ffsengine.cpp:        msg(tr("reconstruct: unknown item type %1").arg(model->type(index)), index);
ffsengine.cpp:    UINT32 blockMapSize = volumeHeader->HeaderLength - sizeof(EFI_FIRMWARE_VOLUME_HEADER);
ffsengine.cpp:    if (blockMap[blockMapCount - 1].NumBlocks != 0 || blockMap[blockMapCount - 1].Length != 0)
ffsengine.cpp:    newSize += blockMap[0].Length - newSize % blockMap[0].Length;
ffsengine.cpp:    volumeHeader->FvLength = 0;
ffsengine.cpp:        volumeHeader->FvLength += blockMap[i].NumBlocks * blockMap[i].Length;
ffsengine.cpp:    volumeHeader->Checksum = 0;
ffsengine.cpp:    volumeHeader->Checksum = calculateChecksum16((const UINT16*)volumeHeader, volumeHeader->HeaderLength);
ffsengine.cpp:    return reconstruct(model->index(0, 0), reconstructed);
ffsengine.cpp:    bool hasChildren = (model->rowCount(index) > 0);
ffsengine.cpp:    for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:            data = model->header(index);
ffsengine.cpp:            data.append(model->header(index));
ffsengine.cpp:            data.append(model->body(index));
ffsengine.cpp:            data.append(model->header(index)).append(model->body(index));
ffsengine.cpp:            msg(tr("Hex pattern \"%1\" found as \"%2\" in %3 at %4-offset %5h")
ffsengine.cpp:                .arg(model->name(index))
ffsengine.cpp:    bool hasChildren = (model->rowCount(index) > 0);
ffsengine.cpp:    for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:            data = model->header(index);
ffsengine.cpp:            data.append(model->header(index));
ffsengine.cpp:            data.append(model->body(index));
ffsengine.cpp:            data.append(model->header(index)).append(model->body(index));
ffsengine.cpp:    QList<QByteArray> list = guidPattern.split('-');
ffsengine.cpp:            msg(tr("GUID pattern \"%1\" found as \"%2\" in %3 at %4-offset %5h")
ffsengine.cpp:                .arg(model->name(index))
ffsengine.cpp:    bool hasChildren = (model->rowCount(index) > 0);
ffsengine.cpp:    for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:        data = QString::fromUtf16((const ushort*)model->body(index).data(), model->body(index).length() / 2);
ffsengine.cpp:        data = QString::fromLatin1((const char*)model->body(index).data(), model->body(index).length());
ffsengine.cpp:    int offset = -1;
ffsengine.cpp:            .arg(model->name(index))
ffsengine.cpp:    if (dosHeader->e_magic == EFI_IMAGE_DOS_SIGNATURE){
ffsengine.cpp:        UINT32 offset = dosHeader->e_lfanew;
ffsengine.cpp:        if (peHeader->Signature != EFI_IMAGE_PE_SIGNATURE)
ffsengine.cpp:            delta = base - optHeader->ImageBase;
ffsengine.cpp:            relocOffset = optHeader->DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
ffsengine.cpp:            relocSize = optHeader->DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
ffsengine.cpp:            optHeader->ImageBase = base;
ffsengine.cpp:            delta = base - optHeader->ImageBase;
ffsengine.cpp:            relocOffset = optHeader->DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
ffsengine.cpp:            relocSize = optHeader->DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
ffsengine.cpp:            optHeader->ImageBase = base;
ffsengine.cpp:    else if (dosHeader->e_magic == EFI_IMAGE_TE_SIGNATURE){
ffsengine.cpp:        delta = base - teHeader->ImageBase;
ffsengine.cpp:        relocOffset = teHeader->DataDirectory[EFI_IMAGE_TE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
ffsengine.cpp:        teFixup = teHeader->StrippedSize - sizeof(EFI_IMAGE_TE_HEADER);
ffsengine.cpp:        relocSize = teHeader->DataDirectory[EFI_IMAGE_TE_DIRECTORY_ENTRY_BASERELOC].Size;
ffsengine.cpp:        teHeader->ImageBase = base;
ffsengine.cpp:    RelocBase = (EFI_IMAGE_BASE_RELOCATION*)(file.data() + relocOffset - teFixup);
ffsengine.cpp:    RelocBaseEnd = (EFI_IMAGE_BASE_RELOCATION*)(file.data() + relocOffset - teFixup + relocSize);
ffsengine.cpp:        RelocEnd = (UINT16*)((UINT8*)RelocBase + RelocBase->SizeOfBlock);
ffsengine.cpp:            UINT32 RelocLocation = RelocBase->VirtualAddress - teFixup + (*Reloc & 0x0FFF);
ffsengine.cpp:    if (i == -1) {
ffsengine.cpp:    if (dosHeader->e_magic == EFI_IMAGE_DOS_SIGNATURE){
ffsengine.cpp:        UINT32 offset = dosHeader->e_lfanew;
ffsengine.cpp:        if (peHeader->Signature != EFI_IMAGE_PE_SIGNATURE)
ffsengine.cpp:            entryPoint = optHeader->ImageBase + optHeader->AddressOfEntryPoint;
ffsengine.cpp:            entryPoint = optHeader->ImageBase + optHeader->AddressOfEntryPoint;
ffsengine.cpp:    else if (dosHeader->e_magic == EFI_IMAGE_TE_SIGNATURE){
ffsengine.cpp:        UINT32 teFixup = teHeader->StrippedSize - sizeof(EFI_IMAGE_TE_HEADER);
ffsengine.cpp:        entryPoint = teHeader->ImageBase + teHeader->AddressOfEntryPoint - teFixup;
ffsengine.cpp:    if (dosHeader->e_magic == EFI_IMAGE_DOS_SIGNATURE){
ffsengine.cpp:        UINT32 offset = dosHeader->e_lfanew;
ffsengine.cpp:        if (peHeader->Signature != EFI_IMAGE_PE_SIGNATURE)
ffsengine.cpp:            base = optHeader->ImageBase;
ffsengine.cpp:            base = optHeader->ImageBase;
ffsengine.cpp:    else if (dosHeader->e_magic == EFI_IMAGE_TE_SIGNATURE){
ffsengine.cpp:        base = teHeader->ImageBase;
ffsengine.cpp:        guidToQString(*(const EFI_GUID*)model->header(index).constData()) == guid ||
ffsengine.cpp:        guidToQString(*(const EFI_GUID*)model->header(model->findParentOfType(index, Types::File)).constData()) == guid) {
ffsengine.cpp:        if (!model->header(index).isEmpty()) {
ffsengine.cpp:            file.write(model->header(index));
ffsengine.cpp:        if (!model->body(index).isEmpty()) {
ffsengine.cpp:            file.write(model->body(index));
ffsengine.cpp:            .arg(itemTypeToQString(model->type(index)))
ffsengine.cpp:            .arg(itemSubtypeToQString(model->type(index), model->subtype(index)))
ffsengine.cpp:            .arg(model->text(index).isEmpty() ? "" : tr("Text: %1\n").arg(model->text(index)))
ffsengine.cpp:            .arg(model->info(index));
ffsengine.cpp:    for (int i = 0; i < model->rowCount(index); i++) {
ffsengine.cpp:        QString childPath = QString("%1/%2 %3").arg(path).arg(i).arg(model->text(childIndex).isEmpty() ? model->name(childIndex) : model->text(childIndex));
ffsengine.cpp:    if (!index.isValid() || patches.isEmpty() || model->rowCount(index))
ffsengine.cpp:    if (model->action(index) == Actions::Remove)
ffsengine.cpp:    QByteArray body = model->body(index);
ffsengine.cpp:    if (body != model->body(index)) {
ffsengine.cpp:        QByteArray patched = model->header(index);
ffsengine.cpp:    if (offset > (UINT32)(body.length() - hexReplacePattern.length() / 2))
ffsengine.cpp:    msg(tr("patch: replaced %1 bytes at offset %2h %3 -> %4")
peimage.h:Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.
peimage.h:Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.
peimage.h:http://opensource.org/licenses/bsd-license.php.
peimage.h:    // Optional Header Windows-Specific Fields.
peimage.h:    // Optional Header Windows-Specific Fields.
peimage.h:#define EFI_IMAGE_SYM_ABSOLUTE  (UINT16) -1 ///< Symbol is an absolute value
peimage.h:#define EFI_IMAGE_SYM_DEBUG     (UINT16) -2 ///< Symbol is a special debug item
peimage.h:#define EFI_IMAGE_SYM_CLASS_END_OF_FUNCTION   ((UINT8) -1)
peimage.h:#define EFI_IMAGE_REL_I386_DIR16    0x0001  // Direct 16-bit reference to the symbols virtual address
peimage.h:#define EFI_IMAGE_REL_I386_REL16    0x0002  // PC-relative 16-bit reference to the symbols virtual address
peimage.h:#define EFI_IMAGE_REL_I386_DIR32    0x0006  // Direct 32-bit reference to the symbols virtual address
peimage.h:#define EFI_IMAGE_REL_I386_DIR32NB  0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
peimage.h:#define EFI_IMAGE_REL_I386_SEG12    0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
peimage.h:#define EFI_IMAGE_REL_I386_REL32    0x0014  // PC-relative 32-bit reference to the symbols virtual address
peimage.h:    UINT8 Name[16];     // File member name - `/' terminated
peimage.h:    UINT8 Date[12];     // File member date - decimal
peimage.h:    UINT8 UserID[6];    // File member user id - decimal
peimage.h:    UINT8 GroupID[6];   // File member group id - decimal
peimage.h:    UINT8 Mode[8];      // File member mode - octal
peimage.h:    UINT8 Size[10];     // File member size - decimal
peimage.h:// Debug Data Structure defined by Apple Mach-O to COFF utility.
peimage.h:    //  Filename of .DLL (Mach-O with debug info) goes here
peimage.h:    UINT32                    AddressOfEntryPoint;  // Offset to entry point -- from original optional header
peimage.h:    UINT32                    BaseOfCode;           // From original image -- required for ITP debug
ffsengine.h:http://opensource.org/licenses/bsd-license.php
uefitool.h:  http://opensource.org/licenses/bsd-license.php
uefitool_main.cpp:  http://opensource.org/licenses/bsd-license.php
guidlineedit.cpp:  http://opensource.org/licenses/bsd-license.php
guidlineedit.cpp:    if (event == QKeySequence::Delete || event->key() == Qt::Key_Backspace)
guidlineedit.cpp:        if (event->key() == Qt::Key_Backspace && pos > 0) {
guidlineedit.cpp:                if (txt[i] != QChar('-'))
UEFIReplace/moc_uefireplace.cpp:        - idx * sizeof(QByteArrayData)) \
UEFIReplace/moc_uefireplace.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
UEFIReplace/uefireplace.h:http://opensource.org/licenses/bsd-license.php
UEFIReplace/uefireplace.pro:QT       -= gui
UEFIReplace/uefireplace.pro:CONFIG   -= app_bundle
UEFIReplace/moc_treemodel.cpp:        - idx * sizeof(QByteArrayData)) \
UEFIReplace/moc_treemodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
UEFIReplace/moc_predefs.h:#define __DBL_MIN_EXP__ (-1021)
UEFIReplace/moc_predefs.h:#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
UEFIReplace/moc_predefs.h:#define __FLT32_MIN_EXP__ (-125)
UEFIReplace/moc_predefs.h:#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
UEFIReplace/moc_predefs.h:#define __DBL_MIN_10_EXP__ (-307)
UEFIReplace/moc_predefs.h:#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
UEFIReplace/moc_predefs.h:#define __DEC32_EPSILON__ 1E-6DF
UEFIReplace/moc_predefs.h:#define __FLT128_MIN_EXP__ (-16381)
UEFIReplace/moc_predefs.h:#define __FLT128_MIN_10_EXP__ (-4931)
UEFIReplace/moc_predefs.h:#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
UEFIReplace/moc_predefs.h:#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
UEFIReplace/moc_predefs.h:#define __DEC64_MIN_EXP__ (-382)
UEFIReplace/moc_predefs.h:#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
UEFIReplace/moc_predefs.h:#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
UEFIReplace/moc_predefs.h:#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
UEFIReplace/moc_predefs.h:#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
UEFIReplace/moc_predefs.h:#define __FLT64_MIN_EXP__ (-1021)
UEFIReplace/moc_predefs.h:#define __FLT64X_MIN_10_EXP__ (-4931)
UEFIReplace/moc_predefs.h:#define __DEC32_MIN_EXP__ (-94)
UEFIReplace/moc_predefs.h:#define __DEC32_MIN__ 1E-95DF
UEFIReplace/moc_predefs.h:#define __DEC128_EPSILON__ 1E-33DL
UEFIReplace/moc_predefs.h:#define __FLT64X_MIN_EXP__ (-16381)
UEFIReplace/moc_predefs.h:#define __FLT_MIN_EXP__ (-125)
UEFIReplace/moc_predefs.h:#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
UEFIReplace/moc_predefs.h:#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
UEFIReplace/moc_predefs.h:#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
UEFIReplace/moc_predefs.h:#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
UEFIReplace/moc_predefs.h:#define __FLT64_MIN_10_EXP__ (-307)
UEFIReplace/moc_predefs.h:#define __DEC128_MIN__ 1E-6143DL
UEFIReplace/moc_predefs.h:#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
UEFIReplace/moc_predefs.h:#define __DEC64_EPSILON__ 1E-15DD
UEFIReplace/moc_predefs.h:#define __DEC128_MIN_EXP__ (-6142)
UEFIReplace/moc_predefs.h:#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
UEFIReplace/moc_predefs.h:#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
UEFIReplace/moc_predefs.h:#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
UEFIReplace/moc_predefs.h:#define __FLT32X_MIN_EXP__ (-1021)
UEFIReplace/moc_predefs.h:#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
UEFIReplace/moc_predefs.h:#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
UEFIReplace/moc_predefs.h:#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
UEFIReplace/moc_predefs.h:#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
UEFIReplace/moc_predefs.h:#define __FLT32_MIN_10_EXP__ (-37)
UEFIReplace/moc_predefs.h:#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
UEFIReplace/moc_predefs.h:#define __DEC64_MIN__ 1E-383DD
UEFIReplace/moc_predefs.h:#define __LDBL_MIN_EXP__ (-16381)
UEFIReplace/moc_predefs.h:#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
UEFIReplace/moc_predefs.h:#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
UEFIReplace/moc_predefs.h:#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
UEFIReplace/moc_predefs.h:#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
UEFIReplace/moc_predefs.h:#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
UEFIReplace/moc_predefs.h:#define __FLT_MIN_10_EXP__ (-37)
UEFIReplace/moc_predefs.h:#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
UEFIReplace/moc_predefs.h:#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
UEFIReplace/moc_predefs.h:#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
UEFIReplace/moc_predefs.h:#define __FLT32X_MIN_10_EXP__ (-307)
UEFIReplace/moc_predefs.h:#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
UEFIReplace/moc_predefs.h:#define __LDBL_MIN_10_EXP__ (-4931)
UEFIReplace/moc_ffsengine.cpp:        - idx * sizeof(QByteArrayData)) \
UEFIReplace/moc_ffsengine.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
UEFIReplace/uefireplace.cpp:http://opensource.org/licenses/bsd-license.php
UEFIReplace/uefireplace.cpp:    model = ffsEngine->treeModel();
UEFIReplace/uefireplace.cpp:    UINT8 result = ffsEngine->parseImageFile(buffer);
UEFIReplace/uefireplace.cpp:    result = replaceInFile(model->index(0, 0), guid, sectionType, contents,
UEFIReplace/uefireplace.cpp:    result = ffsEngine->reconstructImageFile(reconstructed);
UEFIReplace/uefireplace.cpp:    if (model->subtype(index) == sectionType) {
UEFIReplace/uefireplace.cpp:        if (model->type(index) != Types::File)
UEFIReplace/uefireplace.cpp:            fileIndex = model->findParentOfType(index, Types::File);
UEFIReplace/uefireplace.cpp:        QByteArray fileGuid = model->header(fileIndex).left(sizeof(EFI_GUID));
UEFIReplace/uefireplace.cpp:            QByteArray subGuid = model->header(index).mid(sizeof(UINT32), sizeof(EFI_GUID));
UEFIReplace/uefireplace.cpp:        if (guidMatch && model->action(index) != Actions::Replace) {
UEFIReplace/uefireplace.cpp:            UINT8 result = ffsEngine->replace(index, newData, mode);
UEFIReplace/uefireplace.cpp:    if (model->rowCount(index) > 0) {
UEFIReplace/uefireplace.cpp:        for (int i = 0; i < model->rowCount(index); i++) {
UEFIReplace/uefireplace_main.cpp:http://opensource.org/licenses/bsd-license.php
UEFIReplace/uefireplace_main.cpp:        std::cout << "UEFIReplace " PROGRAM_VERSION " - UEFI image file replacement utility" << std::endl << std::endl <<
UEFIReplace/uefireplace_main.cpp:            "Usage: UEFIReplace image_file guid section_type contents_file [-o output] [-all] [-asis]" << std::endl;
UEFIReplace/uefireplace_main.cpp:            if ((args.at(i) == "-o" || args.at(i) == "--output") && i + 1 < sz) {
UEFIReplace/uefireplace_main.cpp:            } else if (args.at(i) == "-all") {
UEFIReplace/uefireplace_main.cpp:            } else if (args.at(i) == "-asis") {
UEFIReplace/Makefile:# Command: /usr/lib/qt5/bin/qmake -o Makefile uefireplace.pro CONFIG+=optimize_size
UEFIReplace/Makefile:DEFINES       = -D_CONSOLE -DQT_NO_DEBUG -DQT_CORE_LIB
UEFIReplace/Makefile:CFLAGS        = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)
UEFIReplace/Makefile:CXXFLAGS      = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)
UEFIReplace/Makefile:INCPATH       = -I. -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I. -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++
UEFIReplace/Makefile:DEL_FILE      = rm -f
UEFIReplace/Makefile:CHK_DIR_EXISTS= test -d
UEFIReplace/Makefile:MKDIR         = mkdir -p
UEFIReplace/Makefile:COPY          = cp -f
UEFIReplace/Makefile:COPY_FILE     = cp -f
UEFIReplace/Makefile:COPY_DIR      = cp -f -R
UEFIReplace/Makefile:INSTALL_FILE  = install -m 644 -p
UEFIReplace/Makefile:INSTALL_PROGRAM = install -m 755 -p
UEFIReplace/Makefile:INSTALL_DIR   = cp -f -R
UEFIReplace/Makefile:QINSTALL      = /usr/lib/qt5/bin/qmake -install qinstall
UEFIReplace/Makefile:QINSTALL_PROGRAM = /usr/lib/qt5/bin/qmake -install qinstall -exe
UEFIReplace/Makefile:DEL_FILE      = rm -f
UEFIReplace/Makefile:SYMLINK       = ln -f -s
UEFIReplace/Makefile:MOVE          = mv -f
UEFIReplace/Makefile:TAR           = tar -cf
UEFIReplace/Makefile:COMPRESS      = gzip -9f
UEFIReplace/Makefile:DISTDIR = /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace/.tmp/UEFIReplace1.0.0
UEFIReplace/Makefile:LFLAGS        = -Wl,-O1
UEFIReplace/Makefile:LIBS          = $(SUBLIBS) /usr/lib/x86_64-linux-gnu/libQt5Core.so -lpthread   
UEFIReplace/Makefile:DIST          = /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf \
UEFIReplace/Makefile:	$(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJCOMP) $(LIBS)
UEFIReplace/Makefile:Makefile: uefireplace.pro /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf \
UEFIReplace/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf \
UEFIReplace/Makefile:	$(QMAKE) -o Makefile uefireplace.pro CONFIG+=optimize_size
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf:
UEFIReplace/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf:
UEFIReplace/Makefile:	@$(QMAKE) -o Makefile uefireplace.pro CONFIG+=optimize_size
UEFIReplace/Makefile:	(cd `dirname $(DISTDIR)` && $(TAR) $(DISTNAME).tar $(DISTNAME) && $(COMPRESS) $(DISTNAME).tar) && $(MOVE) `dirname $(DISTDIR)`/$(DISTNAME).tar.gz . && $(DEL_FILE) -r $(DISTDIR)
UEFIReplace/Makefile:	@test -d $(DISTDIR) || mkdir -p $(DISTDIR)
UEFIReplace/Makefile:	$(COPY_FILE) --parents $(DIST) $(DISTDIR)/
UEFIReplace/Makefile:	$(COPY_FILE) --parents /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp $(DISTDIR)/
UEFIReplace/Makefile:	$(COPY_FILE) --parents uefireplace.h ../basetypes.h ../descriptor.h ../gbe.h ../me.h ../ffs.h ../peimage.h ../types.h ../ffsengine.h ../treeitem.h ../treemodel.h ../version.h ../LZMA/LzmaCompress.h ../LZMA/LzmaDecompress.h ../LZMA/x86Convert.h ../Tiano/EfiTianoDecompress.h ../Tiano/EfiTianoCompress.h $(DISTDIR)/
UEFIReplace/Makefile:	$(COPY_FILE) --parents uefireplace_main.cpp uefireplace.cpp ../types.cpp ../descriptor.cpp ../ffs.cpp ../ffsengine.cpp ../peimage.cpp ../treeitem.cpp ../treemodel.cpp ../LZMA/LzmaCompress.c ../LZMA/LzmaDecompress.c ../LZMA/SDK/C/LzFind.c ../LZMA/SDK/C/LzmaDec.c ../LZMA/SDK/C/LzmaEnc.c ../LZMA/SDK/C/Bra86.c ../Tiano/EfiTianoDecompress.c ../Tiano/EfiTianoCompress.c ../Tiano/EfiTianoCompressLegacy.c $(DISTDIR)/
UEFIReplace/Makefile:	-$(DEL_FILE) $(OBJECTS)
UEFIReplace/Makefile:	-$(DEL_FILE) *~ core *.core
UEFIReplace/Makefile:	-$(DEL_FILE) $(TARGET) 
UEFIReplace/Makefile:	-$(DEL_FILE) Makefile
UEFIReplace/Makefile:####### Sub-libraries
UEFIReplace/Makefile:	-$(DEL_FILE) moc_predefs.h
UEFIReplace/Makefile:moc_predefs.h: /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp
UEFIReplace/Makefile:	g++ -pipe -Os -Wall -Wextra -dM -E -o moc_predefs.h /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp
UEFIReplace/Makefile:	-$(DEL_FILE) moc_uefireplace.cpp moc_ffsengine.cpp moc_treemodel.cpp
UEFIReplace/Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include uefireplace.h -o moc_uefireplace.cpp
UEFIReplace/Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include ../ffsengine.h -o moc_ffsengine.cpp
UEFIReplace/Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIReplace -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include ../treemodel.h -o moc_treemodel.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o uefireplace_main.o uefireplace_main.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o uefireplace.o uefireplace.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o types.o ../types.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o descriptor.o ../descriptor.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o ffs.o ../ffs.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o ffsengine.o ../ffsengine.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o peimage.o ../peimage.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o treeitem.o ../treeitem.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o treemodel.o ../treemodel.cpp
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaCompress.o ../LZMA/LzmaCompress.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaDecompress.o ../LZMA/LzmaDecompress.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzFind.o ../LZMA/SDK/C/LzFind.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaDec.o ../LZMA/SDK/C/LzmaDec.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaEnc.o ../LZMA/SDK/C/LzmaEnc.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o Bra86.o ../LZMA/SDK/C/Bra86.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoDecompress.o ../Tiano/EfiTianoDecompress.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoCompress.o ../Tiano/EfiTianoCompress.c
UEFIReplace/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoCompressLegacy.o ../Tiano/EfiTianoCompressLegacy.c
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_uefireplace.o moc_uefireplace.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_ffsengine.o moc_ffsengine.cpp
UEFIReplace/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_treemodel.o moc_treemodel.cpp
ui_uefitool.h:        if (UEFITool->objectName().isEmpty())
ui_uefitool.h:            UEFITool->setObjectName(QString::fromUtf8("UEFITool"));
ui_uefitool.h:        UEFITool->resize(800, 600);
ui_uefitool.h:        sizePolicy.setHeightForWidth(UEFITool->sizePolicy().hasHeightForWidth());
ui_uefitool.h:        UEFITool->setSizePolicy(sizePolicy);
ui_uefitool.h:        UEFITool->setAcceptDrops(true);
ui_uefitool.h:        actionInsertAfter->setObjectName(QString::fromUtf8("actionInsertAfter"));
ui_uefitool.h:        actionInsertAfter->setEnabled(false);
ui_uefitool.h:        actionInsertBefore->setObjectName(QString::fromUtf8("actionInsertBefore"));
ui_uefitool.h:        actionInsertBefore->setEnabled(false);
ui_uefitool.h:        actionReplace->setObjectName(QString::fromUtf8("actionReplace"));
ui_uefitool.h:        actionReplace->setEnabled(false);
ui_uefitool.h:        actionExtract->setObjectName(QString::fromUtf8("actionExtract"));
ui_uefitool.h:        actionExtract->setEnabled(false);
ui_uefitool.h:        actionExtractBody->setObjectName(QString::fromUtf8("actionExtractBody"));
ui_uefitool.h:        actionExtractBody->setEnabled(false);
ui_uefitool.h:        actionRemove->setObjectName(QString::fromUtf8("actionRemove"));
ui_uefitool.h:        actionRemove->setEnabled(false);
ui_uefitool.h:        actionOpenImageFile->setObjectName(QString::fromUtf8("actionOpenImageFile"));
ui_uefitool.h:        actionInsertInto->setObjectName(QString::fromUtf8("actionInsertInto"));
ui_uefitool.h:        actionInsertInto->setEnabled(false);
ui_uefitool.h:        actionSaveImageFile->setObjectName(QString::fromUtf8("actionSaveImageFile"));
ui_uefitool.h:        actionSaveImageFile->setEnabled(false);
ui_uefitool.h:        actionRebuild->setObjectName(QString::fromUtf8("actionRebuild"));
ui_uefitool.h:        actionRebuild->setEnabled(false);
ui_uefitool.h:        actionAbout->setObjectName(QString::fromUtf8("actionAbout"));
ui_uefitool.h:        actionAbout->setMenuRole(QAction::AboutRole);
ui_uefitool.h:        actionAboutQt->setObjectName(QString::fromUtf8("actionAboutQt"));
ui_uefitool.h:        actionAboutQt->setMenuRole(QAction::AboutQtRole);
ui_uefitool.h:        actionQuit->setObjectName(QString::fromUtf8("actionQuit"));
ui_uefitool.h:        actionQuit->setMenuRole(QAction::QuitRole);
ui_uefitool.h:        actionSearch->setObjectName(QString::fromUtf8("actionSearch"));
ui_uefitool.h:        actionSearch->setEnabled(false);
ui_uefitool.h:        actionMessagesClear->setObjectName(QString::fromUtf8("actionMessagesClear"));
ui_uefitool.h:        actionReplaceBody->setObjectName(QString::fromUtf8("actionReplaceBody"));
ui_uefitool.h:        actionReplaceBody->setEnabled(false);
ui_uefitool.h:        actionMessagesCopy->setObjectName(QString::fromUtf8("actionMessagesCopy"));
ui_uefitool.h:        actionMessagesCopyAll->setObjectName(QString::fromUtf8("actionMessagesCopyAll"));
ui_uefitool.h:        actionOpenImageFileInNewWindow->setObjectName(QString::fromUtf8("actionOpenImageFileInNewWindow"));
ui_uefitool.h:        actionDoNotRebuild->setObjectName(QString::fromUtf8("actionDoNotRebuild"));
ui_uefitool.h:        actionDoNotRebuild->setEnabled(false);
ui_uefitool.h:        centralWidget->setObjectName(QString::fromUtf8("centralWidget"));
ui_uefitool.h:        sizePolicy.setHeightForWidth(centralWidget->sizePolicy().hasHeightForWidth());
ui_uefitool.h:        centralWidget->setSizePolicy(sizePolicy);
ui_uefitool.h:        horizontalLayout_7->setSpacing(0);
ui_uefitool.h:        horizontalLayout_7->setContentsMargins(11, 11, 11, 11);
ui_uefitool.h:        horizontalLayout_7->setObjectName(QString::fromUtf8("horizontalLayout_7"));
ui_uefitool.h:        horizontalLayout_7->setContentsMargins(0, 0, 0, 0);
ui_uefitool.h:        messagesSplitter->setObjectName(QString::fromUtf8("messagesSplitter"));
ui_uefitool.h:        messagesSplitter->setOrientation(Qt::Vertical);
ui_uefitool.h:        infoSplitter->setObjectName(QString::fromUtf8("infoSplitter"));
ui_uefitool.h:        infoSplitter->setOrientation(Qt::Horizontal);
ui_uefitool.h:        structureGroupBox->setObjectName(QString::fromUtf8("structureGroupBox"));
ui_uefitool.h:        horizontalLayout_4->setSpacing(0);
ui_uefitool.h:        horizontalLayout_4->setContentsMargins(11, 11, 11, 11);
ui_uefitool.h:        horizontalLayout_4->setObjectName(QString::fromUtf8("horizontalLayout_4"));
ui_uefitool.h:        horizontalLayout_4->setContentsMargins(5, 5, 5, 5);
ui_uefitool.h:        structureTreeView->setObjectName(QString::fromUtf8("structureTreeView"));
ui_uefitool.h:        sizePolicy.setHeightForWidth(structureTreeView->sizePolicy().hasHeightForWidth());
ui_uefitool.h:        structureTreeView->setSizePolicy(sizePolicy);
ui_uefitool.h:        structureTreeView->setIndentation(10);
ui_uefitool.h:        structureTreeView->setHeaderHidden(false);
ui_uefitool.h:        structureTreeView->header()->setCascadingSectionResizes(true);
ui_uefitool.h:        structureTreeView->header()->setDefaultSectionSize(200);
ui_uefitool.h:        structureTreeView->header()->setStretchLastSection(true);
ui_uefitool.h:        horizontalLayout_4->addWidget(structureTreeView);
ui_uefitool.h:        infoSplitter->addWidget(structureGroupBox);
ui_uefitool.h:        infoGroupBox->setObjectName(QString::fromUtf8("infoGroupBox"));
ui_uefitool.h:        horizontalLayout_5->setSpacing(0);
ui_uefitool.h:        horizontalLayout_5->setContentsMargins(11, 11, 11, 11);
ui_uefitool.h:        horizontalLayout_5->setObjectName(QString::fromUtf8("horizontalLayout_5"));
ui_uefitool.h:        horizontalLayout_5->setContentsMargins(5, 5, 5, 5);
ui_uefitool.h:        infoEdit->setObjectName(QString::fromUtf8("infoEdit"));
ui_uefitool.h:        infoEdit->setAcceptDrops(false);
ui_uefitool.h:        infoEdit->setUndoRedoEnabled(false);
ui_uefitool.h:        infoEdit->setReadOnly(true);
ui_uefitool.h:        infoEdit->setCenterOnScroll(false);
ui_uefitool.h:        horizontalLayout_5->addWidget(infoEdit);
ui_uefitool.h:        infoSplitter->addWidget(infoGroupBox);
ui_uefitool.h:        messagesSplitter->addWidget(infoSplitter);
ui_uefitool.h:        messageGroupBox->setObjectName(QString::fromUtf8("messageGroupBox"));
ui_uefitool.h:        horizontalLayout_6->setSpacing(0);
ui_uefitool.h:        horizontalLayout_6->setContentsMargins(11, 11, 11, 11);
ui_uefitool.h:        horizontalLayout_6->setObjectName(QString::fromUtf8("horizontalLayout_6"));
ui_uefitool.h:        horizontalLayout_6->setContentsMargins(5, 5, 5, 5);
ui_uefitool.h:        messageListWidget->setObjectName(QString::fromUtf8("messageListWidget"));
ui_uefitool.h:        messageListWidget->setMouseTracking(true);
ui_uefitool.h:        horizontalLayout_6->addWidget(messageListWidget);
ui_uefitool.h:        messagesSplitter->addWidget(messageGroupBox);
ui_uefitool.h:        horizontalLayout_7->addWidget(messagesSplitter);
ui_uefitool.h:        UEFITool->setCentralWidget(centralWidget);
ui_uefitool.h:        statusBar->setObjectName(QString::fromUtf8("statusBar"));
ui_uefitool.h:        UEFITool->setStatusBar(statusBar);
ui_uefitool.h:        menuBar->setObjectName(QString::fromUtf8("menuBar"));
ui_uefitool.h:        menuBar->setGeometry(QRect(0, 0, 800, 31));
ui_uefitool.h:        menuFile->setObjectName(QString::fromUtf8("menuFile"));
ui_uefitool.h:        menuHelp->setObjectName(QString::fromUtf8("menuHelp"));
ui_uefitool.h:        menuAction->setObjectName(QString::fromUtf8("menuAction"));
ui_uefitool.h:        menuCapsuleActions->setObjectName(QString::fromUtf8("menuCapsuleActions"));
ui_uefitool.h:        menuImageActions->setObjectName(QString::fromUtf8("menuImageActions"));
ui_uefitool.h:        menuRegionActions->setObjectName(QString::fromUtf8("menuRegionActions"));
ui_uefitool.h:        menuPaddingActions->setObjectName(QString::fromUtf8("menuPaddingActions"));
ui_uefitool.h:        menuVolumeActions->setObjectName(QString::fromUtf8("menuVolumeActions"));
ui_uefitool.h:        menuFileActions->setObjectName(QString::fromUtf8("menuFileActions"));
ui_uefitool.h:        menuSectionActions->setObjectName(QString::fromUtf8("menuSectionActions"));
ui_uefitool.h:        menuMessages->setObjectName(QString::fromUtf8("menuMessages"));
ui_uefitool.h:        UEFITool->setMenuBar(menuBar);
ui_uefitool.h:        menuBar->addAction(menuFile->menuAction());
ui_uefitool.h:        menuBar->addAction(menuAction->menuAction());
ui_uefitool.h:        menuBar->addAction(menuHelp->menuAction());
ui_uefitool.h:        menuFile->addAction(actionOpenImageFile);
ui_uefitool.h:        menuFile->addAction(actionOpenImageFileInNewWindow);
ui_uefitool.h:        menuFile->addAction(actionSaveImageFile);
ui_uefitool.h:        menuFile->addSeparator();
ui_uefitool.h:        menuFile->addAction(actionSearch);
ui_uefitool.h:        menuFile->addSeparator();
ui_uefitool.h:        menuFile->addAction(actionQuit);
ui_uefitool.h:        menuHelp->addAction(actionAbout);
ui_uefitool.h:        menuHelp->addAction(actionAboutQt);
ui_uefitool.h:        menuAction->addAction(menuCapsuleActions->menuAction());
ui_uefitool.h:        menuAction->addAction(menuImageActions->menuAction());
ui_uefitool.h:        menuAction->addAction(menuRegionActions->menuAction());
ui_uefitool.h:        menuAction->addAction(menuPaddingActions->menuAction());
ui_uefitool.h:        menuAction->addAction(menuVolumeActions->menuAction());
ui_uefitool.h:        menuAction->addAction(menuFileActions->menuAction());
ui_uefitool.h:        menuAction->addAction(menuSectionActions->menuAction());
ui_uefitool.h:        menuAction->addSeparator();
ui_uefitool.h:        menuAction->addAction(menuMessages->menuAction());
ui_uefitool.h:        menuCapsuleActions->addAction(actionExtract);
ui_uefitool.h:        menuCapsuleActions->addAction(actionExtractBody);
ui_uefitool.h:        menuImageActions->addAction(actionExtract);
ui_uefitool.h:        menuRegionActions->addAction(actionExtract);
ui_uefitool.h:        menuRegionActions->addSeparator();
ui_uefitool.h:        menuRegionActions->addAction(actionDoNotRebuild);
ui_uefitool.h:        menuRegionActions->addSeparator();
ui_uefitool.h:        menuRegionActions->addAction(actionReplace);
ui_uefitool.h:        menuPaddingActions->addAction(actionExtract);
ui_uefitool.h:        menuPaddingActions->addSeparator();
ui_uefitool.h:        menuPaddingActions->addAction(actionReplace);
ui_uefitool.h:        menuVolumeActions->addAction(actionExtract);
ui_uefitool.h:        menuVolumeActions->addAction(actionExtractBody);
ui_uefitool.h:        menuVolumeActions->addSeparator();
ui_uefitool.h:        menuVolumeActions->addAction(actionRebuild);
ui_uefitool.h:        menuVolumeActions->addAction(actionDoNotRebuild);
ui_uefitool.h:        menuVolumeActions->addSeparator();
ui_uefitool.h:        menuVolumeActions->addAction(actionInsertInto);
ui_uefitool.h:        menuVolumeActions->addSeparator();
ui_uefitool.h:        menuVolumeActions->addAction(actionReplace);
ui_uefitool.h:        menuVolumeActions->addAction(actionReplaceBody);
ui_uefitool.h:        menuFileActions->addAction(actionExtract);
ui_uefitool.h:        menuFileActions->addAction(actionExtractBody);
ui_uefitool.h:        menuFileActions->addSeparator();
ui_uefitool.h:        menuFileActions->addAction(actionRebuild);
ui_uefitool.h:        menuFileActions->addAction(actionDoNotRebuild);
ui_uefitool.h:        menuFileActions->addSeparator();
ui_uefitool.h:        menuFileActions->addAction(actionInsertInto);
ui_uefitool.h:        menuFileActions->addAction(actionInsertBefore);
ui_uefitool.h:        menuFileActions->addAction(actionInsertAfter);
ui_uefitool.h:        menuFileActions->addSeparator();
ui_uefitool.h:        menuFileActions->addAction(actionReplace);
ui_uefitool.h:        menuFileActions->addAction(actionReplaceBody);
ui_uefitool.h:        menuFileActions->addSeparator();
ui_uefitool.h:        menuFileActions->addAction(actionRemove);
ui_uefitool.h:        menuSectionActions->addAction(actionExtract);
ui_uefitool.h:        menuSectionActions->addAction(actionExtractBody);
ui_uefitool.h:        menuSectionActions->addSeparator();
ui_uefitool.h:        menuSectionActions->addAction(actionRebuild);
ui_uefitool.h:        menuSectionActions->addAction(actionDoNotRebuild);
ui_uefitool.h:        menuSectionActions->addSeparator();
ui_uefitool.h:        menuSectionActions->addAction(actionInsertInto);
ui_uefitool.h:        menuSectionActions->addAction(actionInsertBefore);
ui_uefitool.h:        menuSectionActions->addAction(actionInsertAfter);
ui_uefitool.h:        menuSectionActions->addSeparator();
ui_uefitool.h:        menuSectionActions->addAction(actionReplace);
ui_uefitool.h:        menuSectionActions->addAction(actionReplaceBody);
ui_uefitool.h:        menuSectionActions->addSeparator();
ui_uefitool.h:        menuSectionActions->addAction(actionRemove);
ui_uefitool.h:        menuMessages->addAction(actionMessagesCopy);
ui_uefitool.h:        menuMessages->addAction(actionMessagesCopyAll);
ui_uefitool.h:        menuMessages->addSeparator();
ui_uefitool.h:        menuMessages->addAction(actionMessagesClear);
ui_uefitool.h:        UEFITool->setWindowTitle(QCoreApplication::translate("UEFITool", "UEFITool", nullptr));
ui_uefitool.h:        actionInsertAfter->setText(QCoreApplication::translate("UEFITool", "Insert &after...", nullptr));
ui_uefitool.h:        actionInsertAfter->setToolTip(QCoreApplication::translate("UEFITool", "Insert an object from file after selected object", nullptr));
ui_uefitool.h:        actionInsertAfter->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Shift+I", nullptr));
ui_uefitool.h:        actionInsertBefore->setText(QCoreApplication::translate("UEFITool", "Insert b&efore...", nullptr));
ui_uefitool.h:        actionInsertBefore->setToolTip(QCoreApplication::translate("UEFITool", "Insert object from file before selected object", nullptr));
ui_uefitool.h:        actionInsertBefore->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Alt+I", nullptr));
ui_uefitool.h:        actionReplace->setText(QCoreApplication::translate("UEFITool", "Rep&lace as is...", nullptr));
ui_uefitool.h:        actionReplace->setToolTip(QCoreApplication::translate("UEFITool", "Replace selected object as is with an object from file", nullptr));
ui_uefitool.h:        actionReplace->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+R", nullptr));
ui_uefitool.h:        actionExtract->setText(QCoreApplication::translate("UEFITool", "E&xtract as is...", nullptr));
ui_uefitool.h:        actionExtract->setToolTip(QCoreApplication::translate("UEFITool", "Extract selected object as is to file", nullptr));
ui_uefitool.h:        actionExtract->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+E", nullptr));
ui_uefitool.h:        actionExtractBody->setText(QCoreApplication::translate("UEFITool", "Extract &body...", nullptr));
ui_uefitool.h:        actionExtractBody->setToolTip(QCoreApplication::translate("UEFITool", "Extract body of selected object to file", nullptr));
ui_uefitool.h:        actionExtractBody->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Shift+E", nullptr));
ui_uefitool.h:        actionRemove->setText(QCoreApplication::translate("UEFITool", "Re&move", nullptr));
ui_uefitool.h:        actionRemove->setToolTip(QCoreApplication::translate("UEFITool", "Remove selected object", nullptr));
ui_uefitool.h:        actionRemove->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Del", nullptr));
ui_uefitool.h:        actionOpenImageFile->setText(QCoreApplication::translate("UEFITool", "&Open image file...", nullptr));
ui_uefitool.h:        actionOpenImageFile->setToolTip(QCoreApplication::translate("UEFITool", "Open image file", nullptr));
ui_uefitool.h:        actionOpenImageFile->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+O", nullptr));
ui_uefitool.h:        actionInsertInto->setText(QCoreApplication::translate("UEFITool", "Insert &into...", nullptr));
ui_uefitool.h:        actionInsertInto->setToolTip(QCoreApplication::translate("UEFITool", "Insert object from file into selected object", nullptr));
ui_uefitool.h:        actionInsertInto->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+I", nullptr));
ui_uefitool.h:        actionSaveImageFile->setText(QCoreApplication::translate("UEFITool", "&Save image file...", nullptr));
ui_uefitool.h:        actionSaveImageFile->setToolTip(QCoreApplication::translate("UEFITool", "Save modified image file", nullptr));
ui_uefitool.h:        actionSaveImageFile->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+S", nullptr));
ui_uefitool.h:        actionRebuild->setText(QCoreApplication::translate("UEFITool", "&Rebuild", nullptr));
ui_uefitool.h:        actionRebuild->setToolTip(QCoreApplication::translate("UEFITool", "Rebuild selected object", nullptr));
ui_uefitool.h:        actionRebuild->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Space", nullptr));
ui_uefitool.h:        actionAbout->setText(QCoreApplication::translate("UEFITool", "&About UEFITool", nullptr));
ui_uefitool.h:        actionAbout->setShortcut(QCoreApplication::translate("UEFITool", "F1", nullptr));
ui_uefitool.h:        actionAboutQt->setText(QCoreApplication::translate("UEFITool", "About &Qt", nullptr));
ui_uefitool.h:        actionQuit->setText(QCoreApplication::translate("UEFITool", "&Quit", nullptr));
ui_uefitool.h:        actionSearch->setText(QCoreApplication::translate("UEFITool", "Sear&ch...", nullptr));
ui_uefitool.h:        actionSearch->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+F", nullptr));
ui_uefitool.h:        actionMessagesClear->setText(QCoreApplication::translate("UEFITool", "Cl&ear", nullptr));
ui_uefitool.h:        actionMessagesClear->setToolTip(QCoreApplication::translate("UEFITool", "Clear messages", nullptr));
ui_uefitool.h:        actionMessagesClear->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Backspace", nullptr));
ui_uefitool.h:        actionReplaceBody->setText(QCoreApplication::translate("UEFITool", "Replace b&ody...", nullptr));
ui_uefitool.h:        actionReplaceBody->setToolTip(QCoreApplication::translate("UEFITool", "Replace body of selected object with a data from file", nullptr));
ui_uefitool.h:        actionReplaceBody->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Shift+R", nullptr));
ui_uefitool.h:        actionMessagesCopy->setText(QCoreApplication::translate("UEFITool", "&Copy", nullptr));
ui_uefitool.h:        actionMessagesCopy->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Shift+C", nullptr));
ui_uefitool.h:        actionMessagesCopyAll->setText(QCoreApplication::translate("UEFITool", "C&opy all", nullptr));
ui_uefitool.h:        actionMessagesCopyAll->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Alt+C", nullptr));
ui_uefitool.h:        actionOpenImageFileInNewWindow->setText(QCoreApplication::translate("UEFITool", "&Open image file in new window...", nullptr));
ui_uefitool.h:        actionOpenImageFileInNewWindow->setToolTip(QCoreApplication::translate("UEFITool", "Open image file in new window", nullptr));
ui_uefitool.h:        actionOpenImageFileInNewWindow->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Shift+O", nullptr));
ui_uefitool.h:        actionDoNotRebuild->setText(QCoreApplication::translate("UEFITool", "&Do not rebuild", nullptr));
ui_uefitool.h:        actionDoNotRebuild->setShortcut(QCoreApplication::translate("UEFITool", "Ctrl+Shift+Space", nullptr));
ui_uefitool.h:        structureGroupBox->setTitle(QCoreApplication::translate("UEFITool", "Structure", nullptr));
ui_uefitool.h:        infoGroupBox->setTitle(QCoreApplication::translate("UEFITool", "Information", nullptr));
ui_uefitool.h:        messageGroupBox->setTitle(QCoreApplication::translate("UEFITool", "Messages", nullptr));
ui_uefitool.h:        menuFile->setTitle(QCoreApplication::translate("UEFITool", "&File", nullptr));
ui_uefitool.h:        menuHelp->setTitle(QCoreApplication::translate("UEFITool", "H&elp", nullptr));
ui_uefitool.h:        menuAction->setTitle(QCoreApplication::translate("UEFITool", "&Action", nullptr));
ui_uefitool.h:        menuCapsuleActions->setTitle(QCoreApplication::translate("UEFITool", "&Capsule", nullptr));
ui_uefitool.h:        menuImageActions->setTitle(QCoreApplication::translate("UEFITool", "&Image", nullptr));
ui_uefitool.h:        menuRegionActions->setTitle(QCoreApplication::translate("UEFITool", "&Region", nullptr));
ui_uefitool.h:        menuPaddingActions->setTitle(QCoreApplication::translate("UEFITool", "&Padding", nullptr));
ui_uefitool.h:        menuVolumeActions->setTitle(QCoreApplication::translate("UEFITool", "&Volume", nullptr));
ui_uefitool.h:        menuFileActions->setTitle(QCoreApplication::translate("UEFITool", "&File", nullptr));
ui_uefitool.h:        menuSectionActions->setTitle(QCoreApplication::translate("UEFITool", "&Section", nullptr));
ui_uefitool.h:        menuMessages->setTitle(QCoreApplication::translate("UEFITool", "&Messages", nullptr));
moc_searchdialog.cpp:        - idx * sizeof(QByteArrayData)) \
moc_searchdialog.cpp:        case 0: _t->setEditFocus((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_searchdialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_searchdialog.cpp:        _id -= 1;
moc_searchdialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_searchdialog.cpp:        _id -= 1;
descriptor.cpp:http://opensource.org/licenses/bsd-license.php
descriptor.cpp:        return (limit + 1 - base) * 0x1000;
searchdialog.h:  http://opensource.org/licenses/bsd-license.php
descriptor.h:http://opensource.org/licenses/bsd-license.php
descriptor.h:    UINT32 NumberOfFlashChips : 2;      // Zero-based number of flash chips installed on board
descriptor.h:    UINT32 NumberOfMasters : 2;         // Zero-based number of flash masters
descriptor.h:    UINT32 NumberOfPchStraps : 8;       // One-based number of UINT32s to read as PCH straps, min=0, max=255 (1 Kb)
descriptor.h:    UINT32 NumberOfProcStraps : 8;      // One-based number of UINT32s to read as processor straps, min=0, max=255 (1 Kb)
descriptor.h:// If limit is zero - region is not present
guidlineedit.h:  http://opensource.org/licenses/bsd-license.php
moc_uefitool.cpp:        - idx * sizeof(QByteArrayData)) \
moc_uefitool.cpp:        case 0: _t->init(); break;
moc_uefitool.cpp:        case 1: _t->populateUi((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_uefitool.cpp:        case 2: _t->scrollTreeView((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
moc_uefitool.cpp:        case 3: _t->openImageFile(); break;
moc_uefitool.cpp:        case 4: _t->openImageFileInNewWindow(); break;
moc_uefitool.cpp:        case 5: _t->saveImageFile(); break;
moc_uefitool.cpp:        case 6: _t->search(); break;
moc_uefitool.cpp:        case 7: _t->extract((*reinterpret_cast< const UINT8(*)>(_a[1]))); break;
moc_uefitool.cpp:        case 8: _t->extractAsIs(); break;
moc_uefitool.cpp:        case 9: _t->extractBody(); break;
moc_uefitool.cpp:        case 10: _t->insert((*reinterpret_cast< const UINT8(*)>(_a[1]))); break;
moc_uefitool.cpp:        case 11: _t->insertInto(); break;
moc_uefitool.cpp:        case 12: _t->insertBefore(); break;
moc_uefitool.cpp:        case 13: _t->insertAfter(); break;
moc_uefitool.cpp:        case 14: _t->replace((*reinterpret_cast< const UINT8(*)>(_a[1]))); break;
moc_uefitool.cpp:        case 15: _t->replaceAsIs(); break;
moc_uefitool.cpp:        case 16: _t->replaceBody(); break;
moc_uefitool.cpp:        case 17: _t->rebuild(); break;
moc_uefitool.cpp:        case 18: _t->doNotRebuild(); break;
moc_uefitool.cpp:        case 19: _t->remove(); break;
moc_uefitool.cpp:        case 20: _t->copyMessage(); break;
moc_uefitool.cpp:        case 21: _t->copyAllMessages(); break;
moc_uefitool.cpp:        case 22: _t->enableMessagesCopyActions((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
moc_uefitool.cpp:        case 23: _t->clearMessages(); break;
moc_uefitool.cpp:        case 24: _t->about(); break;
moc_uefitool.cpp:        case 25: _t->aboutQt(); break;
moc_uefitool.cpp:        case 26: _t->exit(); break;
moc_uefitool.cpp:        case 27: _t->writeSettings(); break;
moc_uefitool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_uefitool.cpp:        _id -= 28;
moc_uefitool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_uefitool.cpp:        _id -= 28;
me.h:http://opensource.org/licenses/bsd-license.php
gbe.h:http://opensource.org/licenses/bsd-license.php
README.rst:| UEFITool is a cross-platform C++/Qt program for parsing, extracting and modifying UEFI firmware images.
README.rst:| Original development was started `here <http://forums.mydigitallife.info/threads/48979-UEFITool-UEFI-firmware-image-viewer-and-editor>`_ at MDL forums as a cross-platform analog to `PhoenixTool <http://forums.mydigitallife.info/threads/13194-Tool-to-Insert-Replace-SLIC-in-Phoenix-Insyde-Dell-EFI-BIOSes>`_'s structure mode with some additional features, but the program's engine was proven to be usefull for another projects like `UEFIPatch <http://www.insanelymac.com/forum/topic/285444-uefipatch-uefi-patching-utility/>`_, `UBU <http://www.win-raid.com/t154f16-Tool-quot-UEFI-BIOS-Updater-quot-UBU.html>`_ and `OZMTool <http://www.insanelymac.com/forum/topic/299711-ozmtool-an-ozmosis-toolbox/>`_.
README.rst:------------
README.rst:| You can either use `pre-built binaries for Windows and OSX <https://github.com/LongSoft/UEFITool/releases/latest>`_ or build a binary yourself. 
README.rst:-----
README.rst:| The program can be started directly without any arguments or supplied with a single argument - a path to the UEFI image file to open after start.
README.rst:| **Messages** panel show all messages from the engine, including structure warnings and search results. Most of messages can be double-clicked to select the element that causes the message.
README.rst:| **Extract** has two variants: **Extract as is** and **Extract body**. The difference is that **Extract as is** extracts the element with it's header (GUID, size, attributes and other structure-related information are located there), and **Extract body** extracts the element data only. 
README.rst:| **Rebuild** marks an element for rebuilding on image reconstruction. Normally, all elements that aren't marked for rebuild won't be changed at all and if you need to correct some structure error (i.e. invalid data checksum) you must mark an element for rebuild manually. If you change an element all it's parents up to the tree root will be marked for rebuild automatically. If UEFI volume is marked for rebuild all uncompressed PEI files in it will also be marked for rebuild because they must be rebased in the reconstructed image to maintain the executable-in-place constraint.
README.rst:------------
README.rst:* Some images has non-standard calculation of base address of TE images, so the program can rebase them incorrectly after modifications. Will be solved ASAP.
README.rst:* The program is meant to work with BIOS images, not some vendor-specific BIOS update files, that is why some of that update file either can\t be opened at all or return errors on reconstruction. If someone wants to write an unpacker for such crappy files - I will be glad to use it.
README.rst:* AMI-specific features like NCBs, ROM_AREA structure and other things like that can't be implemented by me because of the NDA I have.
messagelistitem.h:  http://opensource.org/licenses/bsd-license.php
moc_treemodel.cpp:        - idx * sizeof(QByteArrayData)) \
moc_treemodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_predefs.h:#define __DBL_MIN_EXP__ (-1021)
moc_predefs.h:#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
moc_predefs.h:#define __FLT32_MIN_EXP__ (-125)
moc_predefs.h:#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
moc_predefs.h:#define __DBL_MIN_10_EXP__ (-307)
moc_predefs.h:#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
moc_predefs.h:#define __DEC32_EPSILON__ 1E-6DF
moc_predefs.h:#define __FLT128_MIN_EXP__ (-16381)
moc_predefs.h:#define __FLT128_MIN_10_EXP__ (-4931)
moc_predefs.h:#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
moc_predefs.h:#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
moc_predefs.h:#define __DEC64_MIN_EXP__ (-382)
moc_predefs.h:#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
moc_predefs.h:#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
moc_predefs.h:#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
moc_predefs.h:#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
moc_predefs.h:#define __FLT64_MIN_EXP__ (-1021)
moc_predefs.h:#define __FLT64X_MIN_10_EXP__ (-4931)
moc_predefs.h:#define __DEC32_MIN_EXP__ (-94)
moc_predefs.h:#define __DEC32_MIN__ 1E-95DF
moc_predefs.h:#define __DEC128_EPSILON__ 1E-33DL
moc_predefs.h:#define __FLT64X_MIN_EXP__ (-16381)
moc_predefs.h:#define __FLT_MIN_EXP__ (-125)
moc_predefs.h:#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
moc_predefs.h:#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
moc_predefs.h:#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
moc_predefs.h:#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
moc_predefs.h:#define __FLT64_MIN_10_EXP__ (-307)
moc_predefs.h:#define __DEC128_MIN__ 1E-6143DL
moc_predefs.h:#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
moc_predefs.h:#define __DEC64_EPSILON__ 1E-15DD
moc_predefs.h:#define __DEC128_MIN_EXP__ (-6142)
moc_predefs.h:#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
moc_predefs.h:#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
moc_predefs.h:#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
moc_predefs.h:#define __FLT32X_MIN_EXP__ (-1021)
moc_predefs.h:#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
moc_predefs.h:#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
moc_predefs.h:#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
moc_predefs.h:#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
moc_predefs.h:#define __FLT32_MIN_10_EXP__ (-37)
moc_predefs.h:#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
moc_predefs.h:#define __DEC64_MIN__ 1E-383DD
moc_predefs.h:#define __LDBL_MIN_EXP__ (-16381)
moc_predefs.h:#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
moc_predefs.h:#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
moc_predefs.h:#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
moc_predefs.h:#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
moc_predefs.h:#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
moc_predefs.h:#define __FLT_MIN_10_EXP__ (-37)
moc_predefs.h:#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
moc_predefs.h:#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
moc_predefs.h:#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
moc_predefs.h:#define __FLT32X_MIN_10_EXP__ (-307)
moc_predefs.h:#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
moc_predefs.h:#define __LDBL_MIN_10_EXP__ (-4931)
treemodel.cpp:http://opensource.org/licenses/bsd-license.php
treemodel.cpp:        return static_cast<TreeItem*>(parent.internalPointer())->columnCount();
treemodel.cpp:        return rootItem->columnCount();
treemodel.cpp:        return item->data(index.column());
treemodel.cpp:        return item->info();
treemodel.cpp:    TreeItem *childItem = parentItem->child(row);
treemodel.cpp:    TreeItem *parentItem = childItem->parent();
treemodel.cpp:    return createIndex(parentItem->row(), 0, parentItem);
treemodel.cpp:    return parentItem->childCount();
treemodel.cpp:    return item->type();
treemodel.cpp:    return item->subtype();
treemodel.cpp:    return item->header();
treemodel.cpp:    return item->hasEmptyHeader();
treemodel.cpp:    return item->body();
treemodel.cpp:    return item->hasEmptyBody();
treemodel.cpp:    return item->name();
treemodel.cpp:    return item->text();
treemodel.cpp:    return item->info();
treemodel.cpp:    return item->action();
treemodel.cpp:    return item->compression();
treemodel.cpp:    return item->dictionarySize();
treemodel.cpp:    item->setSubtype(subtype);
treemodel.cpp:    item->setName(data);
treemodel.cpp:    item->setType(data);
treemodel.cpp:    item->setText(data);
treemodel.cpp:    item->setAction(action);
treemodel.cpp:    emit dataChanged(this->index(0, 0), index);
treemodel.cpp:    item->setDictionarySize(dictionarySize);
treemodel.cpp:    emit dataChanged(this->index(0, 0), index);
treemodel.cpp:            parentItem = item->parent();
treemodel.cpp:        parentItem->appendChild(newItem);
treemodel.cpp:        parentItem->prependChild(newItem);
treemodel.cpp:        parentItem->insertChildBefore(item, newItem);
treemodel.cpp:        parentItem->insertChildAfter(item, newItem);
treemodel.cpp:    return createIndex(newItem->row(), parentColumn, newItem);
treemodel.cpp:        item != NULL && item != rootItem && item->type() != type;
UEFIPatch/uefipatch.h:http://opensource.org/licenses/bsd-license.php
UEFIPatch/uefipatch.pro:QT       -= gui
UEFIPatch/uefipatch.pro:CONFIG   -= app_bundle
UEFIPatch/patches.txt:#  Position-independent code     11
UEFIPatch/patches.txt:#  16-bit code                   16
UEFIPatch/patches.txt:#  P - pattern-based, first parameter is a pattern to find, second - a pattern to replace
UEFIPatch/patches.txt:#  O - offset-based, first parameter is hexadecimal offset, second - a pattern to replace
UEFIPatch/patches.txt:#----------------------------------------------------------------------------------
UEFIPatch/patches.txt:#----------------------------------------------------------------------------------
UEFIPatch/patches.txt:F7731B4C-58A2-4DF4-8980-5645D39ECE58 10 P:75080FBAE80F89442430:EB080FBAE80F89442430 
UEFIPatch/patches.txt:# PowerMgmtDxe | Haswell-E
UEFIPatch/patches.txt:F7731B4C-58A2-4DF4-8980-5645D39ECE58 10 P:0FBA6C24380F:0FBA7424380F 
UEFIPatch/patches.txt:8C783970-F02A-4A4D-AF09-8797A51EEC8D 10 P:75080FBAE80F89442430:EB080FBAE80F89442430 
UEFIPatch/patches.txt:# PowerManagement | New SB-E/IB-E 
UEFIPatch/patches.txt:8C783970-F02A-4A4D-AF09-8797A51EEC8D 10 P:0FBA6C24380F:0FBA7424380F 
UEFIPatch/patches.txt:# CpuPei | Sandy Bridge with ME 7.xx, old SB-E/IB-E
UEFIPatch/patches.txt:2BB5AFA9-FF33-417B-8497-CB773C2B93BF 10 P:800018EB050D0080:000018EB050D0000 
UEFIPatch/patches.txt:# PpmInitialize | Broadwell-E
UEFIPatch/patches.txt:3FFCAE95-23CF-4967-94F5-16352F68E43B 10 P:0FBA6C24400F:0FBA7424400F 
UEFIPatch/patches.txt:299D6F8B-2EC9-4E40-9EC6-DDAA7EBF5FD9 10 P:75080D00800000:EB080D00800000 
UEFIPatch/patches.txt:299D6F8B-2EC9-4E40-9EC6-DDAA7EBF5FD9 12 P:75080D00800000:EB080D00800000 
UEFIPatch/patches.txt:299D6F8B-2EC9-4E40-9EC6-DDAA7EBF5FD9 10 P:81E10080000033C1:9090909090909090 
UEFIPatch/patches.txt:299D6F8B-2EC9-4E40-9EC6-DDAA7EBF5FD9 12 P:81E10080000033C1:9090909090909090 
UEFIPatch/patches.txt:# PpmInitialize | Skylake-X
UEFIPatch/patches.txt:3FFCAE95-23CF-4967-94F5-16352F68E43B 10 P:742CB9E2000000:752CB9E2000000 
UEFIPatch/patches.txt:# CpuInitPei | Skylake-X
UEFIPatch/patches.txt:01359D99-9446-456D-ADA4-50A711C03ADA 12 P:BE0080000023CE0B:BE0000000023CE0B 
UEFIPatch/patches.txt:3FFCAE95-23CF-4967-94F5-16352F68E43B 10 P:4889442430....0FBAE8:4889442430....0FBAE0 
UEFIPatch/patches.txt:3FFCAE95-23CF-4967-94F5-16352F68E43B 10 P:4889442450....0FBAE8:4889442450....0FBAE0 
UEFIPatch/patches.txt:3FFCAE95-23CF-4967-94F5-16352F68E43B 10 P:480BC2BA00200000:480BC2BA00000000 
UEFIPatch/patches.txt:3FFCAE95-23CF-4967-94F5-16352F68E43B 10 P:480BC2BA00800000:480BC2BA00000000
UEFIPatch/uefipatch.cpp:http://opensource.org/licenses/bsd-license.php
UEFIPatch/uefipatch.cpp:    model = ffsEngine->treeModel();
UEFIPatch/uefipatch.cpp:    UINT8 result = ffsEngine->parseImageFile(buffer);
UEFIPatch/uefipatch.cpp:        result = patchFile(model->index(0, 0), guid, sectionType, patches);
UEFIPatch/uefipatch.cpp:    result = ffsEngine->reconstructImageFile(reconstructed);
UEFIPatch/uefipatch.cpp:    UINT8 result = ffsEngine->parseImageFile(buffer);
UEFIPatch/uefipatch.cpp:        result = patchFile(model->index(0, 0), guid, sectionType, patches);
UEFIPatch/uefipatch.cpp:    result = ffsEngine->reconstructImageFile(reconstructed);
UEFIPatch/uefipatch.cpp:    if (model->type(index) == Types::Section && model->subtype(index) == sectionType) {
UEFIPatch/uefipatch.cpp:        QModelIndex fileIndex = model->findParentOfType(index, Types::File);
UEFIPatch/uefipatch.cpp:        if (model->type(fileIndex) == Types::File &&
UEFIPatch/uefipatch.cpp:            model->header(fileIndex).left(sizeof(EFI_GUID)) == fileGuid)
UEFIPatch/uefipatch.cpp:            return ffsEngine->patch(index, patches);
UEFIPatch/uefipatch.cpp:    if (model->rowCount(index) > 0) {
UEFIPatch/uefipatch.cpp:        for (int i = 0; i < model->rowCount(index); i++) {
UEFIPatch/patches-misc.txt:#  Position-independent code     11
UEFIPatch/patches-misc.txt:#  16-bit code                   16
UEFIPatch/patches-misc.txt:#  P - pattern-based, first parameter is a pattern to find, second - a pattern to replace
UEFIPatch/patches-misc.txt:#  O - offset-based, first parameter is hexadecimal offset, second - a pattern to replace
UEFIPatch/patches-misc.txt:#----------------------------------------------------------------------------------
UEFIPatch/patches-misc.txt:#----------------------------------------------------------------------------------
UEFIPatch/patches-misc.txt:299D6F8B-2EC9-4E40-9EC6-DDAA7EBF5FD9 10 P:B93A0000000F320D00000400:B93A0000000F320D00000600 
UEFIPatch/patches-misc.txt:#----------------------------------------------------------------------------------
UEFIPatch/patches-misc.txt:#----------------------------------------------------------------------------------
UEFIPatch/patches-misc.txt:# UHCD | ASUS Z87-Pro
UEFIPatch/patches-misc.txt:580DD900-385D-11D7-883A-00500473D4EB 10 P:807A3200745C807A4000:807A32007506807A4000 
UEFIPatch/moc_uefipatch.cpp:        - idx * sizeof(QByteArrayData)) \
UEFIPatch/moc_uefipatch.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
UEFIPatch/uefipatch_main.cpp:http://opensource.org/licenses/bsd-license.php
UEFIPatch/uefipatch_main.cpp:        std::cout << "UEFIPatch " PROGRAM_VERSION " - UEFI image file patching utility" << std::endl << std::endl <<
UEFIPatch/uefipatch_main.cpp:            "Usage: UEFIPatch image_file [patches.txt] [-o output]" << std::endl <<
UEFIPatch/uefipatch_main.cpp:            "Usage: UEFIPatch image_file [-p \"Guid SectionType Patch\"] [-o output]" << std::endl << std::endl <<
UEFIPatch/uefipatch_main.cpp:        if ((args.at(i) == "-p" || args.at(i) == "--patch") && i + 1 < argumentsCount) {
UEFIPatch/uefipatch_main.cpp:        } else if ((args.at(i) == "-o" || args.at(i) == "--output") && i + 1 < argumentsCount) {
UEFIPatch/moc_treemodel.cpp:        - idx * sizeof(QByteArrayData)) \
UEFIPatch/moc_treemodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
UEFIPatch/moc_predefs.h:#define __DBL_MIN_EXP__ (-1021)
UEFIPatch/moc_predefs.h:#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
UEFIPatch/moc_predefs.h:#define __FLT32_MIN_EXP__ (-125)
UEFIPatch/moc_predefs.h:#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
UEFIPatch/moc_predefs.h:#define __DBL_MIN_10_EXP__ (-307)
UEFIPatch/moc_predefs.h:#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
UEFIPatch/moc_predefs.h:#define __DEC32_EPSILON__ 1E-6DF
UEFIPatch/moc_predefs.h:#define __FLT128_MIN_EXP__ (-16381)
UEFIPatch/moc_predefs.h:#define __FLT128_MIN_10_EXP__ (-4931)
UEFIPatch/moc_predefs.h:#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
UEFIPatch/moc_predefs.h:#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
UEFIPatch/moc_predefs.h:#define __DEC64_MIN_EXP__ (-382)
UEFIPatch/moc_predefs.h:#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
UEFIPatch/moc_predefs.h:#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
UEFIPatch/moc_predefs.h:#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
UEFIPatch/moc_predefs.h:#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
UEFIPatch/moc_predefs.h:#define __FLT64_MIN_EXP__ (-1021)
UEFIPatch/moc_predefs.h:#define __FLT64X_MIN_10_EXP__ (-4931)
UEFIPatch/moc_predefs.h:#define __DEC32_MIN_EXP__ (-94)
UEFIPatch/moc_predefs.h:#define __DEC32_MIN__ 1E-95DF
UEFIPatch/moc_predefs.h:#define __DEC128_EPSILON__ 1E-33DL
UEFIPatch/moc_predefs.h:#define __FLT64X_MIN_EXP__ (-16381)
UEFIPatch/moc_predefs.h:#define __FLT_MIN_EXP__ (-125)
UEFIPatch/moc_predefs.h:#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
UEFIPatch/moc_predefs.h:#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
UEFIPatch/moc_predefs.h:#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
UEFIPatch/moc_predefs.h:#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
UEFIPatch/moc_predefs.h:#define __FLT64_MIN_10_EXP__ (-307)
UEFIPatch/moc_predefs.h:#define __DEC128_MIN__ 1E-6143DL
UEFIPatch/moc_predefs.h:#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
UEFIPatch/moc_predefs.h:#define __DEC64_EPSILON__ 1E-15DD
UEFIPatch/moc_predefs.h:#define __DEC128_MIN_EXP__ (-6142)
UEFIPatch/moc_predefs.h:#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
UEFIPatch/moc_predefs.h:#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
UEFIPatch/moc_predefs.h:#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
UEFIPatch/moc_predefs.h:#define __FLT32X_MIN_EXP__ (-1021)
UEFIPatch/moc_predefs.h:#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
UEFIPatch/moc_predefs.h:#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
UEFIPatch/moc_predefs.h:#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
UEFIPatch/moc_predefs.h:#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
UEFIPatch/moc_predefs.h:#define __FLT32_MIN_10_EXP__ (-37)
UEFIPatch/moc_predefs.h:#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
UEFIPatch/moc_predefs.h:#define __DEC64_MIN__ 1E-383DD
UEFIPatch/moc_predefs.h:#define __LDBL_MIN_EXP__ (-16381)
UEFIPatch/moc_predefs.h:#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
UEFIPatch/moc_predefs.h:#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
UEFIPatch/moc_predefs.h:#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
UEFIPatch/moc_predefs.h:#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
UEFIPatch/moc_predefs.h:#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
UEFIPatch/moc_predefs.h:#define __FLT_MIN_10_EXP__ (-37)
UEFIPatch/moc_predefs.h:#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
UEFIPatch/moc_predefs.h:#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
UEFIPatch/moc_predefs.h:#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
UEFIPatch/moc_predefs.h:#define __FLT32X_MIN_10_EXP__ (-307)
UEFIPatch/moc_predefs.h:#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
UEFIPatch/moc_predefs.h:#define __LDBL_MIN_10_EXP__ (-4931)
UEFIPatch/moc_ffsengine.cpp:        - idx * sizeof(QByteArrayData)) \
UEFIPatch/moc_ffsengine.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
UEFIPatch/Makefile:# Command: /usr/lib/qt5/bin/qmake -o Makefile uefipatch.pro CONFIG+=optimize_size
UEFIPatch/Makefile:DEFINES       = -D_CONSOLE -DQT_NO_DEBUG -DQT_CORE_LIB
UEFIPatch/Makefile:CFLAGS        = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)
UEFIPatch/Makefile:CXXFLAGS      = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)
UEFIPatch/Makefile:INCPATH       = -I. -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I. -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++
UEFIPatch/Makefile:DEL_FILE      = rm -f
UEFIPatch/Makefile:CHK_DIR_EXISTS= test -d
UEFIPatch/Makefile:MKDIR         = mkdir -p
UEFIPatch/Makefile:COPY          = cp -f
UEFIPatch/Makefile:COPY_FILE     = cp -f
UEFIPatch/Makefile:COPY_DIR      = cp -f -R
UEFIPatch/Makefile:INSTALL_FILE  = install -m 644 -p
UEFIPatch/Makefile:INSTALL_PROGRAM = install -m 755 -p
UEFIPatch/Makefile:INSTALL_DIR   = cp -f -R
UEFIPatch/Makefile:QINSTALL      = /usr/lib/qt5/bin/qmake -install qinstall
UEFIPatch/Makefile:QINSTALL_PROGRAM = /usr/lib/qt5/bin/qmake -install qinstall -exe
UEFIPatch/Makefile:DEL_FILE      = rm -f
UEFIPatch/Makefile:SYMLINK       = ln -f -s
UEFIPatch/Makefile:MOVE          = mv -f
UEFIPatch/Makefile:TAR           = tar -cf
UEFIPatch/Makefile:COMPRESS      = gzip -9f
UEFIPatch/Makefile:DISTDIR = /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch/.tmp/UEFIPatch1.0.0
UEFIPatch/Makefile:LFLAGS        = -Wl,-O1
UEFIPatch/Makefile:LIBS          = $(SUBLIBS) /usr/lib/x86_64-linux-gnu/libQt5Core.so -lpthread   
UEFIPatch/Makefile:DIST          = /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf \
UEFIPatch/Makefile:	$(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJCOMP) $(LIBS)
UEFIPatch/Makefile:Makefile: uefipatch.pro /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf \
UEFIPatch/Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf \
UEFIPatch/Makefile:	$(QMAKE) -o Makefile uefipatch.pro CONFIG+=optimize_size
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf:
UEFIPatch/Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf:
UEFIPatch/Makefile:	@$(QMAKE) -o Makefile uefipatch.pro CONFIG+=optimize_size
UEFIPatch/Makefile:	(cd `dirname $(DISTDIR)` && $(TAR) $(DISTNAME).tar $(DISTNAME) && $(COMPRESS) $(DISTNAME).tar) && $(MOVE) `dirname $(DISTDIR)`/$(DISTNAME).tar.gz . && $(DEL_FILE) -r $(DISTDIR)
UEFIPatch/Makefile:	@test -d $(DISTDIR) || mkdir -p $(DISTDIR)
UEFIPatch/Makefile:	$(COPY_FILE) --parents $(DIST) $(DISTDIR)/
UEFIPatch/Makefile:	$(COPY_FILE) --parents /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp $(DISTDIR)/
UEFIPatch/Makefile:	$(COPY_FILE) --parents uefipatch.h ../basetypes.h ../descriptor.h ../gbe.h ../me.h ../ffs.h ../peimage.h ../types.h ../ffsengine.h ../treeitem.h ../treemodel.h ../version.h ../LZMA/LzmaCompress.h ../LZMA/LzmaDecompress.h ../LZMA/x86Convert.h ../Tiano/EfiTianoDecompress.h ../Tiano/EfiTianoCompress.h $(DISTDIR)/
UEFIPatch/Makefile:	$(COPY_FILE) --parents uefipatch_main.cpp uefipatch.cpp ../types.cpp ../descriptor.cpp ../ffs.cpp ../ffsengine.cpp ../peimage.cpp ../treeitem.cpp ../treemodel.cpp ../LZMA/LzmaCompress.c ../LZMA/LzmaDecompress.c ../LZMA/SDK/C/LzFind.c ../LZMA/SDK/C/LzmaDec.c ../LZMA/SDK/C/LzmaEnc.c ../LZMA/SDK/C/Bra86.c ../Tiano/EfiTianoDecompress.c ../Tiano/EfiTianoCompress.c ../Tiano/EfiTianoCompressLegacy.c $(DISTDIR)/
UEFIPatch/Makefile:	-$(DEL_FILE) $(OBJECTS)
UEFIPatch/Makefile:	-$(DEL_FILE) *~ core *.core
UEFIPatch/Makefile:	-$(DEL_FILE) $(TARGET) 
UEFIPatch/Makefile:	-$(DEL_FILE) Makefile
UEFIPatch/Makefile:####### Sub-libraries
UEFIPatch/Makefile:	-$(DEL_FILE) moc_predefs.h
UEFIPatch/Makefile:moc_predefs.h: /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp
UEFIPatch/Makefile:	g++ -pipe -Os -Wall -Wextra -dM -E -o moc_predefs.h /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp
UEFIPatch/Makefile:	-$(DEL_FILE) moc_uefipatch.cpp moc_ffsengine.cpp moc_treemodel.cpp
UEFIPatch/Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include uefipatch.h -o moc_uefipatch.cpp
UEFIPatch/Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include ../ffsengine.h -o moc_ffsengine.cpp
UEFIPatch/Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/UEFIPatch -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include ../treemodel.h -o moc_treemodel.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o uefipatch_main.o uefipatch_main.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o uefipatch.o uefipatch.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o types.o ../types.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o descriptor.o ../descriptor.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o ffs.o ../ffs.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o ffsengine.o ../ffsengine.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o peimage.o ../peimage.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o treeitem.o ../treeitem.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o treemodel.o ../treemodel.cpp
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaCompress.o ../LZMA/LzmaCompress.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaDecompress.o ../LZMA/LzmaDecompress.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzFind.o ../LZMA/SDK/C/LzFind.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaDec.o ../LZMA/SDK/C/LzmaDec.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaEnc.o ../LZMA/SDK/C/LzmaEnc.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o Bra86.o ../LZMA/SDK/C/Bra86.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoDecompress.o ../Tiano/EfiTianoDecompress.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoCompress.o ../Tiano/EfiTianoCompress.c
UEFIPatch/Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoCompressLegacy.o ../Tiano/EfiTianoCompressLegacy.c
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_uefipatch.o moc_uefipatch.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_ffsengine.o moc_ffsengine.cpp
UEFIPatch/Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_treemodel.o moc_treemodel.cpp
.appveyor.yml:    - MSYS2_ARCH: i686
.appveyor.yml:  - cd %APPVEYOR_BUILD_FOLDER%
.appveyor.yml:  - set PATH=C:\msys64\mingw32\bin;C:\msys64\usr\bin;%PATH%
.appveyor.yml:  - bash ./unixbuild.sh
.appveyor.yml:  - path: dist\**\*.zip
moc_ffsengine.cpp:        - idx * sizeof(QByteArrayData)) \
moc_ffsengine.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
treemodel.h:http://opensource.org/licenses/bsd-license.php
.travis.yml:  - os: osx
.travis.yml:      - ./unixbuild.sh
.travis.yml:  - os: linux
.travis.yml:      - sudo apt-get update -qq
.travis.yml:      - sudo apt-get install -qq qt5-default qt5-qmake qtbase5-dev-tools cmake
.travis.yml:      - ./unixbuild.sh
.travis.yml:  - os: linux
.travis.yml:      - sudo apt-get update -qq
.travis.yml:      - sudo apt-get install -qq qt5-default qt5-qmake qtbase5-dev-tools cmake
.travis.yml:      - ./unixbuild.sh
basetypes.h:http://opensource.org/licenses/bsd-license.php
.gitignore:# CDT-specific
.gitignore:# PDT-specific
.gitignore:## files generated by popular Visual Studio add-ons.
.gitignore:# User-specific files
.gitignore:# ReSharper is a .NET coding add-in
.gitignore:# TeamCity is a build add-in
.gitignore:# DocProject is a documentation generator add-in
.gitignore:# Click-Once directory
.gitignore:# Visual Studio version. Backup files are not needed, because we have git ;-)
.gitignore:*.egg-info
.gitignore:develop-eggs/
.gitignore:pip-log.txt
peimage.cpp:http://opensource.org/licenses/bsd-license.php.
peimage.cpp:    case IMAGE_FILE_MACHINE_AMD64:  return QObject::tr("x86-64");
messagelistitem.cpp:  http://opensource.org/licenses/bsd-license.php
LZMA/UefiLzma.h:  http://opensource.org/licenses/bsd-license.php
LZMA/LzmaCompress.c:http://opensource.org/licenses/bsd-license.php
LZMA/LzmaDecompress.h:  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.
LZMA/LzmaDecompress.h:  http://opensource.org/licenses/bsd-license.php
LZMA/LzmaCompress.h:  http://opensource.org/licenses/bsd-license.php
LZMA/SDK/C/LzHash.h:/* LzHash.h -- HASH functions for LZ algorithms
LZMA/SDK/C/LzHash.h:2009-02-07 : Igor Pavlov : Public domain */
LZMA/SDK/C/LzHash.h:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
LZMA/SDK/C/LzHash.h:  hash2Value = temp & (kHash2Size - 1); \
LZMA/SDK/C/LzHash.h:  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
LZMA/SDK/C/LzHash.h:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
LZMA/SDK/C/LzHash.h:  hash2Value = temp & (kHash2Size - 1); \
LZMA/SDK/C/LzHash.h:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
LZMA/SDK/C/LzHash.h:  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
LZMA/SDK/C/LzHash.h:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
LZMA/SDK/C/LzHash.h:  hash2Value = temp & (kHash2Size - 1); \
LZMA/SDK/C/LzHash.h:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
LZMA/SDK/C/LzHash.h:  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
LZMA/SDK/C/LzHash.h:  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
LZMA/SDK/C/LzHash.h:  hash4Value &= (kHash4Size - 1); }
LZMA/SDK/C/LzHash.h:/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
LZMA/SDK/C/LzHash.h:#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
LZMA/SDK/C/LzHash.h:  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
LZMA/SDK/C/LzHash.h:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
LZMA/SDK/C/LzHash.h:  hash2Value = temp & (kHash2Size - 1); \
LZMA/SDK/C/LzHash.h:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
LZMA/SDK/C/LzHash.h:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
LZMA/SDK/C/LzHash.h:  hash2Value = temp & (kHash2Size - 1); \
LZMA/SDK/C/LzHash.h:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
LZMA/SDK/C/LzHash.h:  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
LZMA/SDK/C/LzFind.h:/* LzFind.h -- Match finder for LZ algorithms
LZMA/SDK/C/LzFind.h:2009-04-22 : Igor Pavlov : Public domain */
LZMA/SDK/C/LzFind.h:#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
LZMA/SDK/C/LzFind.h:#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
LZMA/SDK/C/LzFind.h:#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
LZMA/SDK/C/Types.h:/* Types.h -- Basic types
LZMA/SDK/C/Types.h:2010-10-09 : Igor Pavlov : Public domain */
LZMA/SDK/C/Types.h:/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
LZMA/SDK/C/Types.h:    /* Returns: result - the number of actually written bytes.
LZMA/SDK/C/Types.h:       Value (UInt64)(Int64)-1 for size means unknown value. */
LZMA/SDK/C/Types.h:#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
LZMA/SDK/C/Types.h:#define IAlloc_Free(p, a) (p)->Free((p), a)
LZMA/SDK/C/7zVersion.h:#define MY_DATE "2010-11-18"
LZMA/SDK/C/LzmaDec.h:/* LzmaDec.h -- LZMA Decoder
LZMA/SDK/C/LzmaDec.h:2009-02-07 : Igor Pavlov : Public domain */
LZMA/SDK/C/LzmaDec.h:/* ---------- LZMA Properties ---------- */
LZMA/SDK/C/LzmaDec.h:/* LzmaProps_Decode - decodes properties
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_UNSUPPORTED - Unsupported properties
LZMA/SDK/C/LzmaDec.h:/* ---------- LZMA Decoder state ---------- */
LZMA/SDK/C/LzmaDec.h:#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
LZMA/SDK/C/LzmaDec.h:/* ---------- Interfaces ---------- */
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_MEM         - Memory allocation error
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_UNSUPPORTED - Unsupported properties
LZMA/SDK/C/LzmaDec.h:/* ---------- Dictionary Interface ---------- */
LZMA/SDK/C/LzmaDec.h:  LZMA_FINISH_ANY - Decode just dicLimit bytes.
LZMA/SDK/C/LzmaDec.h:  LZMA_FINISH_END - Stream must be finished after dicLimit.
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_DATA - Data error
LZMA/SDK/C/LzmaDec.h:/* ---------- Buffer Interface ---------- */
LZMA/SDK/C/LzmaDec.h:/* It's zlib-like interface.
LZMA/SDK/C/LzmaDec.h:  LZMA_FINISH_ANY - Decode just destLen bytes.
LZMA/SDK/C/LzmaDec.h:  LZMA_FINISH_END - Stream must be finished after (*destLen).
LZMA/SDK/C/LzmaDec.h:/* ---------- One Call Interface ---------- */
LZMA/SDK/C/LzmaDec.h:  LZMA_FINISH_ANY - Decode just destLen bytes.
LZMA/SDK/C/LzmaDec.h:  LZMA_FINISH_END - Stream must be finished after (*destLen).
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_DATA - Data error
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_MEM  - Memory allocation error
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_UNSUPPORTED - Unsupported properties
LZMA/SDK/C/LzmaDec.h:  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
LZMA/SDK/C/LzmaEnc.c:/* LzmaEnc.c -- LZMA Encoder
LZMA/SDK/C/LzmaEnc.c:2010-04-16 : Igor Pavlov : Public domain*/
LZMA/SDK/C/LzmaEnc.c:#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
LZMA/SDK/C/LzmaEnc.c:    p->level = 5;
LZMA/SDK/C/LzmaEnc.c:    p->dictSize = p->mc = 0;
LZMA/SDK/C/LzmaEnc.c:    p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
LZMA/SDK/C/LzmaEnc.c:    p->writeEndMark = 0;
LZMA/SDK/C/LzmaEnc.c:    int level = p->level;
LZMA/SDK/C/LzmaEnc.c:    p->level = level;
LZMA/SDK/C/LzmaEnc.c:    if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
LZMA/SDK/C/LzmaEnc.c:    if (p->lc < 0) p->lc = 3;
LZMA/SDK/C/LzmaEnc.c:    if (p->lp < 0) p->lp = 0;
LZMA/SDK/C/LzmaEnc.c:    if (p->pb < 0) p->pb = 2;
LZMA/SDK/C/LzmaEnc.c:    if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
LZMA/SDK/C/LzmaEnc.c:    if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
LZMA/SDK/C/LzmaEnc.c:    if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
LZMA/SDK/C/LzmaEnc.c:    if (p->numHashBytes < 0) p->numHashBytes = 4;
LZMA/SDK/C/LzmaEnc.c:    if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
LZMA/SDK/C/LzmaEnc.c:    if (p->numThreads < 0)
LZMA/SDK/C/LzmaEnc.c:        p->numThreads =
LZMA/SDK/C/LzmaEnc.c:        ((p->btMode && p->algo) ? 2 : 1);
LZMA/SDK/C/LzmaEnc.c:#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
LZMA/SDK/C/LzmaEnc.c:#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
LZMA/SDK/C/LzmaEnc.c:        UInt32 k = (1 << ((slotFast >> 1) - 1));
LZMA/SDK/C/LzmaEnc.c:#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
LZMA/SDK/C/LzmaEnc.c:  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
LZMA/SDK/C/LzmaEnc.c:  res = p->g_FastPos[pos >> i] + (i * 2); }
LZMA/SDK/C/LzmaEnc.c:  p->g_FastPos[pos >> 6] + 12 : \
LZMA/SDK/C/LzmaEnc.c:  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
LZMA/SDK/C/LzmaEnc.c:#define GetPosSlot1(pos) p->g_FastPos[pos]
LZMA/SDK/C/LzmaEnc.c:#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
LZMA/SDK/C/LzmaEnc.c:#define kAlignMask (kAlignTableSize - 1)
LZMA/SDK/C/LzmaEnc.c:#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
LZMA/SDK/C/LzmaEnc.c:#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
LZMA/SDK/C/LzmaEnc.c:    CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
LZMA/SDK/C/LzmaEnc.c:    CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
LZMA/SDK/C/LzmaEnc.c:    CSaveState *dest = &p->saveState;
LZMA/SDK/C/LzmaEnc.c:    dest->lenEnc = p->lenEnc;
LZMA/SDK/C/LzmaEnc.c:    dest->repLenEnc = p->repLenEnc;
LZMA/SDK/C/LzmaEnc.c:    dest->state = p->state;
LZMA/SDK/C/LzmaEnc.c:        memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
LZMA/SDK/C/LzmaEnc.c:        memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
LZMA/SDK/C/LzmaEnc.c:        memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->reps, p->reps, sizeof(p->reps));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
LZMA/SDK/C/LzmaEnc.c:    const CSaveState *p = &dest->saveState;
LZMA/SDK/C/LzmaEnc.c:    dest->lenEnc = p->lenEnc;
LZMA/SDK/C/LzmaEnc.c:    dest->repLenEnc = p->repLenEnc;
LZMA/SDK/C/LzmaEnc.c:    dest->state = p->state;
LZMA/SDK/C/LzmaEnc.c:        memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
LZMA/SDK/C/LzmaEnc.c:        memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
LZMA/SDK/C/LzmaEnc.c:        memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->reps, p->reps, sizeof(p->reps));
LZMA/SDK/C/LzmaEnc.c:    memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
LZMA/SDK/C/LzmaEnc.c:    p->dictSize = props.dictSize;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderCycles = props.mc;
LZMA/SDK/C/LzmaEnc.c:        p->numFastBytes = fb;
LZMA/SDK/C/LzmaEnc.c:    p->lc = props.lc;
LZMA/SDK/C/LzmaEnc.c:    p->lp = props.lp;
LZMA/SDK/C/LzmaEnc.c:    p->pb = props.pb;
LZMA/SDK/C/LzmaEnc.c:    p->fastMode = (props.algo == 0);
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.btMode = props.btMode;
LZMA/SDK/C/LzmaEnc.c:        p->matchFinderBase.numHashBytes = numHashBytes;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.cutValue = props.mc;
LZMA/SDK/C/LzmaEnc.c:    p->writeEndMark = props.writeEndMark;
LZMA/SDK/C/LzmaEnc.c:    p->multiThread = (props.numThreads > 1);
LZMA/SDK/C/LzmaEnc.c:#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
LZMA/SDK/C/LzmaEnc.c:    p->outStream = 0;
LZMA/SDK/C/LzmaEnc.c:    p->bufBase = 0;
LZMA/SDK/C/LzmaEnc.c:#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
LZMA/SDK/C/LzmaEnc.c:    if (p->bufBase == 0)
LZMA/SDK/C/LzmaEnc.c:        p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
LZMA/SDK/C/LzmaEnc.c:        if (p->bufBase == 0)
LZMA/SDK/C/LzmaEnc.c:        p->bufLim = p->bufBase + RC_BUF_SIZE;
LZMA/SDK/C/LzmaEnc.c:    alloc->Free(alloc, p->bufBase);
LZMA/SDK/C/LzmaEnc.c:    p->bufBase = 0;
LZMA/SDK/C/LzmaEnc.c:    p->low = 0;
LZMA/SDK/C/LzmaEnc.c:    p->range = 0xFFFFFFFF;
LZMA/SDK/C/LzmaEnc.c:    p->cacheSize = 1;
LZMA/SDK/C/LzmaEnc.c:    p->cache = 0;
LZMA/SDK/C/LzmaEnc.c:    p->buf = p->bufBase;
LZMA/SDK/C/LzmaEnc.c:    p->processed = 0;
LZMA/SDK/C/LzmaEnc.c:    p->res = SZ_OK;
LZMA/SDK/C/LzmaEnc.c:    if (p->res != SZ_OK)
LZMA/SDK/C/LzmaEnc.c:    num = p->buf - p->bufBase;
LZMA/SDK/C/LzmaEnc.c:    if (num != p->outStream->Write(p->outStream, p->bufBase, num))
LZMA/SDK/C/LzmaEnc.c:        p->res = SZ_ERROR_WRITE;
LZMA/SDK/C/LzmaEnc.c:    p->processed += num;
LZMA/SDK/C/LzmaEnc.c:    p->buf = p->bufBase;
LZMA/SDK/C/LzmaEnc.c:    if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
LZMA/SDK/C/LzmaEnc.c:        Byte temp = p->cache;
LZMA/SDK/C/LzmaEnc.c:            Byte *buf = p->buf;
LZMA/SDK/C/LzmaEnc.c:            *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
LZMA/SDK/C/LzmaEnc.c:            p->buf = buf;
LZMA/SDK/C/LzmaEnc.c:            if (buf == p->bufLim)
LZMA/SDK/C/LzmaEnc.c:        } while (--p->cacheSize != 0);
LZMA/SDK/C/LzmaEnc.c:        p->cache = (Byte)((UInt32)p->low >> 24);
LZMA/SDK/C/LzmaEnc.c:    p->cacheSize++;
LZMA/SDK/C/LzmaEnc.c:    p->low = (UInt32)p->low << 8;
LZMA/SDK/C/LzmaEnc.c:        p->range >>= 1;
LZMA/SDK/C/LzmaEnc.c:        p->low += p->range & (0 - ((value >> --numBits) & 1));
LZMA/SDK/C/LzmaEnc.c:        if (p->range < kTopValue)
LZMA/SDK/C/LzmaEnc.c:            p->range <<= 8;
LZMA/SDK/C/LzmaEnc.c:    UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
LZMA/SDK/C/LzmaEnc.c:        p->range = newBound;
LZMA/SDK/C/LzmaEnc.c:        ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
LZMA/SDK/C/LzmaEnc.c:        p->low += newBound;
LZMA/SDK/C/LzmaEnc.c:        p->range -= newBound;
LZMA/SDK/C/LzmaEnc.c:        ttt -= ttt >> kNumMoveBits;
LZMA/SDK/C/LzmaEnc.c:    if (p->range < kTopValue)
LZMA/SDK/C/LzmaEnc.c:        p->range <<= 8;
LZMA/SDK/C/LzmaEnc.c:        ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
LZMA/SDK/C/LzmaEnc.c:  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
LZMA/SDK/C/LzmaEnc.c:  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
LZMA/SDK/C/LzmaEnc.c:#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
LZMA/SDK/C/LzmaEnc.c:#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
LZMA/SDK/C/LzmaEnc.c:#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
LZMA/SDK/C/LzmaEnc.c:        i--;
LZMA/SDK/C/LzmaEnc.c:    for (i = numBitLevels; i != 0; i--)
LZMA/SDK/C/LzmaEnc.c:    p->choice = p->choice2 = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->low[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->mid[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->high[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        RangeEnc_EncodeBit(rc, &p->choice, 0);
LZMA/SDK/C/LzmaEnc.c:        RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
LZMA/SDK/C/LzmaEnc.c:        RangeEnc_EncodeBit(rc, &p->choice, 1);
LZMA/SDK/C/LzmaEnc.c:            RangeEnc_EncodeBit(rc, &p->choice2, 0);
LZMA/SDK/C/LzmaEnc.c:            RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
LZMA/SDK/C/LzmaEnc.c:            RangeEnc_EncodeBit(rc, &p->choice2, 1);
LZMA/SDK/C/LzmaEnc.c:            RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
LZMA/SDK/C/LzmaEnc.c:    UInt32 a0 = GET_PRICE_0a(p->choice);
LZMA/SDK/C/LzmaEnc.c:    UInt32 a1 = GET_PRICE_1a(p->choice);
LZMA/SDK/C/LzmaEnc.c:    UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
LZMA/SDK/C/LzmaEnc.c:    UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
LZMA/SDK/C/LzmaEnc.c:        prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
LZMA/SDK/C/LzmaEnc.c:        prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
LZMA/SDK/C/LzmaEnc.c:        prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
LZMA/SDK/C/LzmaEnc.c:    LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
LZMA/SDK/C/LzmaEnc.c:    p->counters[posState] = p->tableSize;
LZMA/SDK/C/LzmaEnc.c:    LenEnc_Encode(&p->p, rc, symbol, posState);
LZMA/SDK/C/LzmaEnc.c:        if (--p->counters[posState] == 0)
LZMA/SDK/C/LzmaEnc.c:        p->additionalOffset += num;
LZMA/SDK/C/LzmaEnc.c:        p->matchFinder.Skip(p->matchFinderObj, num);
LZMA/SDK/C/LzmaEnc.c:    p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
LZMA/SDK/C/LzmaEnc.c:    numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
LZMA/SDK/C/LzmaEnc.c:            printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
LZMA/SDK/C/LzmaEnc.c:        lenRes = p->matches[numPairs - 2];
LZMA/SDK/C/LzmaEnc.c:        if (lenRes == p->numFastBytes)
LZMA/SDK/C/LzmaEnc.c:            const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
LZMA/SDK/C/LzmaEnc.c:            UInt32 distance = p->matches[numPairs - 1] + 1;
LZMA/SDK/C/LzmaEnc.c:            UInt32 numAvail = p->numAvail;
LZMA/SDK/C/LzmaEnc.c:                const Byte *pby2 = pby - distance;
LZMA/SDK/C/LzmaEnc.c:    p->additionalOffset++;
LZMA/SDK/C/LzmaEnc.c:#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:#define IsShortRep(p) ((p)->backPrev == 0)
LZMA/SDK/C/LzmaEnc.c:        GET_PRICE_0(p->isRepG0[state]) +
LZMA/SDK/C/LzmaEnc.c:        GET_PRICE_0(p->isRep0Long[state][posState]);
LZMA/SDK/C/LzmaEnc.c:        price = GET_PRICE_0(p->isRepG0[state]);
LZMA/SDK/C/LzmaEnc.c:        price += GET_PRICE_1(p->isRep0Long[state][posState]);
LZMA/SDK/C/LzmaEnc.c:        price = GET_PRICE_1(p->isRepG0[state]);
LZMA/SDK/C/LzmaEnc.c:            price += GET_PRICE_0(p->isRepG1[state]);
LZMA/SDK/C/LzmaEnc.c:            price += GET_PRICE_1(p->isRepG1[state]);
LZMA/SDK/C/LzmaEnc.c:            price += GET_PRICE(p->isRepG2[state], repIndex - 2);
LZMA/SDK/C/LzmaEnc.c:    return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
LZMA/SDK/C/LzmaEnc.c:    UInt32 posMem = p->opt[cur].posPrev;
LZMA/SDK/C/LzmaEnc.c:    UInt32 backMem = p->opt[cur].backPrev;
LZMA/SDK/C/LzmaEnc.c:    p->optimumEndIndex = cur;
LZMA/SDK/C/LzmaEnc.c:        if (p->opt[cur].prev1IsChar)
LZMA/SDK/C/LzmaEnc.c:            MakeAsChar(&p->opt[posMem])
LZMA/SDK/C/LzmaEnc.c:                p->opt[posMem].posPrev = posMem - 1;
LZMA/SDK/C/LzmaEnc.c:            if (p->opt[cur].prev2)
LZMA/SDK/C/LzmaEnc.c:                p->opt[posMem - 1].prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:                p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
LZMA/SDK/C/LzmaEnc.c:                p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
LZMA/SDK/C/LzmaEnc.c:        backMem = p->opt[posPrev].backPrev;
LZMA/SDK/C/LzmaEnc.c:        posMem = p->opt[posPrev].posPrev;
LZMA/SDK/C/LzmaEnc.c:        p->opt[posPrev].backPrev = backCur;
LZMA/SDK/C/LzmaEnc.c:        p->opt[posPrev].posPrev = cur;
LZMA/SDK/C/LzmaEnc.c:    *backRes = p->opt[0].backPrev;
LZMA/SDK/C/LzmaEnc.c:    p->optimumCurrentIndex = p->opt[0].posPrev;
LZMA/SDK/C/LzmaEnc.c:    return p->optimumCurrentIndex;
LZMA/SDK/C/LzmaEnc.c:#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
LZMA/SDK/C/LzmaEnc.c:    if (p->optimumEndIndex != p->optimumCurrentIndex)
LZMA/SDK/C/LzmaEnc.c:        const COptimal *opt = &p->opt[p->optimumCurrentIndex];
LZMA/SDK/C/LzmaEnc.c:        UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
LZMA/SDK/C/LzmaEnc.c:        *backRes = opt->backPrev;
LZMA/SDK/C/LzmaEnc.c:        p->optimumCurrentIndex = opt->posPrev;
LZMA/SDK/C/LzmaEnc.c:    p->optimumCurrentIndex = p->optimumEndIndex = 0;
LZMA/SDK/C/LzmaEnc.c:    if (p->additionalOffset == 0)
LZMA/SDK/C/LzmaEnc.c:        mainLen = p->longestMatchLength;
LZMA/SDK/C/LzmaEnc.c:        numPairs = p->numPairs;
LZMA/SDK/C/LzmaEnc.c:    numAvail = p->numAvail;
LZMA/SDK/C/LzmaEnc.c:        *backRes = (UInt32)(-1);
LZMA/SDK/C/LzmaEnc.c:    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
LZMA/SDK/C/LzmaEnc.c:        reps[i] = p->reps[i];
LZMA/SDK/C/LzmaEnc.c:        data2 = data - (reps[i] + 1);
LZMA/SDK/C/LzmaEnc.c:    if (repLens[repMaxIndex] >= p->numFastBytes)
LZMA/SDK/C/LzmaEnc.c:        MovePos(p, lenRes - 1);
LZMA/SDK/C/LzmaEnc.c:    matches = p->matches;
LZMA/SDK/C/LzmaEnc.c:    if (mainLen >= p->numFastBytes)
LZMA/SDK/C/LzmaEnc.c:        *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
LZMA/SDK/C/LzmaEnc.c:        MovePos(p, mainLen - 1);
LZMA/SDK/C/LzmaEnc.c:    matchByte = *(data - (reps[0] + 1));
LZMA/SDK/C/LzmaEnc.c:        *backRes = (UInt32)-1;
LZMA/SDK/C/LzmaEnc.c:    p->opt[0].state = (CState)p->state;
LZMA/SDK/C/LzmaEnc.c:    posState = (position & p->pbMask);
LZMA/SDK/C/LzmaEnc.c:        const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
LZMA/SDK/C/LzmaEnc.c:        p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
LZMA/SDK/C/LzmaEnc.c:            (!IsCharState(p->state) ?
LZMA/SDK/C/LzmaEnc.c:            LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
LZMA/SDK/C/LzmaEnc.c:            LitEnc_GetPrice(probs, curByte, p->ProbPrices));
LZMA/SDK/C/LzmaEnc.c:    MakeAsChar(&p->opt[1]);
LZMA/SDK/C/LzmaEnc.c:    matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
LZMA/SDK/C/LzmaEnc.c:    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
LZMA/SDK/C/LzmaEnc.c:        UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
LZMA/SDK/C/LzmaEnc.c:        if (shortRepPrice < p->opt[1].price)
LZMA/SDK/C/LzmaEnc.c:            p->opt[1].price = shortRepPrice;
LZMA/SDK/C/LzmaEnc.c:            MakeAsShortRep(&p->opt[1]);
LZMA/SDK/C/LzmaEnc.c:        *backRes = p->opt[1].backPrev;
LZMA/SDK/C/LzmaEnc.c:    p->opt[1].posPrev = 0;
LZMA/SDK/C/LzmaEnc.c:        p->opt[0].backs[i] = reps[i];
LZMA/SDK/C/LzmaEnc.c:        p->opt[len--].price = kInfinityPrice;
LZMA/SDK/C/LzmaEnc.c:        price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
LZMA/SDK/C/LzmaEnc.c:            UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
LZMA/SDK/C/LzmaEnc.c:            COptimal *opt = &p->opt[repLen];
LZMA/SDK/C/LzmaEnc.c:            if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                opt->posPrev = 0;
LZMA/SDK/C/LzmaEnc.c:                opt->backPrev = i;
LZMA/SDK/C/LzmaEnc.c:                opt->prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:        } while (--repLen >= 2);
LZMA/SDK/C/LzmaEnc.c:    normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
LZMA/SDK/C/LzmaEnc.c:            UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
LZMA/SDK/C/LzmaEnc.c:                curAndLenPrice += p->distancesPrices[lenToPosState][distance];
LZMA/SDK/C/LzmaEnc.c:                curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
LZMA/SDK/C/LzmaEnc.c:            opt = &p->opt[len];
LZMA/SDK/C/LzmaEnc.c:            if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                opt->posPrev = 0;
LZMA/SDK/C/LzmaEnc.c:                opt->backPrev = distance + LZMA_NUM_REPS;
LZMA/SDK/C/LzmaEnc.c:                opt->prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:            printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
LZMA/SDK/C/LzmaEnc.c:        if (newLen >= p->numFastBytes)
LZMA/SDK/C/LzmaEnc.c:            p->numPairs = numPairs;
LZMA/SDK/C/LzmaEnc.c:            p->longestMatchLength = newLen;
LZMA/SDK/C/LzmaEnc.c:        curOpt = &p->opt[cur];
LZMA/SDK/C/LzmaEnc.c:        posPrev = curOpt->posPrev;
LZMA/SDK/C/LzmaEnc.c:        if (curOpt->prev1IsChar)
LZMA/SDK/C/LzmaEnc.c:            posPrev--;
LZMA/SDK/C/LzmaEnc.c:            if (curOpt->prev2)
LZMA/SDK/C/LzmaEnc.c:                state = p->opt[curOpt->posPrev2].state;
LZMA/SDK/C/LzmaEnc.c:                if (curOpt->backPrev2 < LZMA_NUM_REPS)
LZMA/SDK/C/LzmaEnc.c:                state = p->opt[posPrev].state;
LZMA/SDK/C/LzmaEnc.c:            state = p->opt[posPrev].state;
LZMA/SDK/C/LzmaEnc.c:        if (posPrev == cur - 1)
LZMA/SDK/C/LzmaEnc.c:            if (curOpt->prev1IsChar && curOpt->prev2)
LZMA/SDK/C/LzmaEnc.c:                posPrev = curOpt->posPrev2;
LZMA/SDK/C/LzmaEnc.c:                pos = curOpt->backPrev2;
LZMA/SDK/C/LzmaEnc.c:                pos = curOpt->backPrev;
LZMA/SDK/C/LzmaEnc.c:            prevOpt = &p->opt[posPrev];
LZMA/SDK/C/LzmaEnc.c:                reps[0] = prevOpt->backs[pos];
LZMA/SDK/C/LzmaEnc.c:                    reps[i] = prevOpt->backs[i - 1];
LZMA/SDK/C/LzmaEnc.c:                    reps[i] = prevOpt->backs[i];
LZMA/SDK/C/LzmaEnc.c:                reps[0] = (pos - LZMA_NUM_REPS);
LZMA/SDK/C/LzmaEnc.c:                    reps[i] = prevOpt->backs[i - 1];
LZMA/SDK/C/LzmaEnc.c:        curOpt->state = (CState)state;
LZMA/SDK/C/LzmaEnc.c:        curOpt->backs[0] = reps[0];
LZMA/SDK/C/LzmaEnc.c:        curOpt->backs[1] = reps[1];
LZMA/SDK/C/LzmaEnc.c:        curOpt->backs[2] = reps[2];
LZMA/SDK/C/LzmaEnc.c:        curOpt->backs[3] = reps[3];
LZMA/SDK/C/LzmaEnc.c:        curPrice = curOpt->price;
LZMA/SDK/C/LzmaEnc.c:        data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
LZMA/SDK/C/LzmaEnc.c:        matchByte = *(data - (reps[0] + 1));
LZMA/SDK/C/LzmaEnc.c:        posState = (position & p->pbMask);
LZMA/SDK/C/LzmaEnc.c:        curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
LZMA/SDK/C/LzmaEnc.c:            const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
LZMA/SDK/C/LzmaEnc.c:                LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
LZMA/SDK/C/LzmaEnc.c:                LitEnc_GetPrice(probs, curByte, p->ProbPrices));
LZMA/SDK/C/LzmaEnc.c:        nextOpt = &p->opt[cur + 1];
LZMA/SDK/C/LzmaEnc.c:        if (curAnd1Price < nextOpt->price)
LZMA/SDK/C/LzmaEnc.c:            nextOpt->price = curAnd1Price;
LZMA/SDK/C/LzmaEnc.c:            nextOpt->posPrev = cur;
LZMA/SDK/C/LzmaEnc.c:        matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
LZMA/SDK/C/LzmaEnc.c:        repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
LZMA/SDK/C/LzmaEnc.c:        if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
LZMA/SDK/C/LzmaEnc.c:            if (shortRepPrice <= nextOpt->price)
LZMA/SDK/C/LzmaEnc.c:                nextOpt->price = shortRepPrice;
LZMA/SDK/C/LzmaEnc.c:                nextOpt->posPrev = cur;
LZMA/SDK/C/LzmaEnc.c:        numAvailFull = p->numAvail;
LZMA/SDK/C/LzmaEnc.c:            UInt32 temp = kNumOpts - 1 - cur;
LZMA/SDK/C/LzmaEnc.c:        numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
LZMA/SDK/C/LzmaEnc.c:            const Byte *data2 = data - (reps[0] + 1);
LZMA/SDK/C/LzmaEnc.c:            UInt32 limit = p->numFastBytes + 1;
LZMA/SDK/C/LzmaEnc.c:            lenTest2 = temp - 1;
LZMA/SDK/C/LzmaEnc.c:                UInt32 posStateNext = (position + 1) & p->pbMask;
LZMA/SDK/C/LzmaEnc.c:                    GET_PRICE_1(p->isMatch[state2][posStateNext]) +
LZMA/SDK/C/LzmaEnc.c:                    GET_PRICE_1(p->isRep[state2]);
LZMA/SDK/C/LzmaEnc.c:                /* for (; lenTest2 >= 2; lenTest2--) */
LZMA/SDK/C/LzmaEnc.c:                        p->opt[++lenEnd].price = kInfinityPrice;
LZMA/SDK/C/LzmaEnc.c:                    opt = &p->opt[offset];
LZMA/SDK/C/LzmaEnc.c:                    if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                        opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                        opt->posPrev = cur + 1;
LZMA/SDK/C/LzmaEnc.c:                        opt->backPrev = 0;
LZMA/SDK/C/LzmaEnc.c:                        opt->prev1IsChar = True;
LZMA/SDK/C/LzmaEnc.c:                        opt->prev2 = False;
LZMA/SDK/C/LzmaEnc.c:                const Byte *data2 = data - (reps[repIndex] + 1);
LZMA/SDK/C/LzmaEnc.c:                    p->opt[++lenEnd].price = kInfinityPrice;
LZMA/SDK/C/LzmaEnc.c:                    UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
LZMA/SDK/C/LzmaEnc.c:                    COptimal *opt = &p->opt[cur + lenTest];
LZMA/SDK/C/LzmaEnc.c:                    if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                        opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                        opt->posPrev = cur;
LZMA/SDK/C/LzmaEnc.c:                        opt->backPrev = repIndex;
LZMA/SDK/C/LzmaEnc.c:                        opt->prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:                } while (--lenTest >= 2);
LZMA/SDK/C/LzmaEnc.c:                    UInt32 limit = lenTest2 + p->numFastBytes;
LZMA/SDK/C/LzmaEnc.c:                    lenTest2 -= lenTest + 1;
LZMA/SDK/C/LzmaEnc.c:                        UInt32 posStateNext = (position + lenTest) & p->pbMask;
LZMA/SDK/C/LzmaEnc.c:                            price + p->repLenEnc.prices[posState][lenTest - 2] +
LZMA/SDK/C/LzmaEnc.c:                            GET_PRICE_0(p->isMatch[state2][posStateNext]) +
LZMA/SDK/C/LzmaEnc.c:                            LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
LZMA/SDK/C/LzmaEnc.c:                            data[lenTest], data2[lenTest], p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:                        posStateNext = (position + lenTest + 1) & p->pbMask;
LZMA/SDK/C/LzmaEnc.c:                            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
LZMA/SDK/C/LzmaEnc.c:                            GET_PRICE_1(p->isRep[state2]);
LZMA/SDK/C/LzmaEnc.c:                        /* for (; lenTest2 >= 2; lenTest2--) */
LZMA/SDK/C/LzmaEnc.c:                                p->opt[++lenEnd].price = kInfinityPrice;
LZMA/SDK/C/LzmaEnc.c:                            opt = &p->opt[offset];
LZMA/SDK/C/LzmaEnc.c:                            if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                                opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                                opt->posPrev = cur + lenTest + 1;
LZMA/SDK/C/LzmaEnc.c:                                opt->backPrev = 0;
LZMA/SDK/C/LzmaEnc.c:                                opt->prev1IsChar = True;
LZMA/SDK/C/LzmaEnc.c:                                opt->prev2 = True;
LZMA/SDK/C/LzmaEnc.c:                                opt->posPrev2 = cur;
LZMA/SDK/C/LzmaEnc.c:                                opt->backPrev2 = repIndex;
LZMA/SDK/C/LzmaEnc.c:            UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
LZMA/SDK/C/LzmaEnc.c:                p->opt[++lenEnd].price = kInfinityPrice;
LZMA/SDK/C/LzmaEnc.c:                UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
LZMA/SDK/C/LzmaEnc.c:                    curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
LZMA/SDK/C/LzmaEnc.c:                    curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
LZMA/SDK/C/LzmaEnc.c:                opt = &p->opt[cur + lenTest];
LZMA/SDK/C/LzmaEnc.c:                if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                    opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                    opt->posPrev = cur;
LZMA/SDK/C/LzmaEnc.c:                    opt->backPrev = curBack + LZMA_NUM_REPS;
LZMA/SDK/C/LzmaEnc.c:                    opt->prev1IsChar = False;
LZMA/SDK/C/LzmaEnc.c:                    const Byte *data2 = data - (curBack + 1);
LZMA/SDK/C/LzmaEnc.c:                    UInt32 limit = lenTest2 + p->numFastBytes;
LZMA/SDK/C/LzmaEnc.c:                    lenTest2 -= lenTest + 1;
LZMA/SDK/C/LzmaEnc.c:                        UInt32 posStateNext = (position + lenTest) & p->pbMask;
LZMA/SDK/C/LzmaEnc.c:                            GET_PRICE_0(p->isMatch[state2][posStateNext]) +
LZMA/SDK/C/LzmaEnc.c:                            LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
LZMA/SDK/C/LzmaEnc.c:                            data[lenTest], data2[lenTest], p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:                        posStateNext = (posStateNext + 1) & p->pbMask;
LZMA/SDK/C/LzmaEnc.c:                            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
LZMA/SDK/C/LzmaEnc.c:                            GET_PRICE_1(p->isRep[state2]);
LZMA/SDK/C/LzmaEnc.c:                        /* for (; lenTest2 >= 2; lenTest2--) */
LZMA/SDK/C/LzmaEnc.c:                                p->opt[++lenEnd].price = kInfinityPrice;
LZMA/SDK/C/LzmaEnc.c:                            opt = &p->opt[offset];
LZMA/SDK/C/LzmaEnc.c:                            if (curAndLenPrice < opt->price)
LZMA/SDK/C/LzmaEnc.c:                                opt->price = curAndLenPrice;
LZMA/SDK/C/LzmaEnc.c:                                opt->posPrev = cur + lenTest + 1;
LZMA/SDK/C/LzmaEnc.c:                                opt->backPrev = 0;
LZMA/SDK/C/LzmaEnc.c:                                opt->prev1IsChar = True;
LZMA/SDK/C/LzmaEnc.c:                                opt->prev2 = True;
LZMA/SDK/C/LzmaEnc.c:                                opt->posPrev2 = cur;
LZMA/SDK/C/LzmaEnc.c:                                opt->backPrev2 = curBack + LZMA_NUM_REPS;
LZMA/SDK/C/LzmaEnc.c:    if (p->additionalOffset == 0)
LZMA/SDK/C/LzmaEnc.c:        mainLen = p->longestMatchLength;
LZMA/SDK/C/LzmaEnc.c:        numPairs = p->numPairs;
LZMA/SDK/C/LzmaEnc.c:    numAvail = p->numAvail;
LZMA/SDK/C/LzmaEnc.c:    *backRes = (UInt32)-1;
LZMA/SDK/C/LzmaEnc.c:    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
LZMA/SDK/C/LzmaEnc.c:        const Byte *data2 = data - (p->reps[i] + 1);
LZMA/SDK/C/LzmaEnc.c:        if (len >= p->numFastBytes)
LZMA/SDK/C/LzmaEnc.c:            MovePos(p, len - 1);
LZMA/SDK/C/LzmaEnc.c:    matches = p->matches;
LZMA/SDK/C/LzmaEnc.c:    if (mainLen >= p->numFastBytes)
LZMA/SDK/C/LzmaEnc.c:        *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
LZMA/SDK/C/LzmaEnc.c:        MovePos(p, mainLen - 1);
LZMA/SDK/C/LzmaEnc.c:        mainDist = matches[numPairs - 1];
LZMA/SDK/C/LzmaEnc.c:        while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
LZMA/SDK/C/LzmaEnc.c:            if (!ChangePair(matches[numPairs - 3], mainDist))
LZMA/SDK/C/LzmaEnc.c:            numPairs -= 2;
LZMA/SDK/C/LzmaEnc.c:            mainLen = matches[numPairs - 2];
LZMA/SDK/C/LzmaEnc.c:            mainDist = matches[numPairs - 1];
LZMA/SDK/C/LzmaEnc.c:        MovePos(p, repLen - 1);
LZMA/SDK/C/LzmaEnc.c:    p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
LZMA/SDK/C/LzmaEnc.c:    if (p->longestMatchLength >= 2)
LZMA/SDK/C/LzmaEnc.c:        UInt32 newDistance = matches[p->numPairs - 1];
LZMA/SDK/C/LzmaEnc.c:        if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
LZMA/SDK/C/LzmaEnc.c:            (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
LZMA/SDK/C/LzmaEnc.c:            (p->longestMatchLength > mainLen + 1) ||
LZMA/SDK/C/LzmaEnc.c:            (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
LZMA/SDK/C/LzmaEnc.c:    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
LZMA/SDK/C/LzmaEnc.c:        const Byte *data2 = data - (p->reps[i] + 1);
LZMA/SDK/C/LzmaEnc.c:        limit = mainLen - 1;
LZMA/SDK/C/LzmaEnc.c:    MovePos(p, mainLen - 2);
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
LZMA/SDK/C/LzmaEnc.c:    p->state = kMatchNextStates[p->state];
LZMA/SDK/C/LzmaEnc.c:    LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:    RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
LZMA/SDK/C/LzmaEnc.c:    RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
LZMA/SDK/C/LzmaEnc.c:    if (p->result != SZ_OK)
LZMA/SDK/C/LzmaEnc.c:        return p->result;
LZMA/SDK/C/LzmaEnc.c:    if (p->rc.res != SZ_OK)
LZMA/SDK/C/LzmaEnc.c:        p->result = SZ_ERROR_WRITE;
LZMA/SDK/C/LzmaEnc.c:    if (p->matchFinderBase.result != SZ_OK)
LZMA/SDK/C/LzmaEnc.c:        p->result = SZ_ERROR_READ;
LZMA/SDK/C/LzmaEnc.c:    if (p->result != SZ_OK)
LZMA/SDK/C/LzmaEnc.c:        p->finished = True;
LZMA/SDK/C/LzmaEnc.c:    return p->result;
LZMA/SDK/C/LzmaEnc.c:    p->finished = True;
LZMA/SDK/C/LzmaEnc.c:    if (p->writeEndMark)
LZMA/SDK/C/LzmaEnc.c:        WriteEndMarker(p, nowPos & p->pbMask);
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_FlushData(&p->rc);
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_FlushStream(&p->rc);
LZMA/SDK/C/LzmaEnc.c:        p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:    p->alignPriceCount = 0;
LZMA/SDK/C/LzmaEnc.c:        UInt32 footerBits = ((posSlot >> 1) - 1);
LZMA/SDK/C/LzmaEnc.c:        tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:        const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
LZMA/SDK/C/LzmaEnc.c:        UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
LZMA/SDK/C/LzmaEnc.c:        for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
LZMA/SDK/C/LzmaEnc.c:            posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:        for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
LZMA/SDK/C/LzmaEnc.c:            posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
LZMA/SDK/C/LzmaEnc.c:            UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
LZMA/SDK/C/LzmaEnc.c:    p->matchPriceCount = 0;
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_Construct(&p->rc);
LZMA/SDK/C/LzmaEnc.c:    MatchFinder_Construct(&p->matchFinderBase);
LZMA/SDK/C/LzmaEnc.c:    MatchFinderMt_Construct(&p->matchFinderMt);
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderMt.MatchFinder = &p->matchFinderBase;
LZMA/SDK/C/LzmaEnc.c:    LzmaEnc_FastPosInit(p->g_FastPos);
LZMA/SDK/C/LzmaEnc.c:    LzmaEnc_InitPriceTables(p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:    p->litProbs = 0;
LZMA/SDK/C/LzmaEnc.c:    p->saveState.litProbs = 0;
LZMA/SDK/C/LzmaEnc.c:    p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
LZMA/SDK/C/LzmaEnc.c:    alloc->Free(alloc, p->litProbs);
LZMA/SDK/C/LzmaEnc.c:    alloc->Free(alloc, p->saveState.litProbs);
LZMA/SDK/C/LzmaEnc.c:    p->litProbs = 0;
LZMA/SDK/C/LzmaEnc.c:    p->saveState.litProbs = 0;
LZMA/SDK/C/LzmaEnc.c:    MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
LZMA/SDK/C/LzmaEnc.c:    MatchFinder_Free(&p->matchFinderBase, allocBig);
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_Free(&p->rc, alloc);
LZMA/SDK/C/LzmaEnc.c:    alloc->Free(alloc, p);
LZMA/SDK/C/LzmaEnc.c:    if (p->needInit)
LZMA/SDK/C/LzmaEnc.c:        p->matchFinder.Init(p->matchFinderObj);
LZMA/SDK/C/LzmaEnc.c:        p->needInit = 0;
LZMA/SDK/C/LzmaEnc.c:    if (p->finished)
LZMA/SDK/C/LzmaEnc.c:        return p->result;
LZMA/SDK/C/LzmaEnc.c:    nowPos32 = (UInt32)p->nowPos64;
LZMA/SDK/C/LzmaEnc.c:    if (p->nowPos64 == 0)
LZMA/SDK/C/LzmaEnc.c:        if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
LZMA/SDK/C/LzmaEnc.c:        RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
LZMA/SDK/C/LzmaEnc.c:        p->state = kLiteralNextStates[p->state];
LZMA/SDK/C/LzmaEnc.c:        curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
LZMA/SDK/C/LzmaEnc.c:        LitEnc_Encode(&p->rc, p->litProbs, curByte);
LZMA/SDK/C/LzmaEnc.c:        p->additionalOffset--;
LZMA/SDK/C/LzmaEnc.c:    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
LZMA/SDK/C/LzmaEnc.c:        if (p->fastMode)
LZMA/SDK/C/LzmaEnc.c:        posState = nowPos32 & p->pbMask;
LZMA/SDK/C/LzmaEnc.c:        if (len == 1 && pos == (UInt32)-1)
LZMA/SDK/C/LzmaEnc.c:            RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
LZMA/SDK/C/LzmaEnc.c:            data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
LZMA/SDK/C/LzmaEnc.c:            probs = LIT_PROBS(nowPos32, *(data - 1));
LZMA/SDK/C/LzmaEnc.c:            if (IsCharState(p->state))
LZMA/SDK/C/LzmaEnc.c:                LitEnc_Encode(&p->rc, probs, curByte);
LZMA/SDK/C/LzmaEnc.c:                LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
LZMA/SDK/C/LzmaEnc.c:            p->state = kLiteralNextStates[p->state];
LZMA/SDK/C/LzmaEnc.c:            RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
LZMA/SDK/C/LzmaEnc.c:                RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
LZMA/SDK/C/LzmaEnc.c:                    RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
LZMA/SDK/C/LzmaEnc.c:                    RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
LZMA/SDK/C/LzmaEnc.c:                    UInt32 distance = p->reps[pos];
LZMA/SDK/C/LzmaEnc.c:                    RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
LZMA/SDK/C/LzmaEnc.c:                        RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
LZMA/SDK/C/LzmaEnc.c:                        RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
LZMA/SDK/C/LzmaEnc.c:                        RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
LZMA/SDK/C/LzmaEnc.c:                            p->reps[3] = p->reps[2];
LZMA/SDK/C/LzmaEnc.c:                        p->reps[2] = p->reps[1];
LZMA/SDK/C/LzmaEnc.c:                    p->reps[1] = p->reps[0];
LZMA/SDK/C/LzmaEnc.c:                    p->reps[0] = distance;
LZMA/SDK/C/LzmaEnc.c:                    p->state = kShortRepNextStates[p->state];
LZMA/SDK/C/LzmaEnc.c:                    LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:                    p->state = kRepNextStates[p->state];
LZMA/SDK/C/LzmaEnc.c:                RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
LZMA/SDK/C/LzmaEnc.c:                p->state = kMatchNextStates[p->state];
LZMA/SDK/C/LzmaEnc.c:                LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:                pos -= LZMA_NUM_REPS;
LZMA/SDK/C/LzmaEnc.c:                RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
LZMA/SDK/C/LzmaEnc.c:                    UInt32 footerBits = ((posSlot >> 1) - 1);
LZMA/SDK/C/LzmaEnc.c:                    UInt32 posReduced = pos - base;
LZMA/SDK/C/LzmaEnc.c:                        RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
LZMA/SDK/C/LzmaEnc.c:                        RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
LZMA/SDK/C/LzmaEnc.c:                        RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
LZMA/SDK/C/LzmaEnc.c:                        p->alignPriceCount++;
LZMA/SDK/C/LzmaEnc.c:                p->reps[3] = p->reps[2];
LZMA/SDK/C/LzmaEnc.c:                p->reps[2] = p->reps[1];
LZMA/SDK/C/LzmaEnc.c:                p->reps[1] = p->reps[0];
LZMA/SDK/C/LzmaEnc.c:                p->reps[0] = pos;
LZMA/SDK/C/LzmaEnc.c:                p->matchPriceCount++;
LZMA/SDK/C/LzmaEnc.c:        p->additionalOffset -= len;
LZMA/SDK/C/LzmaEnc.c:        if (p->additionalOffset == 0)
LZMA/SDK/C/LzmaEnc.c:            if (!p->fastMode)
LZMA/SDK/C/LzmaEnc.c:                if (p->matchPriceCount >= (1 << 7))
LZMA/SDK/C/LzmaEnc.c:                if (p->alignPriceCount >= kAlignTableSize)
LZMA/SDK/C/LzmaEnc.c:            if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
LZMA/SDK/C/LzmaEnc.c:            processed = nowPos32 - startPos32;
LZMA/SDK/C/LzmaEnc.c:                    RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
LZMA/SDK/C/LzmaEnc.c:                p->nowPos64 += nowPos32 - startPos32;
LZMA/SDK/C/LzmaEnc.c:    p->nowPos64 += nowPos32 - startPos32;
LZMA/SDK/C/LzmaEnc.c:    if (!RangeEnc_Alloc(&p->rc, alloc))
LZMA/SDK/C/LzmaEnc.c:        Bool btMode = (p->matchFinderBase.btMode != 0);
LZMA/SDK/C/LzmaEnc.c:        p->mtMode = (p->multiThread && !p->fastMode && btMode);
LZMA/SDK/C/LzmaEnc.c:        unsigned lclp = p->lc + p->lp;
LZMA/SDK/C/LzmaEnc.c:        if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
LZMA/SDK/C/LzmaEnc.c:            p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
LZMA/SDK/C/LzmaEnc.c:            p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
LZMA/SDK/C/LzmaEnc.c:            if (p->litProbs == 0 || p->saveState.litProbs == 0)
LZMA/SDK/C/LzmaEnc.c:            p->lclp = lclp;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
LZMA/SDK/C/LzmaEnc.c:    if (beforeSize + p->dictSize < keepWindowSize)
LZMA/SDK/C/LzmaEnc.c:        beforeSize = keepWindowSize - p->dictSize;
LZMA/SDK/C/LzmaEnc.c:    if (p->mtMode)
LZMA/SDK/C/LzmaEnc.c:        RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
LZMA/SDK/C/LzmaEnc.c:        p->matchFinderObj = &p->matchFinderMt;
LZMA/SDK/C/LzmaEnc.c:        MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
LZMA/SDK/C/LzmaEnc.c:        if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
LZMA/SDK/C/LzmaEnc.c:        p->matchFinderObj = &p->matchFinderBase;
LZMA/SDK/C/LzmaEnc.c:        MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
LZMA/SDK/C/LzmaEnc.c:    p->state = 0;
LZMA/SDK/C/LzmaEnc.c:        p->reps[i] = 0;
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_Init(&p->rc);
LZMA/SDK/C/LzmaEnc.c:            p->isMatch[i][j] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:            p->isRep0Long[i][j] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->isRep[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->isRepG0[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->isRepG1[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:        p->isRepG2[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:      UInt32 num = 0x300 << (p->lp + p->lc);
LZMA/SDK/C/LzmaEnc.c:          p->litProbs[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:          CLzmaProb *probs = p->posSlotEncoder[i];
LZMA/SDK/C/LzmaEnc.c:      for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
LZMA/SDK/C/LzmaEnc.c:          p->posEncoders[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:    LenEnc_Init(&p->lenEnc.p);
LZMA/SDK/C/LzmaEnc.c:    LenEnc_Init(&p->repLenEnc.p);
LZMA/SDK/C/LzmaEnc.c:        p->posAlignEncoder[i] = kProbInitValue;
LZMA/SDK/C/LzmaEnc.c:    p->optimumEndIndex = 0;
LZMA/SDK/C/LzmaEnc.c:    p->optimumCurrentIndex = 0;
LZMA/SDK/C/LzmaEnc.c:    p->additionalOffset = 0;
LZMA/SDK/C/LzmaEnc.c:    p->pbMask = (1 << p->pb) - 1;
LZMA/SDK/C/LzmaEnc.c:    p->lpMask = (1 << p->lp) - 1;
LZMA/SDK/C/LzmaEnc.c:    if (!p->fastMode)
LZMA/SDK/C/LzmaEnc.c:    p->lenEnc.tableSize =
LZMA/SDK/C/LzmaEnc.c:        p->repLenEnc.tableSize =
LZMA/SDK/C/LzmaEnc.c:        p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
LZMA/SDK/C/LzmaEnc.c:    LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:    LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
LZMA/SDK/C/LzmaEnc.c:        if (p->dictSize <= ((UInt32)1 << i))
LZMA/SDK/C/LzmaEnc.c:    p->distTableSize = i * 2;
LZMA/SDK/C/LzmaEnc.c:    p->finished = False;
LZMA/SDK/C/LzmaEnc.c:    p->result = SZ_OK;
LZMA/SDK/C/LzmaEnc.c:    p->nowPos64 = 0;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.stream = inStream;
LZMA/SDK/C/LzmaEnc.c:    p->needInit = 1;
LZMA/SDK/C/LzmaEnc.c:    p->rc.outStream = outStream;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.stream = inStream;
LZMA/SDK/C/LzmaEnc.c:    p->needInit = 1;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.directInput = 1;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.bufferBase = (Byte *)src;
LZMA/SDK/C/LzmaEnc.c:    p->matchFinderBase.directInputRem = srcLen;
LZMA/SDK/C/LzmaEnc.c:    p->needInit = 1;
LZMA/SDK/C/LzmaEnc.c:    if (p->mtMode)
LZMA/SDK/C/LzmaEnc.c:        MatchFinderMt_ReleaseStream(&p->matchFinderMt);
LZMA/SDK/C/LzmaEnc.c:    if (p->rem < size)
LZMA/SDK/C/LzmaEnc.c:        size = p->rem;
LZMA/SDK/C/LzmaEnc.c:        p->overflow = True;
LZMA/SDK/C/LzmaEnc.c:    memcpy(p->data, data, size);
LZMA/SDK/C/LzmaEnc.c:    p->rem -= size;
LZMA/SDK/C/LzmaEnc.c:    p->data += size;
LZMA/SDK/C/LzmaEnc.c:    return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
LZMA/SDK/C/LzmaEnc.c:    return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
LZMA/SDK/C/LzmaEnc.c:    p->writeEndMark = False;
LZMA/SDK/C/LzmaEnc.c:    p->finished = False;
LZMA/SDK/C/LzmaEnc.c:    p->result = SZ_OK;
LZMA/SDK/C/LzmaEnc.c:    nowPos64 = p->nowPos64;
LZMA/SDK/C/LzmaEnc.c:    RangeEnc_Init(&p->rc);
LZMA/SDK/C/LzmaEnc.c:    p->rc.outStream = &outStream.funcTable;
LZMA/SDK/C/LzmaEnc.c:    *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
LZMA/SDK/C/LzmaEnc.c:    *destLen -= outStream.rem;
LZMA/SDK/C/LzmaEnc.c:        if (res != SZ_OK || p->finished != 0)
LZMA/SDK/C/LzmaEnc.c:            res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
LZMA/SDK/C/LzmaEnc.c:    UInt32 dictSize = p->dictSize;
LZMA/SDK/C/LzmaEnc.c:    props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
LZMA/SDK/C/LzmaEnc.c:    p->writeEndMark = writeEndMark;
LZMA/SDK/C/LzmaEnc.c:    p->rc.outStream = &outStream.funcTable;
LZMA/SDK/C/LzmaEnc.c:    *destLen -= outStream.rem;
LZMA/SDK/C/LzmaEnc.h:/*  LzmaEnc.h -- LZMA Encoder
LZMA/SDK/C/LzmaEnc.h:2009-02-07 : Igor Pavlov : Public domain */
LZMA/SDK/C/LzmaEnc.h:  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
LZMA/SDK/C/LzmaEnc.h:                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
LZMA/SDK/C/LzmaEnc.h:  int algo;        /* 0 - fast, 1 - normal, default = 1 */
LZMA/SDK/C/LzmaEnc.h:  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
LZMA/SDK/C/LzmaEnc.h:  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
LZMA/SDK/C/LzmaEnc.h:/* ---------- CLzmaEncHandle Interface ---------- */
LZMA/SDK/C/LzmaEnc.h:  SZ_OK           - OK
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_MEM    - Memory allocation error
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_PARAM  - Incorrect paramater in props
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_WRITE  - Write callback error.
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_PROGRESS - some break from progress callback
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
LZMA/SDK/C/LzmaEnc.h:/* ---------- One Call Interface ---------- */
LZMA/SDK/C/LzmaEnc.h:  SZ_OK               - OK
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_MEM        - Memory allocation error
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_PARAM      - Incorrect paramater
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_OUTPUT_EOF - output buffer overflow
LZMA/SDK/C/LzmaEnc.h:  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
LZMA/SDK/C/LzmaDec.c:/* LzmaDec.c -- LZMA Decoder
LZMA/SDK/C/LzmaDec.c:2009-09-20 : Igor Pavlov : Public domain*/
LZMA/SDK/C/LzmaDec.c:#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
LZMA/SDK/C/LzmaDec.c:#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
LZMA/SDK/C/LzmaDec.c:    { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
LZMA/SDK/C/LzmaDec.c:  i -= 0x40; }
LZMA/SDK/C/LzmaDec.c:#define UPDATE_1_CHECK range -= bound; code -= bound;
LZMA/SDK/C/LzmaDec.c:    { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
LZMA/SDK/C/LzmaDec.c:#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
LZMA/SDK/C/LzmaDec.c:#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
LZMA/SDK/C/LzmaDec.c:/* First LZMA-symbol is always decoded.
LZMA/SDK/C/LzmaDec.c:And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is with last normalization
LZMA/SDK/C/LzmaDec.c:SZ_OK - OK
LZMA/SDK/C/LzmaDec.c:SZ_ERROR_DATA - Error
LZMA/SDK/C/LzmaDec.c:p->remainLen:
LZMA/SDK/C/LzmaDec.c:    CLzmaProb *probs = p->probs;
LZMA/SDK/C/LzmaDec.c:    unsigned state = p->state;
LZMA/SDK/C/LzmaDec.c:    UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
LZMA/SDK/C/LzmaDec.c:    unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
LZMA/SDK/C/LzmaDec.c:    unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
LZMA/SDK/C/LzmaDec.c:    unsigned lc = p->prop.lc;
LZMA/SDK/C/LzmaDec.c:    Byte *dic = p->dic;
LZMA/SDK/C/LzmaDec.c:    SizeT dicBufSize = p->dicBufSize;
LZMA/SDK/C/LzmaDec.c:    SizeT dicPos = p->dicPos;
LZMA/SDK/C/LzmaDec.c:    UInt32 processedPos = p->processedPos;
LZMA/SDK/C/LzmaDec.c:    UInt32 checkDicSize = p->checkDicSize;
LZMA/SDK/C/LzmaDec.c:    const Byte *buf = p->buf;
LZMA/SDK/C/LzmaDec.c:    UInt32 range = p->range;
LZMA/SDK/C/LzmaDec.c:    UInt32 code = p->code;
LZMA/SDK/C/LzmaDec.c:                (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
LZMA/SDK/C/LzmaDec.c:                state -= (state < 4) ? state : 3;
LZMA/SDK/C/LzmaDec.c:                unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
LZMA/SDK/C/LzmaDec.c:                state -= (state < 10) ? 3 : 6;
LZMA/SDK/C/LzmaDec.c:            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
LZMA/SDK/C/LzmaDec.c:        ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
LZMA/SDK/C/LzmaDec.c:        int numDirectBits = (int)(((distance >> 1) - 1));
LZMA/SDK/C/LzmaDec.c:            prob = probs + SpecPos + distance - posSlot - 1;
LZMA/SDK/C/LzmaDec.c:                } while (--numDirectBits != 0);
LZMA/SDK/C/LzmaDec.c:            numDirectBits -= kNumAlignBits;
LZMA/SDK/C/LzmaDec.c:                    code -= range;
LZMA/SDK/C/LzmaDec.c:                    t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
LZMA/SDK/C/LzmaDec.c:                code -= range;
LZMA/SDK/C/LzmaDec.c:            } while (--numDirectBits != 0);
LZMA/SDK/C/LzmaDec.c:                state -= kNumStates;
LZMA/SDK/C/LzmaDec.c:    SizeT rem = limit - dicPos;
LZMA/SDK/C/LzmaDec.c:    SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
LZMA/SDK/C/LzmaDec.c:    len -= curLen;
LZMA/SDK/C/LzmaDec.c:        ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
LZMA/SDK/C/LzmaDec.c:        } while (--curLen != 0);
LZMA/SDK/C/LzmaDec.c:    p->buf = buf;
LZMA/SDK/C/LzmaDec.c:    p->range = range;
LZMA/SDK/C/LzmaDec.c:    p->code = code;
LZMA/SDK/C/LzmaDec.c:    p->remainLen = len;
LZMA/SDK/C/LzmaDec.c:    p->dicPos = dicPos;
LZMA/SDK/C/LzmaDec.c:    p->processedPos = processedPos;
LZMA/SDK/C/LzmaDec.c:    p->reps[0] = rep0;
LZMA/SDK/C/LzmaDec.c:    p->reps[1] = rep1;
LZMA/SDK/C/LzmaDec.c:    p->reps[2] = rep2;
LZMA/SDK/C/LzmaDec.c:    p->reps[3] = rep3;
LZMA/SDK/C/LzmaDec.c:    p->state = state;
LZMA/SDK/C/LzmaDec.c:    if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
LZMA/SDK/C/LzmaDec.c:        Byte *dic = p->dic;
LZMA/SDK/C/LzmaDec.c:        SizeT dicPos = p->dicPos;
LZMA/SDK/C/LzmaDec.c:        SizeT dicBufSize = p->dicBufSize;
LZMA/SDK/C/LzmaDec.c:        unsigned len = p->remainLen;
LZMA/SDK/C/LzmaDec.c:        UInt32 rep0 = p->reps[0];
LZMA/SDK/C/LzmaDec.c:        if (limit - dicPos < len)
LZMA/SDK/C/LzmaDec.c:            len = (unsigned)(limit - dicPos);
LZMA/SDK/C/LzmaDec.c:        if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
LZMA/SDK/C/LzmaDec.c:            p->checkDicSize = p->prop.dicSize;
LZMA/SDK/C/LzmaDec.c:        p->processedPos += len;
LZMA/SDK/C/LzmaDec.c:        p->remainLen -= len;
LZMA/SDK/C/LzmaDec.c:        while (len-- != 0)
LZMA/SDK/C/LzmaDec.c:            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
LZMA/SDK/C/LzmaDec.c:        p->dicPos = dicPos;
LZMA/SDK/C/LzmaDec.c:        if (p->checkDicSize == 0)
LZMA/SDK/C/LzmaDec.c:            UInt32 rem = p->prop.dicSize - p->processedPos;
LZMA/SDK/C/LzmaDec.c:            if (limit - p->dicPos > rem)
LZMA/SDK/C/LzmaDec.c:                limit2 = p->dicPos + rem;
LZMA/SDK/C/LzmaDec.c:        if (p->processedPos >= p->prop.dicSize)
LZMA/SDK/C/LzmaDec.c:            p->checkDicSize = p->prop.dicSize;
LZMA/SDK/C/LzmaDec.c:    } while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
LZMA/SDK/C/LzmaDec.c:    if (p->remainLen > kMatchSpecLenStart)
LZMA/SDK/C/LzmaDec.c:        p->remainLen = kMatchSpecLenStart;
LZMA/SDK/C/LzmaDec.c:    UInt32 range = p->range;
LZMA/SDK/C/LzmaDec.c:    UInt32 code = p->code;
LZMA/SDK/C/LzmaDec.c:    CLzmaProb *probs = p->probs;
LZMA/SDK/C/LzmaDec.c:    unsigned state = p->state;
LZMA/SDK/C/LzmaDec.c:        unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
LZMA/SDK/C/LzmaDec.c:                /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
LZMA/SDK/C/LzmaDec.c:            if (p->checkDicSize != 0 || p->processedPos != 0)
LZMA/SDK/C/LzmaDec.c:                ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
LZMA/SDK/C/LzmaDec.c:                (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
LZMA/SDK/C/LzmaDec.c:                unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
LZMA/SDK/C/LzmaDec.c:                    ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
LZMA/SDK/C/LzmaDec.c:        ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
LZMA/SDK/C/LzmaDec.c:        int numDirectBits = ((posSlot >> 1) - 1);
LZMA/SDK/C/LzmaDec.c:        /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
LZMA/SDK/C/LzmaDec.c:            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
LZMA/SDK/C/LzmaDec.c:            numDirectBits -= kNumAlignBits;
LZMA/SDK/C/LzmaDec.c:                code -= range & (((code - range) >> 31) - 1);
LZMA/SDK/C/LzmaDec.c:                /* if (code >= range) code -= range; */
LZMA/SDK/C/LzmaDec.c:            } while (--numDirectBits != 0);
LZMA/SDK/C/LzmaDec.c:              } while (--numDirectBits != 0);
LZMA/SDK/C/LzmaDec.c:    p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
LZMA/SDK/C/LzmaDec.c:    p->range = 0xFFFFFFFF;
LZMA/SDK/C/LzmaDec.c:    p->needFlush = 0;
LZMA/SDK/C/LzmaDec.c:    p->needFlush = 1;
LZMA/SDK/C/LzmaDec.c:    p->remainLen = 0;
LZMA/SDK/C/LzmaDec.c:    p->tempBufSize = 0;
LZMA/SDK/C/LzmaDec.c:        p->processedPos = 0;
LZMA/SDK/C/LzmaDec.c:        p->checkDicSize = 0;
LZMA/SDK/C/LzmaDec.c:        p->needInitState = 1;
LZMA/SDK/C/LzmaDec.c:        p->needInitState = 1;
LZMA/SDK/C/LzmaDec.c:    p->dicPos = 0;
LZMA/SDK/C/LzmaDec.c:    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
LZMA/SDK/C/LzmaDec.c:    CLzmaProb *probs = p->probs;
LZMA/SDK/C/LzmaDec.c:    p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
LZMA/SDK/C/LzmaDec.c:    p->state = 0;
LZMA/SDK/C/LzmaDec.c:    p->needInitState = 0;
LZMA/SDK/C/LzmaDec.c:    while (p->remainLen != kMatchSpecLenStart)
LZMA/SDK/C/LzmaDec.c:        if (p->needFlush != 0)
LZMA/SDK/C/LzmaDec.c:            for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
LZMA/SDK/C/LzmaDec.c:                p->tempBuf[p->tempBufSize++] = *src++;
LZMA/SDK/C/LzmaDec.c:            if (p->tempBufSize < RC_INIT_SIZE)
LZMA/SDK/C/LzmaDec.c:            if (p->tempBuf[0] != 0)
LZMA/SDK/C/LzmaDec.c:            LzmaDec_InitRc(p, p->tempBuf);
LZMA/SDK/C/LzmaDec.c:            p->tempBufSize = 0;
LZMA/SDK/C/LzmaDec.c:        if (p->dicPos >= dicLimit)
LZMA/SDK/C/LzmaDec.c:            if (p->remainLen == 0 && p->code == 0)
LZMA/SDK/C/LzmaDec.c:            if (p->remainLen != 0)
LZMA/SDK/C/LzmaDec.c:        if (p->needInitState)
LZMA/SDK/C/LzmaDec.c:        if (p->tempBufSize == 0)
LZMA/SDK/C/LzmaDec.c:                    memcpy(p->tempBuf, src, inSize);
LZMA/SDK/C/LzmaDec.c:                    p->tempBufSize = (unsigned)inSize;
LZMA/SDK/C/LzmaDec.c:                bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
LZMA/SDK/C/LzmaDec.c:            p->buf = src;
LZMA/SDK/C/LzmaDec.c:            processed = (SizeT)(p->buf - src);
LZMA/SDK/C/LzmaDec.c:            inSize -= processed;
LZMA/SDK/C/LzmaDec.c:            unsigned rem = p->tempBufSize, lookAhead = 0;
LZMA/SDK/C/LzmaDec.c:                p->tempBuf[rem++] = src[lookAhead++];
LZMA/SDK/C/LzmaDec.c:            p->tempBufSize = rem;
LZMA/SDK/C/LzmaDec.c:                int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
LZMA/SDK/C/LzmaDec.c:            p->buf = p->tempBuf;
LZMA/SDK/C/LzmaDec.c:            if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
LZMA/SDK/C/LzmaDec.c:            lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
LZMA/SDK/C/LzmaDec.c:            inSize -= lookAhead;
LZMA/SDK/C/LzmaDec.c:            p->tempBufSize = 0;
LZMA/SDK/C/LzmaDec.c:    if (p->code == 0)
LZMA/SDK/C/LzmaDec.c:    return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
LZMA/SDK/C/LzmaDec.c:        if (p->dicPos == p->dicBufSize)
LZMA/SDK/C/LzmaDec.c:            p->dicPos = 0;
LZMA/SDK/C/LzmaDec.c:        dicPos = p->dicPos;
LZMA/SDK/C/LzmaDec.c:        if (outSize > p->dicBufSize - dicPos)
LZMA/SDK/C/LzmaDec.c:            outSizeCur = p->dicBufSize;
LZMA/SDK/C/LzmaDec.c:        inSize -= inSizeCur;
LZMA/SDK/C/LzmaDec.c:        outSizeCur = p->dicPos - dicPos;
LZMA/SDK/C/LzmaDec.c:        memcpy(dest, p->dic + dicPos, outSizeCur);
LZMA/SDK/C/LzmaDec.c:        outSize -= outSizeCur;
LZMA/SDK/C/LzmaDec.c:    alloc->Free(alloc, p->probs);
LZMA/SDK/C/LzmaDec.c:    p->probs = 0;
LZMA/SDK/C/LzmaDec.c:    alloc->Free(alloc, p->dic);
LZMA/SDK/C/LzmaDec.c:    p->dic = 0;
LZMA/SDK/C/LzmaDec.c:    p->dicSize = dicSize;
LZMA/SDK/C/LzmaDec.c:    p->lc = d % 9;
LZMA/SDK/C/LzmaDec.c:    p->pb = d / 5;
LZMA/SDK/C/LzmaDec.c:    p->lp = d % 5;
LZMA/SDK/C/LzmaDec.c:    if (p->probs == 0 || numProbs != p->numProbs)
LZMA/SDK/C/LzmaDec.c:        p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
LZMA/SDK/C/LzmaDec.c:        p->numProbs = numProbs;
LZMA/SDK/C/LzmaDec.c:        if (p->probs == 0)
LZMA/SDK/C/LzmaDec.c:    p->prop = propNew;
LZMA/SDK/C/LzmaDec.c:    if (p->dic == 0 || dicBufSize != p->dicBufSize)
LZMA/SDK/C/LzmaDec.c:        p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
LZMA/SDK/C/LzmaDec.c:        if (p->dic == 0)
LZMA/SDK/C/LzmaDec.c:    p->dicBufSize = dicBufSize;
LZMA/SDK/C/LzmaDec.c:    p->prop = propNew;
LZMA/SDK/C/Bra.h:/* Bra.h -- Branch converters for executables
LZMA/SDK/C/Bra.h:2009-02-07 : Igor Pavlov : Public domain */
LZMA/SDK/C/Bra.h:    data     - data buffer
LZMA/SDK/C/Bra.h:    size     - size of data
LZMA/SDK/C/Bra.h:    ip       - current virtual Instruction Pinter (IP) value
LZMA/SDK/C/Bra.h:    state    - state variable for x86 converter
LZMA/SDK/C/Bra.h:    encoding - 0 (for decoding), 1 (for encoding)
LZMA/SDK/C/Bra.h:    state    - state variable for x86 converter
LZMA/SDK/C/Bra.h:      size -= processed;
LZMA/SDK/C/CpuArch.h:/* CpuArch.h -- CPU specific code
LZMA/SDK/C/CpuArch.h:2010-10-26: Igor Pavlov : Public domain */
LZMA/SDK/C/CpuArch.h:#define x86cpuid_GetFamily(p) (((p)->ver >> 8) & 0xFF00F)
LZMA/SDK/C/CpuArch.h:#define x86cpuid_GetModel(p) (((p)->ver >> 4) & 0xF00F)
LZMA/SDK/C/CpuArch.h:#define x86cpuid_GetStepping(p) ((p)->ver & 0xF)
LZMA/SDK/C/Bra86.c:/* Bra86.c -- Converter for x86 code (BCJ)
LZMA/SDK/C/Bra86.c:2008-10-04 : Igor Pavlov : Public domain */
LZMA/SDK/C/Bra86.c:  prevPosT = (SizeT)0 - 1;
LZMA/SDK/C/Bra86.c:    Byte *limit = data + size - 4;
LZMA/SDK/C/Bra86.c:    bufferPos = (SizeT)(p - data);
LZMA/SDK/C/Bra86.c:    prevPosT = bufferPos - prevPosT;
LZMA/SDK/C/Bra86.c:      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
LZMA/SDK/C/Bra86.c:        Byte b = p[4 - kMaskToBitNumber[prevMask]];
LZMA/SDK/C/Bra86.c:          dest = src - (ip + (UInt32)bufferPos);
LZMA/SDK/C/Bra86.c:        b = (Byte)(dest >> (24 - index));
LZMA/SDK/C/Bra86.c:        src = dest ^ ((1 << (32 - index)) - 1);
LZMA/SDK/C/Bra86.c:      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
LZMA/SDK/C/Bra86.c:  prevPosT = bufferPos - prevPosT;
LZMA/SDK/C/Bra86.c:  *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
LZMA/SDK/C/LzFind.c:/* LzFind.c -- Match finder for LZ algorithms
LZMA/SDK/C/LzFind.c:2009-04-22 : Igor Pavlov : Public domain */
LZMA/SDK/C/LzFind.c:#define kNormalizeMask (~(kNormalizeStepMin - 1))
LZMA/SDK/C/LzFind.c:    if (!p->directInput)
LZMA/SDK/C/LzFind.c:        alloc->Free(alloc, p->bufferBase);
LZMA/SDK/C/LzFind.c:        p->bufferBase = 0;
LZMA/SDK/C/LzFind.c:    UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
LZMA/SDK/C/LzFind.c:    if (p->directInput)
LZMA/SDK/C/LzFind.c:        p->blockSize = blockSize;
LZMA/SDK/C/LzFind.c:    if (p->bufferBase == 0 || p->blockSize != blockSize)
LZMA/SDK/C/LzFind.c:        p->blockSize = blockSize;
LZMA/SDK/C/LzFind.c:        p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
LZMA/SDK/C/LzFind.c:    return (p->bufferBase != 0);
LZMA/SDK/C/LzFind.c:Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
LZMA/SDK/C/LzFind.c:Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
LZMA/SDK/C/LzFind.c:UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
LZMA/SDK/C/LzFind.c:    p->posLimit -= subValue;
LZMA/SDK/C/LzFind.c:    p->pos -= subValue;
LZMA/SDK/C/LzFind.c:    p->streamPos -= subValue;
LZMA/SDK/C/LzFind.c:    if (p->streamEndWasReached || p->result != SZ_OK)
LZMA/SDK/C/LzFind.c:    if (p->directInput)
LZMA/SDK/C/LzFind.c:        UInt32 curSize = 0xFFFFFFFF - p->streamPos;
LZMA/SDK/C/LzFind.c:        if (curSize > p->directInputRem)
LZMA/SDK/C/LzFind.c:            curSize = (UInt32)p->directInputRem;
LZMA/SDK/C/LzFind.c:        p->directInputRem -= curSize;
LZMA/SDK/C/LzFind.c:        p->streamPos += curSize;
LZMA/SDK/C/LzFind.c:        if (p->directInputRem == 0)
LZMA/SDK/C/LzFind.c:            p->streamEndWasReached = 1;
LZMA/SDK/C/LzFind.c:        Byte *dest = p->buffer + (p->streamPos - p->pos);
LZMA/SDK/C/LzFind.c:        size_t size = (p->bufferBase + p->blockSize - dest);
LZMA/SDK/C/LzFind.c:        p->result = p->stream->Read(p->stream, dest, &size);
LZMA/SDK/C/LzFind.c:        if (p->result != SZ_OK)
LZMA/SDK/C/LzFind.c:            p->streamEndWasReached = 1;
LZMA/SDK/C/LzFind.c:        p->streamPos += (UInt32)size;
LZMA/SDK/C/LzFind.c:        if (p->streamPos - p->pos > p->keepSizeAfter)
LZMA/SDK/C/LzFind.c:    memmove(p->bufferBase,
LZMA/SDK/C/LzFind.c:        p->buffer - p->keepSizeBefore,
LZMA/SDK/C/LzFind.c:        (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
LZMA/SDK/C/LzFind.c:    p->buffer = p->bufferBase + p->keepSizeBefore;
LZMA/SDK/C/LzFind.c:    if (p->directInput)
LZMA/SDK/C/LzFind.c:    /* if (p->streamEndWasReached) return 0; */
LZMA/SDK/C/LzFind.c:    return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
LZMA/SDK/C/LzFind.c:    if (p->streamEndWasReached)
LZMA/SDK/C/LzFind.c:    if (p->keepSizeAfter >= p->streamPos - p->pos)
LZMA/SDK/C/LzFind.c:    p->cutValue = 32;
LZMA/SDK/C/LzFind.c:    p->btMode = 1;
LZMA/SDK/C/LzFind.c:    p->numHashBytes = 4;
LZMA/SDK/C/LzFind.c:    p->bigHash = 0;
LZMA/SDK/C/LzFind.c:    p->bufferBase = 0;
LZMA/SDK/C/LzFind.c:    p->directInput = 0;
LZMA/SDK/C/LzFind.c:    p->hash = 0;
LZMA/SDK/C/LzFind.c:            r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
LZMA/SDK/C/LzFind.c:        p->crc[i] = r;
LZMA/SDK/C/LzFind.c:    alloc->Free(alloc, p->hash);
LZMA/SDK/C/LzFind.c:    p->hash = 0;
LZMA/SDK/C/LzFind.c:    return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
LZMA/SDK/C/LzFind.c:    p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
LZMA/SDK/C/LzFind.c:    p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
LZMA/SDK/C/LzFind.c:        p->matchMaxLen = matchMaxLen;
LZMA/SDK/C/LzFind.c:            p->fixedHashSize = 0;
LZMA/SDK/C/LzFind.c:            if (p->numHashBytes == 2)
LZMA/SDK/C/LzFind.c:                hs = (1 << 16) - 1;
LZMA/SDK/C/LzFind.c:                hs = historySize - 1;
LZMA/SDK/C/LzFind.c:                    if (p->numHashBytes == 3)
LZMA/SDK/C/LzFind.c:                        hs = (1 << 24) - 1;
LZMA/SDK/C/LzFind.c:            p->hashMask = hs;
LZMA/SDK/C/LzFind.c:            if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
LZMA/SDK/C/LzFind.c:            if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
LZMA/SDK/C/LzFind.c:            if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
LZMA/SDK/C/LzFind.c:            hs += p->fixedHashSize;
LZMA/SDK/C/LzFind.c:        UInt32 prevSize = p->hashSizeSum + p->numSons;
LZMA/SDK/C/LzFind.c:        p->historySize = historySize;
LZMA/SDK/C/LzFind.c:        p->hashSizeSum = hs;
LZMA/SDK/C/LzFind.c:        p->cyclicBufferSize = newCyclicBufferSize;
LZMA/SDK/C/LzFind.c:        p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
LZMA/SDK/C/LzFind.c:        newSize = p->hashSizeSum + p->numSons;
LZMA/SDK/C/LzFind.c:        if (p->hash != 0 && prevSize == newSize)
LZMA/SDK/C/LzFind.c:        p->hash = AllocRefs(newSize, alloc);
LZMA/SDK/C/LzFind.c:        if (p->hash != 0)
LZMA/SDK/C/LzFind.c:            p->son = p->hash + p->hashSizeSum;
LZMA/SDK/C/LzFind.c:    UInt32 limit = kMaxValForNormalize - p->pos;
LZMA/SDK/C/LzFind.c:    UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
LZMA/SDK/C/LzFind.c:    limit2 = p->streamPos - p->pos;
LZMA/SDK/C/LzFind.c:    if (limit2 <= p->keepSizeAfter)
LZMA/SDK/C/LzFind.c:        limit2 -= p->keepSizeAfter;
LZMA/SDK/C/LzFind.c:        UInt32 lenLimit = p->streamPos - p->pos;
LZMA/SDK/C/LzFind.c:        if (lenLimit > p->matchMaxLen)
LZMA/SDK/C/LzFind.c:            lenLimit = p->matchMaxLen;
LZMA/SDK/C/LzFind.c:        p->lenLimit = lenLimit;
LZMA/SDK/C/LzFind.c:    p->posLimit = p->pos + limit;
LZMA/SDK/C/LzFind.c:    for (i = 0; i < p->hashSizeSum; i++)
LZMA/SDK/C/LzFind.c:        p->hash[i] = kEmptyHashValue;
LZMA/SDK/C/LzFind.c:    p->cyclicBufferPos = 0;
LZMA/SDK/C/LzFind.c:    p->buffer = p->bufferBase;
LZMA/SDK/C/LzFind.c:    p->pos = p->streamPos = p->cyclicBufferSize;
LZMA/SDK/C/LzFind.c:    p->result = SZ_OK;
LZMA/SDK/C/LzFind.c:    p->streamEndWasReached = 0;
LZMA/SDK/C/LzFind.c:    return (p->pos - p->historySize - 1) & kNormalizeMask;
LZMA/SDK/C/LzFind.c:            value -= subValue;
LZMA/SDK/C/LzFind.c:    MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
LZMA/SDK/C/LzFind.c:    if (p->pos == kMaxValForNormalize)
LZMA/SDK/C/LzFind.c:    if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
LZMA/SDK/C/LzFind.c:    if (p->cyclicBufferPos == p->cyclicBufferSize)
LZMA/SDK/C/LzFind.c:        p->cyclicBufferPos = 0;
LZMA/SDK/C/LzFind.c:        UInt32 delta = pos - curMatch;
LZMA/SDK/C/LzFind.c:        if (cutValue-- == 0 || delta >= _cyclicBufferSize)
LZMA/SDK/C/LzFind.c:            const Byte *pb = cur - delta;
LZMA/SDK/C/LzFind.c:            curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
LZMA/SDK/C/LzFind.c:                    *distances++ = delta - 1;
LZMA/SDK/C/LzFind.c:        UInt32 delta = pos - curMatch;
LZMA/SDK/C/LzFind.c:        if (cutValue-- == 0 || delta >= _cyclicBufferSize)
LZMA/SDK/C/LzFind.c:        CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
LZMA/SDK/C/LzFind.c:        const Byte *pb = cur - delta;
LZMA/SDK/C/LzFind.c:                *distances++ = delta - 1;
LZMA/SDK/C/LzFind.c:        UInt32 delta = pos - curMatch;
LZMA/SDK/C/LzFind.c:        if (cutValue-- == 0 || delta >= _cyclicBufferSize)
LZMA/SDK/C/LzFind.c:        CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
LZMA/SDK/C/LzFind.c:        const Byte *pb = cur - delta;
LZMA/SDK/C/LzFind.c:  ++p->cyclicBufferPos; \
LZMA/SDK/C/LzFind.c:  p->buffer++; \
LZMA/SDK/C/LzFind.c:  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
LZMA/SDK/C/LzFind.c:  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
LZMA/SDK/C/LzFind.c:  cur = p->buffer;
LZMA/SDK/C/LzFind.c:#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
LZMA/SDK/C/LzFind.c:  distances + offset, maxLen) - distances); MOVE_POS_RET;
LZMA/SDK/C/LzFind.c:    curMatch = p->hash[hashValue];
LZMA/SDK/C/LzFind.c:    p->hash[hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    curMatch = p->hash[hashValue];
LZMA/SDK/C/LzFind.c:    p->hash[hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    delta2 = p->pos - p->hash[hash2Value];
LZMA/SDK/C/LzFind.c:    curMatch = p->hash[kFix3HashSize + hashValue];
LZMA/SDK/C/LzFind.c:    p->hash[hash2Value] =
LZMA/SDK/C/LzFind.c:        p->hash[kFix3HashSize + hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
LZMA/SDK/C/LzFind.c:            if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
LZMA/SDK/C/LzFind.c:        distances[1] = delta2 - 1;
LZMA/SDK/C/LzFind.c:    delta2 = p->pos - p->hash[hash2Value];
LZMA/SDK/C/LzFind.c:    delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
LZMA/SDK/C/LzFind.c:    curMatch = p->hash[kFix4HashSize + hashValue];
LZMA/SDK/C/LzFind.c:    p->hash[hash2Value] =
LZMA/SDK/C/LzFind.c:        p->hash[kFix3HashSize + hash3Value] =
LZMA/SDK/C/LzFind.c:        p->hash[kFix4HashSize + hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
LZMA/SDK/C/LzFind.c:        distances[1] = delta2 - 1;
LZMA/SDK/C/LzFind.c:    if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
LZMA/SDK/C/LzFind.c:        distances[offset + 1] = delta3 - 1;
LZMA/SDK/C/LzFind.c:            if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
LZMA/SDK/C/LzFind.c:        distances[offset - 2] = maxLen;
LZMA/SDK/C/LzFind.c:    delta2 = p->pos - p->hash[hash2Value];
LZMA/SDK/C/LzFind.c:    delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
LZMA/SDK/C/LzFind.c:    curMatch = p->hash[kFix4HashSize + hashValue];
LZMA/SDK/C/LzFind.c:    p->hash[hash2Value] =
LZMA/SDK/C/LzFind.c:        p->hash[kFix3HashSize + hash3Value] =
LZMA/SDK/C/LzFind.c:        p->hash[kFix4HashSize + hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
LZMA/SDK/C/LzFind.c:        distances[1] = delta2 - 1;
LZMA/SDK/C/LzFind.c:    if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
LZMA/SDK/C/LzFind.c:        distances[offset + 1] = delta3 - 1;
LZMA/SDK/C/LzFind.c:            if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
LZMA/SDK/C/LzFind.c:        distances[offset - 2] = maxLen;
LZMA/SDK/C/LzFind.c:            p->son[p->cyclicBufferPos] = curMatch;
LZMA/SDK/C/LzFind.c:        distances + offset, maxLen) - (distances));
LZMA/SDK/C/LzFind.c:    curMatch = p->hash[hashValue];
LZMA/SDK/C/LzFind.c:    p->hash[hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:        distances, 2) - (distances));
LZMA/SDK/C/LzFind.c:        curMatch = p->hash[hashValue];
LZMA/SDK/C/LzFind.c:        p->hash[hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    } while (--num != 0);
LZMA/SDK/C/LzFind.c:        curMatch = p->hash[hashValue];
LZMA/SDK/C/LzFind.c:        p->hash[hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    } while (--num != 0);
LZMA/SDK/C/LzFind.c:        curMatch = p->hash[kFix3HashSize + hashValue];
LZMA/SDK/C/LzFind.c:        p->hash[hash2Value] =
LZMA/SDK/C/LzFind.c:            p->hash[kFix3HashSize + hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    } while (--num != 0);
LZMA/SDK/C/LzFind.c:        curMatch = p->hash[kFix4HashSize + hashValue];
LZMA/SDK/C/LzFind.c:        p->hash[hash2Value] =
LZMA/SDK/C/LzFind.c:            p->hash[kFix3HashSize + hash3Value] = p->pos;
LZMA/SDK/C/LzFind.c:        p->hash[kFix4HashSize + hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:    } while (--num != 0);
LZMA/SDK/C/LzFind.c:        curMatch = p->hash[kFix4HashSize + hashValue];
LZMA/SDK/C/LzFind.c:        p->hash[hash2Value] =
LZMA/SDK/C/LzFind.c:            p->hash[kFix3HashSize + hash3Value] =
LZMA/SDK/C/LzFind.c:            p->hash[kFix4HashSize + hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:        p->son[p->cyclicBufferPos] = curMatch;
LZMA/SDK/C/LzFind.c:    } while (--num != 0);
LZMA/SDK/C/LzFind.c:        curMatch = p->hash[hashValue];
LZMA/SDK/C/LzFind.c:        p->hash[hashValue] = p->pos;
LZMA/SDK/C/LzFind.c:        p->son[p->cyclicBufferPos] = curMatch;
LZMA/SDK/C/LzFind.c:    } while (--num != 0);
LZMA/SDK/C/LzFind.c:    vTable->Init = (Mf_Init_Func)MatchFinder_Init;
LZMA/SDK/C/LzFind.c:    vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
LZMA/SDK/C/LzFind.c:    vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
LZMA/SDK/C/LzFind.c:    vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
LZMA/SDK/C/LzFind.c:    if (!p->btMode)
LZMA/SDK/C/LzFind.c:        vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
LZMA/SDK/C/LzFind.c:        vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
LZMA/SDK/C/LzFind.c:    else if (p->numHashBytes == 2)
LZMA/SDK/C/LzFind.c:        vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
LZMA/SDK/C/LzFind.c:        vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
LZMA/SDK/C/LzFind.c:    else if (p->numHashBytes == 3)
LZMA/SDK/C/LzFind.c:        vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
LZMA/SDK/C/LzFind.c:        vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
LZMA/SDK/C/LzFind.c:        vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
LZMA/SDK/C/LzFind.c:        vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
LZMA/LzmaDecompress.c:Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.
LZMA/LzmaDecompress.c:http://opensource.org/licenses/bsd-license.php
LZMA/LzmaDecompress.c:    for (Index = LZMA_PROPS_SIZE + 7; Index >= LZMA_PROPS_SIZE; Index--)
LZMA/LzmaDecompress.c:    EncodedDataSize = (SizeT)(SourceSize - LZMA_HEADER_SIZE);
treeitem.cpp:http://opensource.org/licenses/bsd-license.php
treeitem.cpp:    if (index == -1)
treeitem.cpp:    if (index == -1)
treeitem.cpp:        return parentItem->childItems.indexOf(const_cast<TreeItem*>(this));
treeitem.cpp:            child(i)->setAction(Actions::Insert);
treeitem.cpp:    if (parentItem && parentItem->type() != Types::Root
treeitem.cpp:        && parentItem->action() == Actions::NoAction)
treeitem.cpp:        parentItem->setAction(Actions::Rebuild);
ffs.h:http://opensource.org/licenses/bsd-license.php
ffs.h://14EEBB90-890A-43DB-AED1-5D3C4588A418
ffs.h:// Vendor-specific file system GUIDs
ffs.h:// AD3FFFFF-D28B-44C4-9F13-9EA98A97F9F0 // Intel 1
ffs.h:// D6A1CD70-4B33-4994-A6EA-375F2CCC5437 // Intel 2
ffs.h:// 4F494156-AED6-4D64-A537-B8A5557BCEEC // Sony 1
ffs.h:// Vector of volume GUIDs with FFSv2-compatible files
ffs.h:const QByteArray EFI_FIRMWARE_FILE_SYSTEM3_GUID // 5473C07A-3DCB-4dca-BD6F-1E9689E7349A
ffs.h:// Vector of volume GUIDs with FFSv3-compatible files
ffs.h:// GUIDs of GUID-defined sections
ffs.h:const QByteArray EFI_GUIDED_SECTION_CRC32 // FC1BCDB0-7D31-49AA-936A-A4600D9DD083
ffs.h:const QByteArray EFI_GUIDED_SECTION_TIANO // A31280AD-481E-41B6-95E8-127F4C984779
ffs.h:const QByteArray EFI_GUIDED_SECTION_LZMA // EE4E5898-3914-4259-9D6E-DC7BD79403CF
ffs.h:const QByteArray EFI_GUIDED_SECTION_LZMAF86 //D42AE6BD-1352-4BFB-909A-CA72A6EAE889
ffs.h:const QByteArray EFI_FIRMWARE_CONTENTS_SIGNED_GUID //0F9D89E8-9259-4F76-A5AF-0C89E34023DF
ffs.h:// UEFI Crypto-signed Stuff
searchdialog.cpp:  http://opensource.org/licenses/bsd-license.php
searchdialog.cpp:hexValidator(QRegExp("([0-9a-fA-F\\. ])*")),
searchdialog.cpp:guidValidator(QRegExp("[0-9a-fA-F\\.]{8}-[0-9a-fA-F\\.]{4}-[0-9a-fA-F\\.]{4}-[0-9a-fA-F\\.]{4}-[0-9a-fA-F\\.]{12}"))
searchdialog.cpp:    ui->setupUi(this);
searchdialog.cpp:    ui->hexEdit->setValidator(&hexValidator);
searchdialog.cpp:    ui->guidEdit->setValidator(&guidValidator);
searchdialog.cpp:    connect(ui->tabWidget, SIGNAL(currentChanged(int)), this, SLOT(setEditFocus(int)));
searchdialog.cpp:    setEditFocus(ui->tabWidget->currentIndex());
searchdialog.cpp:        ui->hexEdit->setFocus();
searchdialog.cpp:        ui->guidEdit->setFocus();
searchdialog.cpp:        ui->guidEdit->setCursorPosition(0);
searchdialog.cpp:        ui->textEdit->setFocus();
searchdialog.ui:<?xml version="1.0" encoding="UTF-8"?>
searchdialog.ui:          <string>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</string>
searchdialog.ui:          <string>........-....-....-....-............</string>
unixbuild.sh:  export UPLATFORM="linux_$(uname -m)"
unixbuild.sh:  if [ ! -d /opt/qt56sm ]; then
unixbuild.sh:    curl -L -o /tmp/qt-5.6.3-static-mac.zip https://github.com/distdb/qtbuilds/blob/master/qt-5.6.3-static-mac.zip?raw=true || exit 1
unixbuild.sh:    qtsum=$(shasum -a 256 /tmp/qt-5.6.3-static-mac.zip | cut -f1 -d' ')
unixbuild.sh:    sudo mkdir -p /opt || exit 1
unixbuild.sh:    sudo unzip -q /tmp/qt-5.6.3-static-mac.zip || exit 1
unixbuild.sh:    cd - || exit 1
unixbuild.sh:  pacman -S --noconfirm --needed zip unzip curl perl mingw-w64-i686-toolchain mingw-w64-i686-cmake || exit 1
unixbuild.sh:  if [ ! -d "/c/Qt/5.6/mingw49_32_release_static/" ]; then
unixbuild.sh:    curl -L -o /tmp/qt-5.6.3-static-win32.zip https://github.com/distdb/qtbuilds/blob/master/qt-5.6.3-static-win32.zip?raw=true || exit 1
unixbuild.sh:    qtsum=$(shasum -a 256 /tmp/qt-5.6.3-static-win32.zip | cut -f1 -d' ')
unixbuild.sh:    mkdir -p /c/Qt/5.6 || exit 1
unixbuild.sh:    unzip -q /tmp/qt-5.6.3-static-win32.zip || exit 1
unixbuild.sh:    cd - || exit 1
unixbuild.sh:UEFITOOL_VER=$(cat version.h | grep PROGRAM_VERSION | cut -d'"' -f2)
unixbuild.sh:  if [ "$(echo "$2" | grep '^[0-9]*\.[0-9]*\.[0-9]*$')" != "$2" ]; then
unixbuild.sh:  # -flto is flawed on CI atm
unixbuild.sh:    qmake $3 QMAKE_CXXFLAGS+=-flto QMAKE_LFLAGS+=-flto CONFIG+=optimize_size || exit 1
unixbuild.sh:    qmake $3 QMAKE_CXXFLAGS="-static -flto -Os" QMAKE_LFLAGS="-static -flto -Os" CONFIG+=optimize_size CONFIG+=staticlib CONFIG+=static || exit 1
unixbuild.sh:      strip -x UEFITool.app/Contents/MacOS/UEFITool || exit 1
unixbuild.sh:      zip -qry dist/"${1}_${2}_${UPLATFORM}.zip" UEFITool.app ${4} || exit 1
unixbuild.sh:      strip -x "${1}${BINSUFFIX}" || exit 1
unixbuild.sh:      zip -qry dist/"${1}_${2}_${UPLATFORM}.zip" "${1}${BINSUFFIX}" ${4} || exit 1
unixbuild.sh:    strip -x "${1}${BINSUFFIX}" || exit 1
unixbuild.sh:    zip -qry ../dist/"${1}_${2}_${UPLATFORM}.zip" "${1}${BINSUFFIX}" ${4} || exit 1
unixbuild.sh:    cd - || exit 1
unixbuild.sh:rm -rf dist
unixbuild.sh:mkdir -p dist || exit 1
.qmake.stash:    /usr/include/x86_64-linux-gnu/c++/11 \
.qmake.stash:    /usr/lib/gcc/x86_64-linux-gnu/11/include \
.qmake.stash:    /usr/include/x86_64-linux-gnu \
.qmake.stash:    /usr/lib/gcc/x86_64-linux-gnu/11 \
.qmake.stash:    /usr/lib/x86_64-linux-gnu \
.qmake.stash:    /lib/x86_64-linux-gnu \
ui_searchdialog.h:        if (SearchDialog->objectName().isEmpty())
ui_searchdialog.h:            SearchDialog->setObjectName(QString::fromUtf8("SearchDialog"));
ui_searchdialog.h:        SearchDialog->resize(400, 237);
ui_searchdialog.h:        SearchDialog->setModal(false);
ui_searchdialog.h:        verticalLayout->setObjectName(QString::fromUtf8("verticalLayout"));
ui_searchdialog.h:        tabWidget->setObjectName(QString::fromUtf8("tabWidget"));
ui_searchdialog.h:        hexTab->setObjectName(QString::fromUtf8("hexTab"));
ui_searchdialog.h:        gridLayout_2->setObjectName(QString::fromUtf8("gridLayout_2"));
ui_searchdialog.h:        hexLabel->setObjectName(QString::fromUtf8("hexLabel"));
ui_searchdialog.h:        gridLayout_2->addWidget(hexLabel, 0, 0, 1, 1);
ui_searchdialog.h:        hexEdit->setObjectName(QString::fromUtf8("hexEdit"));
ui_searchdialog.h:        gridLayout_2->addWidget(hexEdit, 0, 1, 1, 1);
ui_searchdialog.h:        hexGroupBox->setObjectName(QString::fromUtf8("hexGroupBox"));
ui_searchdialog.h:        verticalLayout_3->setObjectName(QString::fromUtf8("verticalLayout_3"));
ui_searchdialog.h:        hexScopeFullRadioButton->setObjectName(QString::fromUtf8("hexScopeFullRadioButton"));
ui_searchdialog.h:        hexScopeFullRadioButton->setChecked(true);
ui_searchdialog.h:        verticalLayout_3->addWidget(hexScopeFullRadioButton);
ui_searchdialog.h:        hexScopeHeaderRadioButton->setObjectName(QString::fromUtf8("hexScopeHeaderRadioButton"));
ui_searchdialog.h:        verticalLayout_3->addWidget(hexScopeHeaderRadioButton);
ui_searchdialog.h:        hexScopeBodyRadioButton->setObjectName(QString::fromUtf8("hexScopeBodyRadioButton"));
ui_searchdialog.h:        verticalLayout_3->addWidget(hexScopeBodyRadioButton);
ui_searchdialog.h:        gridLayout_2->addWidget(hexGroupBox, 1, 0, 1, 2);
ui_searchdialog.h:        tabWidget->addTab(hexTab, QString());
ui_searchdialog.h:        guidTab->setObjectName(QString::fromUtf8("guidTab"));
ui_searchdialog.h:        gridLayout->setObjectName(QString::fromUtf8("gridLayout"));
ui_searchdialog.h:        guidLabel->setObjectName(QString::fromUtf8("guidLabel"));
ui_searchdialog.h:        gridLayout->addWidget(guidLabel, 0, 0, 1, 1);
ui_searchdialog.h:        guidEdit->setObjectName(QString::fromUtf8("guidEdit"));
ui_searchdialog.h:        gridLayout->addWidget(guidEdit, 0, 1, 1, 1);
ui_searchdialog.h:        guidGroupBox->setObjectName(QString::fromUtf8("guidGroupBox"));
ui_searchdialog.h:        verticalLayout_5->setObjectName(QString::fromUtf8("verticalLayout_5"));
ui_searchdialog.h:        guidScopeFullRadioButton->setObjectName(QString::fromUtf8("guidScopeFullRadioButton"));
ui_searchdialog.h:        guidScopeFullRadioButton->setChecked(false);
ui_searchdialog.h:        verticalLayout_5->addWidget(guidScopeFullRadioButton);
ui_searchdialog.h:        guidScopeHeaderRadioButton->setObjectName(QString::fromUtf8("guidScopeHeaderRadioButton"));
ui_searchdialog.h:        guidScopeHeaderRadioButton->setChecked(true);
ui_searchdialog.h:        verticalLayout_5->addWidget(guidScopeHeaderRadioButton);
ui_searchdialog.h:        guidScopeBodyRadioButton->setObjectName(QString::fromUtf8("guidScopeBodyRadioButton"));
ui_searchdialog.h:        verticalLayout_5->addWidget(guidScopeBodyRadioButton);
ui_searchdialog.h:        gridLayout->addWidget(guidGroupBox, 1, 0, 1, 2);
ui_searchdialog.h:        tabWidget->addTab(guidTab, QString());
ui_searchdialog.h:        textTab->setObjectName(QString::fromUtf8("textTab"));
ui_searchdialog.h:        gridLayout_3->setObjectName(QString::fromUtf8("gridLayout_3"));
ui_searchdialog.h:        textLabel->setObjectName(QString::fromUtf8("textLabel"));
ui_searchdialog.h:        gridLayout_3->addWidget(textLabel, 0, 0, 1, 1);
ui_searchdialog.h:        textEdit->setObjectName(QString::fromUtf8("textEdit"));
ui_searchdialog.h:        gridLayout_3->addWidget(textEdit, 0, 1, 1, 1);
ui_searchdialog.h:        textGroupBox->setObjectName(QString::fromUtf8("textGroupBox"));
ui_searchdialog.h:        verticalLayout_4->setObjectName(QString::fromUtf8("verticalLayout_4"));
ui_searchdialog.h:        textUnicodeCheckBox->setObjectName(QString::fromUtf8("textUnicodeCheckBox"));
ui_searchdialog.h:        textUnicodeCheckBox->setChecked(true);
ui_searchdialog.h:        verticalLayout_4->addWidget(textUnicodeCheckBox);
ui_searchdialog.h:        textCaseSensitiveCheckBox->setObjectName(QString::fromUtf8("textCaseSensitiveCheckBox"));
ui_searchdialog.h:        verticalLayout_4->addWidget(textCaseSensitiveCheckBox);
ui_searchdialog.h:        gridLayout_3->addWidget(textGroupBox, 1, 0, 1, 2);
ui_searchdialog.h:        tabWidget->addTab(textTab, QString());
ui_searchdialog.h:        verticalLayout->addWidget(tabWidget);
ui_searchdialog.h:        buttonBox->setObjectName(QString::fromUtf8("buttonBox"));
ui_searchdialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_searchdialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Ok);
ui_searchdialog.h:        verticalLayout->addWidget(buttonBox);
ui_searchdialog.h:        tabWidget->setCurrentIndex(0);
ui_searchdialog.h:        SearchDialog->setWindowTitle(QCoreApplication::translate("SearchDialog", "Search", nullptr));
ui_searchdialog.h:        hexLabel->setText(QCoreApplication::translate("SearchDialog", "Hex pattern:", nullptr));
ui_searchdialog.h:        hexEdit->setInputMask(QString());
ui_searchdialog.h:        hexGroupBox->setTitle(QCoreApplication::translate("SearchDialog", "Search scope", nullptr));
ui_searchdialog.h:        hexScopeFullRadioButton->setText(QCoreApplication::translate("SearchDialog", "Header and body", nullptr));
ui_searchdialog.h:        hexScopeHeaderRadioButton->setText(QCoreApplication::translate("SearchDialog", "Header only", nullptr));
ui_searchdialog.h:        hexScopeBodyRadioButton->setText(QCoreApplication::translate("SearchDialog", "Body only", nullptr));
ui_searchdialog.h:        tabWidget->setTabText(tabWidget->indexOf(hexTab), QCoreApplication::translate("SearchDialog", "Hex pattern", nullptr));
ui_searchdialog.h:        guidLabel->setText(QCoreApplication::translate("SearchDialog", "GUID:", nullptr));
ui_searchdialog.h:        guidEdit->setInputMask(QCoreApplication::translate("SearchDialog", "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", nullptr));
ui_searchdialog.h:        guidEdit->setText(QCoreApplication::translate("SearchDialog", "........-....-....-....-............", nullptr));
ui_searchdialog.h:        guidGroupBox->setTitle(QCoreApplication::translate("SearchDialog", "Search scope", nullptr));
ui_searchdialog.h:        guidScopeFullRadioButton->setText(QCoreApplication::translate("SearchDialog", "Header and body", nullptr));
ui_searchdialog.h:        guidScopeHeaderRadioButton->setText(QCoreApplication::translate("SearchDialog", "Header only", nullptr));
ui_searchdialog.h:        guidScopeBodyRadioButton->setText(QCoreApplication::translate("SearchDialog", "Body only", nullptr));
ui_searchdialog.h:        tabWidget->setTabText(tabWidget->indexOf(guidTab), QCoreApplication::translate("SearchDialog", "GUID", nullptr));
ui_searchdialog.h:        textLabel->setText(QCoreApplication::translate("SearchDialog", "Text:", nullptr));
ui_searchdialog.h:        textGroupBox->setTitle(QCoreApplication::translate("SearchDialog", "Text search options", nullptr));
ui_searchdialog.h:        textUnicodeCheckBox->setText(QCoreApplication::translate("SearchDialog", "Unicode", nullptr));
ui_searchdialog.h:        textCaseSensitiveCheckBox->setText(QCoreApplication::translate("SearchDialog", "Case sensitive", nullptr));
ui_searchdialog.h:        tabWidget->setTabText(tabWidget->indexOf(textTab), QCoreApplication::translate("SearchDialog", "Text", nullptr));
treeitem.h:http://opensource.org/licenses/bsd-license.php
Makefile:# Command: /usr/lib/qt5/bin/qmake -o Makefile uefitool.pro CONFIG+=optimize_size
Makefile:DEFINES       = -DQT_NO_DEBUG -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB
Makefile:CFLAGS        = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)
Makefile:CXXFLAGS      = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)
Makefile:INCPATH       = -I. -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtWidgets -I/usr/include/x86_64-linux-gnu/qt5/QtGui -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I. -I. -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++
Makefile:DEL_FILE      = rm -f
Makefile:CHK_DIR_EXISTS= test -d
Makefile:MKDIR         = mkdir -p
Makefile:COPY          = cp -f
Makefile:COPY_FILE     = cp -f
Makefile:COPY_DIR      = cp -f -R
Makefile:INSTALL_FILE  = install -m 644 -p
Makefile:INSTALL_PROGRAM = install -m 755 -p
Makefile:INSTALL_DIR   = cp -f -R
Makefile:QINSTALL      = /usr/lib/qt5/bin/qmake -install qinstall
Makefile:QINSTALL_PROGRAM = /usr/lib/qt5/bin/qmake -install qinstall -exe
Makefile:DEL_FILE      = rm -f
Makefile:SYMLINK       = ln -f -s
Makefile:MOVE          = mv -f
Makefile:TAR           = tar -cf
Makefile:COMPRESS      = gzip -9f
Makefile:DISTDIR = /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/.tmp/UEFITool1.0.0
Makefile:LFLAGS        = -Wl,-O1
Makefile:LIBS          = $(SUBLIBS) /usr/lib/x86_64-linux-gnu/libQt5Widgets.so /usr/lib/x86_64-linux-gnu/libQt5Gui.so /usr/lib/x86_64-linux-gnu/libQt5Core.so -lGL -lpthread   
Makefile:DIST          = /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/opengl.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/uic.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf \
Makefile:	$(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJCOMP) $(LIBS)
Makefile:Makefile: uefitool.pro /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/opengl.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/uic.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf \
Makefile:		/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf \
Makefile:	$(QMAKE) -o Makefile uefitool.pro CONFIG+=optimize_size
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_pre.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/unix.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/linux.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/sanitize.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-base.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/common/g++-unix.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/qconfig.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_Baloo.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_accessibility_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_devicediscovery_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_edid_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_egl_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfs_kms_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eglfsdeviceintegration_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_eventdispatcher_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fb_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_fontdatabase_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_glx_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_input_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_kms_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_linuxaccessibility_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_platformcompositor_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_service_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_theme_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_vulkan_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xcb_qpa_lib_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xkbcommon_support_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_functions.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt_config.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/spec_post.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/toolchain.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_pre.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resolve_config.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/default_post.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/warn_on.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qt.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources_functions.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/resources.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/moc.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/opengl.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/uic.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/unix/thread.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/qmake_use.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/file_copies.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/testcase_targets.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/exceptions.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/yacc.prf:
Makefile:/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/lex.prf:
Makefile:	@$(QMAKE) -o Makefile uefitool.pro CONFIG+=optimize_size
Makefile:	(cd `dirname $(DISTDIR)` && $(TAR) $(DISTNAME).tar $(DISTNAME) && $(COMPRESS) $(DISTNAME).tar) && $(MOVE) `dirname $(DISTDIR)`/$(DISTNAME).tar.gz . && $(DEL_FILE) -r $(DISTDIR)
Makefile:	@test -d $(DISTDIR) || mkdir -p $(DISTDIR)
Makefile:	$(COPY_FILE) --parents $(DIST) $(DISTDIR)/
Makefile:	$(COPY_FILE) --parents /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp $(DISTDIR)/
Makefile:	$(COPY_FILE) --parents uefitool.h searchdialog.h basetypes.h descriptor.h gbe.h me.h ffs.h peimage.h types.h ffsengine.h treeitem.h treemodel.h messagelistitem.h guidlineedit.h version.h LZMA/LzmaCompress.h LZMA/LzmaDecompress.h LZMA/x86Convert.h Tiano/EfiTianoDecompress.h Tiano/EfiTianoCompress.h $(DISTDIR)/
Makefile:	$(COPY_FILE) --parents uefitool_main.cpp uefitool.cpp searchdialog.cpp types.cpp descriptor.cpp ffs.cpp peimage.cpp ffsengine.cpp treeitem.cpp treemodel.cpp messagelistitem.cpp guidlineedit.cpp LZMA/LzmaCompress.c LZMA/LzmaDecompress.c LZMA/SDK/C/LzFind.c LZMA/SDK/C/LzmaDec.c LZMA/SDK/C/LzmaEnc.c LZMA/SDK/C/Bra86.c Tiano/EfiTianoDecompress.c Tiano/EfiTianoCompress.c Tiano/EfiTianoCompressLegacy.c $(DISTDIR)/
Makefile:	$(COPY_FILE) --parents uefitool.ui searchdialog.ui $(DISTDIR)/
Makefile:	-$(DEL_FILE) $(OBJECTS)
Makefile:	-$(DEL_FILE) *~ core *.core
Makefile:	-$(DEL_FILE) $(TARGET) 
Makefile:	-$(DEL_FILE) .qmake.stash
Makefile:	-$(DEL_FILE) Makefile
Makefile:####### Sub-libraries
Makefile:	-$(DEL_FILE) moc_predefs.h
Makefile:moc_predefs.h: /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp
Makefile:	g++ -pipe -Os -Wall -Wextra -dM -E -o moc_predefs.h /usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/dummy.cpp
Makefile:	-$(DEL_FILE) moc_uefitool.cpp moc_searchdialog.cpp moc_ffsengine.cpp moc_treemodel.cpp
Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0 -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtWidgets -I/usr/include/x86_64-linux-gnu/qt5/QtGui -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include uefitool.h -o moc_uefitool.cpp
Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0 -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtWidgets -I/usr/include/x86_64-linux-gnu/qt5/QtGui -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include searchdialog.h -o moc_searchdialog.cpp
Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0 -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtWidgets -I/usr/include/x86_64-linux-gnu/qt5/QtGui -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include ffsengine.h -o moc_ffsengine.cpp
Makefile:	/usr/lib/qt5/bin/moc $(DEFINES) --include /home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0/moc_predefs.h -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -I/home/lstas/code/damn-vulnerable-uefi/UEFITool-0.28.0 -I/usr/include/x86_64-linux-gnu/qt5 -I/usr/include/x86_64-linux-gnu/qt5/QtWidgets -I/usr/include/x86_64-linux-gnu/qt5/QtGui -I/usr/include/x86_64-linux-gnu/qt5/QtCore -I/usr/include/c++/11 -I/usr/include/x86_64-linux-gnu/c++/11 -I/usr/include/c++/11/backward -I/usr/lib/gcc/x86_64-linux-gnu/11/include -I/usr/local/include -I/usr/include/x86_64-linux-gnu -I/usr/include treemodel.h -o moc_treemodel.cpp
Makefile:	-$(DEL_FILE) ui_uefitool.h ui_searchdialog.h
Makefile:	/usr/lib/qt5/bin/uic uefitool.ui -o ui_uefitool.h
Makefile:	/usr/lib/qt5/bin/uic searchdialog.ui -o ui_searchdialog.h
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o uefitool_main.o uefitool_main.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o uefitool.o uefitool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o searchdialog.o searchdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o types.o types.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o descriptor.o descriptor.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o ffs.o ffs.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o peimage.o peimage.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o ffsengine.o ffsengine.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o treeitem.o treeitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o treemodel.o treemodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o messagelistitem.o messagelistitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o guidlineedit.o guidlineedit.cpp
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaCompress.o LZMA/LzmaCompress.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaDecompress.o LZMA/LzmaDecompress.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzFind.o LZMA/SDK/C/LzFind.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaDec.o LZMA/SDK/C/LzmaDec.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o LzmaEnc.o LZMA/SDK/C/LzmaEnc.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o Bra86.o LZMA/SDK/C/Bra86.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoDecompress.o Tiano/EfiTianoDecompress.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoCompress.o Tiano/EfiTianoCompress.c
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o EfiTianoCompressLegacy.o Tiano/EfiTianoCompressLegacy.c
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_uefitool.o moc_uefitool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_searchdialog.o moc_searchdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_ffsengine.o moc_ffsengine.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_treemodel.o moc_treemodel.cpp
Tiano/EfiTianoCompress.c:Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
Tiano/EfiTianoCompress.c:http://opensource.org/licenses/bsd-license.php                                            
Tiano/EfiTianoCompress.c:#define HASH(p, c)        ((p) + ((c) << (WNDBIT - 9)) + WNDSIZ * 2)
Tiano/EfiTianoCompress.c:#define NC                (UINT8_MAX + MAXMATCH + 2 - THRESHOLD)
Tiano/EfiTianoCompress.c:STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],
Tiano/EfiTianoCompress.c:              mCrcTable[UINT8_MAX + 1], mCFreq[2 * NC - 1],mCCode[NC],
Tiano/EfiTianoCompress.c:              mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];
Tiano/EfiTianoCompress.c:  SrcBuffer   - The buffer storing the source data
Tiano/EfiTianoCompress.c:  SrcSize     - The size of source data
Tiano/EfiTianoCompress.c:  DstBuffer   - The buffer to store the compressed data
Tiano/EfiTianoCompress.c:  DstSize     - On input, the size of DstBuffer; On output,
Tiano/EfiTianoCompress.c:  EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. In this case,
Tiano/EfiTianoCompress.c:  EFI_SUCCESS           - Compression is successful.
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:SrcBuffer   - The buffer storing the source data
Tiano/EfiTianoCompress.c:SrcSize     - The size of source data
Tiano/EfiTianoCompress.c:DstBuffer   - The buffer to store the compressed data
Tiano/EfiTianoCompress.c:DstSize     - On input, the size of DstBuffer; On output,
Tiano/EfiTianoCompress.c:EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. In this case,
Tiano/EfiTianoCompress.c:EFI_SUCCESS           - Compression is successful.
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  Data    - the dword to put
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  EFI_SUCCESS           - Memory is allocated successfully
Tiano/EfiTianoCompress.c:  EFI_OUT_OF_RESOURCES  - Allocation fails
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  for (i = 1; i < (NODE)(WNDSIZ - 1); i++) {
Tiano/EfiTianoCompress.c:  mNext[WNDSIZ - 1] = NIL;
Tiano/EfiTianoCompress.c:  q       - the parent node
Tiano/EfiTianoCompress.c:  c       - the edge character
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  q       - the parent node
Tiano/EfiTianoCompress.c:  c       - the edge character
Tiano/EfiTianoCompress.c:  r       - the child node
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  Old     - the node to split
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:    mMatchLen--;
Tiano/EfiTianoCompress.c:      mMatchPos -= WNDSIZ;
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  if (r >= (NODE)WNDSIZ || --mChildCount[r] > 1) {
Tiano/EfiTianoCompress.c:    t -= WNDSIZ;
Tiano/EfiTianoCompress.c:      u -= WNDSIZ;
Tiano/EfiTianoCompress.c:      u -= WNDSIZ;
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  mRemainder--;
Tiano/EfiTianoCompress.c:  EFI_SUCCESS           - The compression is successful
Tiano/EfiTianoCompress.c:  EFI_OUT_0F_RESOURCES  - Not enough memory for compression process
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:      Output(mText[mPos - 1], 0);
Tiano/EfiTianoCompress.c:      Output(LastMatchLen + (UINT8_MAX + 1 - THRESHOLD),
Tiano/EfiTianoCompress.c:             (mPos - LastMatchPos - 2) & (WNDSIZ - 1));
Tiano/EfiTianoCompress.c:      while (--LastMatchLen > 0) {
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  while (n > 0 && mCLen[n - 1] == 0) {
Tiano/EfiTianoCompress.c:    n--;
Tiano/EfiTianoCompress.c:  n       - the number of symbols
Tiano/EfiTianoCompress.c:  nbit    - the number of bits needed to represent 'n'
Tiano/EfiTianoCompress.c:  Special - the special symbol that needs to be take care of
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  while (n > 0 && mPTLen[n - 1] == 0) {
Tiano/EfiTianoCompress.c:    n--;
Tiano/EfiTianoCompress.c:      PutBits(k - 3, (1U << (k - 3)) - 2);
Tiano/EfiTianoCompress.c:      PutBits(2, (i - 3) & 3);
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  while (n > 0 && mCLen[n - 1] == 0) {
Tiano/EfiTianoCompress.c:    n--;
Tiano/EfiTianoCompress.c:        PutBits(4, Count - 3);
Tiano/EfiTianoCompress.c:        PutBits(CBIT, Count - 20);
Tiano/EfiTianoCompress.c:    PutBits(c - 1, p & (0xFFFFU >> (17 - c)));
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:    WritePTLen(NP, gPBIT, -1);
Tiano/EfiTianoCompress.c:    if (Flags & (1U << (UINT8_BIT - 1))) {
Tiano/EfiTianoCompress.c:  c     - The original character or the 'String Length' element of a Pointer
Tiano/EfiTianoCompress.c:  p     - The 'Position' field of a Pointer
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:    mOutputMask = 1U << (UINT8_BIT - 1);
Tiano/EfiTianoCompress.c:    if (mOutputPos >= mBufSiz - 3 * UINT8_BIT) {
Tiano/EfiTianoCompress.c:  PutBits(UINT8_BIT - 1, 0);
Tiano/EfiTianoCompress.c:  n   - the rightmost n bits of the data is used
Tiano/EfiTianoCompress.c:  x   - the data 
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:    mSubBitBuf |= x << (mBitCount -= n);
Tiano/EfiTianoCompress.c:    Temp = (UINT8)(mSubBitBuf | (x >> (n -= mBitCount)));
Tiano/EfiTianoCompress.c:      mSubBitBuf = x << (mBitCount = UINT8_BIT - n);
Tiano/EfiTianoCompress.c:      Temp = (UINT8)(x >> (n - UINT8_BIT));
Tiano/EfiTianoCompress.c:      mSubBitBuf = x << (mBitCount = 2 * UINT8_BIT - n);
Tiano/EfiTianoCompress.c:  p   - the buffer to hold the data
Tiano/EfiTianoCompress.c:  n   - number of bytes to read
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  p -= n;
Tiano/EfiTianoCompress.c:  while (--i >= 0) {
Tiano/EfiTianoCompress.c:  i   - the top node
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:    Depth--;
Tiano/EfiTianoCompress.c:  Root   - the root of the tree
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  for (i = 16; i > 0; i--) {
Tiano/EfiTianoCompress.c:    Cum += mLenCnt[i] << (16 - i);
Tiano/EfiTianoCompress.c:    mLenCnt[16]--;
Tiano/EfiTianoCompress.c:    for (i = 15; i > 0; i--) {
Tiano/EfiTianoCompress.c:        mLenCnt[i]--;
Tiano/EfiTianoCompress.c:    Cum--;
Tiano/EfiTianoCompress.c:  for (i = 16; i > 0; i--) {
Tiano/EfiTianoCompress.c:    while (--k >= 0) {
Tiano/EfiTianoCompress.c:  // priority queue: send i-th entry down heap
Tiano/EfiTianoCompress.c:  n     - number of symbols
Tiano/EfiTianoCompress.c:  Len   - the code length array
Tiano/EfiTianoCompress.c:  Code  - stores codes for each symbol
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  NParm    - number of symbols
Tiano/EfiTianoCompress.c:  FreqParm - frequency of each symbol
Tiano/EfiTianoCompress.c:  LenParm  - code length for each symbol
Tiano/EfiTianoCompress.c:  CodeParm - code for each symbol
Tiano/EfiTianoCompress.c:--*/
Tiano/EfiTianoCompress.c:  for (i = mHeapSize / 2; i >= 1; i--) {
Tiano/EfiTianoCompress.c:    mHeap[1] = mHeap[mHeapSize--];
Tiano/EfiTianoDecompress.h:Copyright (c) 2004 - 2008, Intel Corporation. All rights reserved.<BR>
Tiano/EfiTianoDecompress.h:http://opensource.org/licenses/bsd-license.php
Tiano/EfiTianoDecompress.h:--*/
Tiano/EfiTianoDecompress.h:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.h:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.h:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.h:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.h:EFI_SUCCESS           - The size of destination buffer and the size of scratch buffer are successfully retrieved.
Tiano/EfiTianoDecompress.h:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.h:--*/
Tiano/EfiTianoDecompress.h:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.h:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.h:Destination - The destination buffer to store the decompressed data
Tiano/EfiTianoDecompress.h:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.h:Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
Tiano/EfiTianoDecompress.h:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.h:EFI_SUCCESS           - Decompression is successful
Tiano/EfiTianoDecompress.h:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.h:--*/
Tiano/EfiTianoDecompress.h:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.h:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.h:Destination - The destination buffer to store the decompressed data
Tiano/EfiTianoDecompress.h:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.h:Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
Tiano/EfiTianoDecompress.h:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.h:EFI_SUCCESS           - Decompression is successful
Tiano/EfiTianoDecompress.h:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.h:--*/
Tiano/EfiTianoCompressLegacy.c:Copyright (c) 2006 - 2008, Intel Corporation
Tiano/EfiTianoCompressLegacy.c:http://opensource.org/licenses/bsd-license.php
Tiano/EfiTianoCompressLegacy.c:#define HASH(p, c)    ((p) + ((c) << (WNDBIT - 9)) + WNDSIZ * 2)
Tiano/EfiTianoCompressLegacy.c:#define NC    (UINT8_MAX + MAXMATCH + 2 - THRESHOLD)
Tiano/EfiTianoCompressLegacy.c:STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],
Tiano/EfiTianoCompressLegacy.c:  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];
Tiano/EfiTianoCompressLegacy.c:SrcBuffer   - The buffer storing the source data
Tiano/EfiTianoCompressLegacy.c:SrcSize     - The size of source data
Tiano/EfiTianoCompressLegacy.c:DstBuffer   - The buffer to store the compressed data
Tiano/EfiTianoCompressLegacy.c:DstSize     - On input, the size of DstBuffer; On output,
Tiano/EfiTianoCompressLegacy.c:EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
Tiano/EfiTianoCompressLegacy.c:EFI_SUCCESS           - Compression is successful.
Tiano/EfiTianoCompressLegacy.c:EFI_OUT_OF_RESOURCES  - No resource to complete function.
Tiano/EfiTianoCompressLegacy.c:EFI_INVALID_PARAMETER - Parameter supplied is wrong.
Tiano/EfiTianoCompressLegacy.c:--*/
Tiano/EfiTianoCompressLegacy.c:  SrcBuffer   - The buffer storing the source data
Tiano/EfiTianoCompressLegacy.c:  SrcSize     - The size of source data
Tiano/EfiTianoCompressLegacy.c:  DstBuffer   - The buffer to store the compressed data
Tiano/EfiTianoCompressLegacy.c:  DstSize     - On input, the size of DstBuffer; On output,
Tiano/EfiTianoCompressLegacy.c:  Version     - The version of de/compression algorithm.
Tiano/EfiTianoCompressLegacy.c:  EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
Tiano/EfiTianoCompressLegacy.c:  EFI_SUCCESS           - Compression is successful.
Tiano/EfiTianoCompressLegacy.c:  EFI_OUT_OF_RESOURCES  - No resource to complete function.
Tiano/EfiTianoCompressLegacy.c:  EFI_INVALID_PARAMETER - Parameter supplied is wrong.
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  Data    - the DWORD to put
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  EFI_SUCCESS           - Memory is allocated successfully
Tiano/EfiTianoCompressLegacy.c:  EFI_OUT_OF_RESOURCES  - Allocation fails
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:    for (Index = 1; Index < (NODE) WNDSIZ - 1; Index++) {
Tiano/EfiTianoCompressLegacy.c:  mNext[WNDSIZ - 1] = NIL;
Tiano/EfiTianoCompressLegacy.c:  NodeQ       - the parent node
Tiano/EfiTianoCompressLegacy.c:  CharC       - the edge character
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  Parent       - the parent node
Tiano/EfiTianoCompressLegacy.c:  CharC   - the edge character
Tiano/EfiTianoCompressLegacy.c:  Child       - the child node
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  Old     - the node to split
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:    mMatchLen--;
Tiano/EfiTianoCompressLegacy.c:      mMatchPos -= WNDSIZ;
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  mChildCount[NodeR]--;
Tiano/EfiTianoCompressLegacy.c:    NodeT -= WNDSIZ;
Tiano/EfiTianoCompressLegacy.c:      NodeU -= WNDSIZ;
Tiano/EfiTianoCompressLegacy.c:      NodeU -= WNDSIZ;
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  mRemainder--;
Tiano/EfiTianoCompressLegacy.c:  EFI_SUCCESS           - The compression is successful
Tiano/EfiTianoCompressLegacy.c:  EFI_OUT_0F_RESOURCES  - Not enough memory for compression process
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:      Output (mText[mPos - 1], 0);
Tiano/EfiTianoCompressLegacy.c:        if (((mPos - LastMatchPos - 2) & (WNDSIZ - 1)) > (1U << 11)) {
Tiano/EfiTianoCompressLegacy.c:          Output (mText[mPos - 1], 0);
Tiano/EfiTianoCompressLegacy.c:        LastMatchLen + (UINT8_MAX + 1 - THRESHOLD),
Tiano/EfiTianoCompressLegacy.c:        (mPos - LastMatchPos - 2) & (WNDSIZ - 1)
Tiano/EfiTianoCompressLegacy.c:      LastMatchLen--;
Tiano/EfiTianoCompressLegacy.c:        LastMatchLen--;
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  while (Number > 0 && mCLen[Number - 1] == 0) {
Tiano/EfiTianoCompressLegacy.c:    Number--;
Tiano/EfiTianoCompressLegacy.c:  Number       - the number of symbols
Tiano/EfiTianoCompressLegacy.c:  nbit    - the number of bits needed to represent 'n'
Tiano/EfiTianoCompressLegacy.c:  Special - the special symbol that needs to be take care of
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  while (Number > 0 && mPTLen[Number - 1] == 0) {
Tiano/EfiTianoCompressLegacy.c:    Number--;
Tiano/EfiTianoCompressLegacy.c:      PutBits (Index3 - 3, (1U << (Index3 - 3)) - 2);
Tiano/EfiTianoCompressLegacy.c:      PutBits (2, (Index - 3) & 3);
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  while (Number > 0 && mCLen[Number - 1] == 0) {
Tiano/EfiTianoCompressLegacy.c:    Number--;
Tiano/EfiTianoCompressLegacy.c:        PutBits (4, Count - 3);
Tiano/EfiTianoCompressLegacy.c:        PutBits (CBIT, Count - 20);
Tiano/EfiTianoCompressLegacy.c:    PutBits (Index - 1, Value & (0xFFFFFFFFU >> (32 - Index + 1)));
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:    WritePTLen (NP, mPbit, -1);
Tiano/EfiTianoCompressLegacy.c:    if (Flags & (1U << (UINT8_BIT - 1))) {
Tiano/EfiTianoCompressLegacy.c:  CharC     - The original character or the 'String Length' element of a Pointer
Tiano/EfiTianoCompressLegacy.c:  Pos     - The 'Position' field of a Pointer
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:    mOutputMask = 1U << (UINT8_BIT - 1);
Tiano/EfiTianoCompressLegacy.c:    if (mOutputPos >= mBufSiz - 5 * UINT8_BIT) {
Tiano/EfiTianoCompressLegacy.c:  PutBits (UINT8_BIT - 1, 0);
Tiano/EfiTianoCompressLegacy.c:  Number   - the rightmost n bits of the data is used
Tiano/EfiTianoCompressLegacy.c:  x   - the data
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:    // Number -= mBitCount should never equal to 32
Tiano/EfiTianoCompressLegacy.c:    Temp = (UINT8) (mSubBitBuf | (Value >> (Number -= mBitCount)));
Tiano/EfiTianoCompressLegacy.c:  mSubBitBuf |= Value << (mBitCount -= Number);
Tiano/EfiTianoCompressLegacy.c:  Pointer   - the buffer to hold the data
Tiano/EfiTianoCompressLegacy.c:  Number   - number of bytes to read
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  Pointer -= Number;
Tiano/EfiTianoCompressLegacy.c:  Index--;
Tiano/EfiTianoCompressLegacy.c:    Index--;
Tiano/EfiTianoCompressLegacy.c:  Index   - the top node
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:    Depth--;
Tiano/EfiTianoCompressLegacy.c:  Root   - the root of the tree
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  for (Index = 16; Index > 0; Index--) {
Tiano/EfiTianoCompressLegacy.c:    Cum += mLenCnt[Index] << (16 - Index);
Tiano/EfiTianoCompressLegacy.c:    mLenCnt[16]--;
Tiano/EfiTianoCompressLegacy.c:    for (Index = 15; Index > 0; Index--) {
Tiano/EfiTianoCompressLegacy.c:        mLenCnt[Index]--;
Tiano/EfiTianoCompressLegacy.c:    Cum--;
Tiano/EfiTianoCompressLegacy.c:  for (Index = 16; Index > 0; Index--) {
Tiano/EfiTianoCompressLegacy.c:    Index3--;
Tiano/EfiTianoCompressLegacy.c:      Index3--;
Tiano/EfiTianoCompressLegacy.c:  // priority queue: send Index-th entry down heap
Tiano/EfiTianoCompressLegacy.c:  Number     - number of symbols
Tiano/EfiTianoCompressLegacy.c:  Len   - the code length array
Tiano/EfiTianoCompressLegacy.c:  Code  - stores codes for each symbol
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  NParm    - number of symbols
Tiano/EfiTianoCompressLegacy.c:  FreqParm - frequency of each symbol
Tiano/EfiTianoCompressLegacy.c:  LenParm  - code length for each symbol
Tiano/EfiTianoCompressLegacy.c:  CodeParm - code for each symbol
Tiano/EfiTianoCompressLegacy.c:  --*/
Tiano/EfiTianoCompressLegacy.c:  for (Index = mHeapSize / 2; Index >= 1; Index--) {
Tiano/EfiTianoCompressLegacy.c:    mHeap[1] = mHeap[mHeapSize--];
Tiano/EfiTianoDecompress.c:Copyright (c) 2004 - 2010, Intel Corporation. All rights reserved.<BR>
Tiano/EfiTianoDecompress.c:http://opensource.org/licenses/bsd-license.php
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:#define BAD_TABLE - 1
Tiano/EfiTianoDecompress.c:#define NC      (0xff + MAXMATCH + 2 - THRESHOLD)
Tiano/EfiTianoDecompress.c:#define MAXNP   ((1U << MAXPBIT) - 1)
Tiano/EfiTianoDecompress.c:    UINT16  mLeft[2 * NC - 1];
Tiano/EfiTianoDecompress.c:    UINT16  mRight[2 * NC - 1];
Tiano/EfiTianoDecompress.c:Sd        - The global scratch data
Tiano/EfiTianoDecompress.c:NumOfBits  - The number of bits to shift and read.
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:    Sd->mBitBuf = (UINT32) (((UINT64)Sd->mBitBuf) << NumOfBits);
Tiano/EfiTianoDecompress.c:    while (NumOfBits > Sd->mBitCount) {
Tiano/EfiTianoDecompress.c:        Sd->mBitBuf |= (UINT32) (((UINT64)Sd->mSubBitBuf) << (NumOfBits = (UINT16) (NumOfBits - Sd->mBitCount)));
Tiano/EfiTianoDecompress.c:        if (Sd->mCompSize > 0) {
Tiano/EfiTianoDecompress.c:            Sd->mCompSize--;
Tiano/EfiTianoDecompress.c:            Sd->mSubBitBuf = 0;
Tiano/EfiTianoDecompress.c:            Sd->mSubBitBuf = Sd->mSrcBase[Sd->mInBuf++];
Tiano/EfiTianoDecompress.c:            Sd->mBitCount = 8;
Tiano/EfiTianoDecompress.c:            Sd->mSubBitBuf = 0;
Tiano/EfiTianoDecompress.c:            Sd->mBitCount = 8;
Tiano/EfiTianoDecompress.c:    Sd->mBitCount = (UINT16)(Sd->mBitCount - NumOfBits);
Tiano/EfiTianoDecompress.c:    Sd->mBitBuf |= Sd->mSubBitBuf >> Sd->mBitCount;
Tiano/EfiTianoDecompress.c:Sd            - The global scratch data.
Tiano/EfiTianoDecompress.c:NumOfBits     - The number of bits to pop and read.
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:    OutBits = (UINT32)(Sd->mBitBuf >> (BITBUFSIZ - NumOfBits));
Tiano/EfiTianoDecompress.c:Sd        - The global scratch data
Tiano/EfiTianoDecompress.c:NumOfChar - Number of symbols in the symbol set
Tiano/EfiTianoDecompress.c:BitLen    - Code length array
Tiano/EfiTianoDecompress.c:TableBits - The width of the mapping table
Tiano/EfiTianoDecompress.c:Table     - The table
Tiano/EfiTianoDecompress.c:0         - OK.
Tiano/EfiTianoDecompress.c:BAD_TABLE - The table is corrupted.
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:        Start[Index + 1] = (UINT16)(Start[Index] + (Count[Index] << (16 - Index)));
Tiano/EfiTianoDecompress.c:    JuBits = (UINT16)(16 - TableBits);
Tiano/EfiTianoDecompress.c:        Weight[Index] = (UINT16)(1U << (TableBits - Index));
Tiano/EfiTianoDecompress.c:        Weight[Index] = (UINT16)(1U << (16 - Index));
Tiano/EfiTianoDecompress.c:    Mask = (UINT16)(1U << (15 - TableBits));
Tiano/EfiTianoDecompress.c:            Index = (UINT16)(Len - TableBits);
Tiano/EfiTianoDecompress.c:                if ((*Pointer == 0) && (Avail < sizeof(Sd->mRight) / sizeof(UINT16)) && (Avail < sizeof(Sd->mLeft) / sizeof(UINT16))) {
Tiano/EfiTianoDecompress.c:                    Sd->mRight[Avail] = Sd->mLeft[Avail] = 0;
Tiano/EfiTianoDecompress.c:                if ((Index3 & Mask) && (*Pointer < (sizeof(Sd->mRight) / sizeof(UINT16)))) {
Tiano/EfiTianoDecompress.c:                    Pointer = &Sd->mRight[*Pointer];
Tiano/EfiTianoDecompress.c:                else if (*Pointer < (sizeof(Sd->mLeft) / sizeof(UINT16))) {
Tiano/EfiTianoDecompress.c:                    Pointer = &Sd->mLeft[*Pointer];
Tiano/EfiTianoDecompress.c:                Index--;
Tiano/EfiTianoDecompress.c:Sd      - the global scratch data
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:    Val = Sd->mPTTable[Sd->mBitBuf >> (BITBUFSIZ - 8)];
Tiano/EfiTianoDecompress.c:        Mask = 1U << (BITBUFSIZ - 1 - 8);
Tiano/EfiTianoDecompress.c:            if (Sd->mBitBuf & Mask) {
Tiano/EfiTianoDecompress.c:                Val = Sd->mRight[Val];
Tiano/EfiTianoDecompress.c:                Val = Sd->mLeft[Val];
Tiano/EfiTianoDecompress.c:    FillBuf(Sd, Sd->mPTLen[Val]);
Tiano/EfiTianoDecompress.c:        Pos = (UINT32)((1U << (Val - 1)) + GetBits(Sd, (UINT16)(Val - 1)));
Tiano/EfiTianoDecompress.c:Sd        - The global scratch data
Tiano/EfiTianoDecompress.c:nn        - Number of symbols
Tiano/EfiTianoDecompress.c:nbit      - Number of bits needed to represent nn
Tiano/EfiTianoDecompress.c:Special   - The special symbol that needs to be taken care of
Tiano/EfiTianoDecompress.c:0         - OK.
Tiano/EfiTianoDecompress.c:BAD_TABLE - Table is corrupted.
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:    if ((Number > sizeof(Sd->mPTLen)) || (nn > sizeof(Sd->mPTLen))) {
Tiano/EfiTianoDecompress.c:            Sd->mPTTable[Index] = CharC;
Tiano/EfiTianoDecompress.c:            Sd->mPTLen[Index] = 0;
Tiano/EfiTianoDecompress.c:        CharC = (UINT16)(Sd->mBitBuf >> (BITBUFSIZ - 3));
Tiano/EfiTianoDecompress.c:            Mask = 1U << (BITBUFSIZ - 1 - 3);
Tiano/EfiTianoDecompress.c:            while (Mask & Sd->mBitBuf) {
Tiano/EfiTianoDecompress.c:        FillBuf(Sd, (UINT16)((CharC < 7) ? 3 : CharC - 3));
Tiano/EfiTianoDecompress.c:        Sd->mPTLen[Index++] = (UINT8)CharC;
Tiano/EfiTianoDecompress.c:            while ((INT16)(--CharC) >= 0) {
Tiano/EfiTianoDecompress.c:                if (Index >= sizeof(Sd->mPTLen)) {
Tiano/EfiTianoDecompress.c:                Sd->mPTLen[Index++] = 0;
Tiano/EfiTianoDecompress.c:        Sd->mPTLen[Index++] = 0;
Tiano/EfiTianoDecompress.c:    return MakeTable(Sd, nn, Sd->mPTLen, 8, Sd->mPTTable);
Tiano/EfiTianoDecompress.c:Sd    - the global scratch data
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:            Sd->mCLen[Index] = 0;
Tiano/EfiTianoDecompress.c:            Sd->mCTable[Index] = CharC;
Tiano/EfiTianoDecompress.c:        CharC = Sd->mPTTable[Sd->mBitBuf >> (BITBUFSIZ - 8)];
Tiano/EfiTianoDecompress.c:            Mask = 1U << (BITBUFSIZ - 1 - 8);
Tiano/EfiTianoDecompress.c:                if (Mask & Sd->mBitBuf) {
Tiano/EfiTianoDecompress.c:                    CharC = Sd->mRight[CharC];
Tiano/EfiTianoDecompress.c:                    CharC = Sd->mLeft[CharC];
Tiano/EfiTianoDecompress.c:        FillBuf(Sd, Sd->mPTLen[CharC]);
Tiano/EfiTianoDecompress.c:            while ((INT16)(--CharC) >= 0) {
Tiano/EfiTianoDecompress.c:                Sd->mCLen[Index++] = 0;
Tiano/EfiTianoDecompress.c:            Sd->mCLen[Index++] = (UINT8)(CharC - 2);
Tiano/EfiTianoDecompress.c:        Sd->mCLen[Index++] = 0;
Tiano/EfiTianoDecompress.c:    MakeTable(Sd, NC, Sd->mCLen, 12, Sd->mCTable);
Tiano/EfiTianoDecompress.c:Sd    - The global scratch data.
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:    if (Sd->mBlockSize == 0) {
Tiano/EfiTianoDecompress.c:        Sd->mBlockSize = (UINT16)GetBits(Sd, 16);
Tiano/EfiTianoDecompress.c:        Sd->mBadTableFlag = ReadPTLen(Sd, NT, TBIT, 3);
Tiano/EfiTianoDecompress.c:        if (Sd->mBadTableFlag != 0) {
Tiano/EfiTianoDecompress.c:        Sd->mBadTableFlag = ReadPTLen(Sd, MAXNP, Sd->mPBit, (UINT16)(-1));
Tiano/EfiTianoDecompress.c:        if (Sd->mBadTableFlag != 0) {
Tiano/EfiTianoDecompress.c:    Sd->mBlockSize--;
Tiano/EfiTianoDecompress.c:    Index2 = Sd->mCTable[Sd->mBitBuf >> (BITBUFSIZ - 12)];
Tiano/EfiTianoDecompress.c:        Mask = 1U << (BITBUFSIZ - 1 - 12);
Tiano/EfiTianoDecompress.c:            if (Sd->mBitBuf & Mask) {
Tiano/EfiTianoDecompress.c:                Index2 = Sd->mRight[Index2];
Tiano/EfiTianoDecompress.c:                Index2 = Sd->mLeft[Index2];
Tiano/EfiTianoDecompress.c:    FillBuf(Sd, Sd->mCLen[Index2]);
Tiano/EfiTianoDecompress.c:Sd            - The global scratch data
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:    BytesRemain = (UINT16)(-1);
Tiano/EfiTianoDecompress.c:        if (Sd->mBadTableFlag != 0) {
Tiano/EfiTianoDecompress.c:            if (Sd->mOutBuf >= Sd->mOrigSize) {
Tiano/EfiTianoDecompress.c:                Sd->mDstBase[Sd->mOutBuf++] = (UINT8)CharC;
Tiano/EfiTianoDecompress.c:            CharC = (UINT16)(CharC - (UINT8_MAX + 1 - THRESHOLD));
Tiano/EfiTianoDecompress.c:            DataIdx = Sd->mOutBuf - DecodeP(Sd) - 1;
Tiano/EfiTianoDecompress.c:            if (DataIdx >= Sd->mOrigSize - BytesRemain) {
Tiano/EfiTianoDecompress.c:                Sd->mBadTableFlag = 1;
Tiano/EfiTianoDecompress.c:            BytesRemain--;
Tiano/EfiTianoDecompress.c:                Sd->mDstBase[Sd->mOutBuf++] = Sd->mDstBase[DataIdx++];
Tiano/EfiTianoDecompress.c:                if (Sd->mOutBuf >= Sd->mOrigSize) {
Tiano/EfiTianoDecompress.c:                BytesRemain--;
Tiano/EfiTianoDecompress.c:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.c:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.c:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.c:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.c:EFI_SUCCESS           - The size of destination buffer and the size of scratch buffer are successull retrieved.
Tiano/EfiTianoDecompress.c:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.c:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.c:Destination - The destination buffer to store the decompressed data
Tiano/EfiTianoDecompress.c:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.c:Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
Tiano/EfiTianoDecompress.c:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.c:Version     - The version of de/compression algorithm.
Tiano/EfiTianoDecompress.c:EFI_SUCCESS           - Decompression is successful
Tiano/EfiTianoDecompress.c:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:        Sd->mPBit = 4;
Tiano/EfiTianoDecompress.c:        Sd->mPBit = 5;
Tiano/EfiTianoDecompress.c:    Sd->mSrcBase = (UINT8*)Src;
Tiano/EfiTianoDecompress.c:    Sd->mDstBase = Dst;
Tiano/EfiTianoDecompress.c:    Sd->mCompSize = CompSize;
Tiano/EfiTianoDecompress.c:    Sd->mOrigSize = OrigSize;
Tiano/EfiTianoDecompress.c:    if (Sd->mBadTableFlag != 0) {
Tiano/EfiTianoDecompress.c:This        - The protocol instance pointer
Tiano/EfiTianoDecompress.c:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.c:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.c:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.c:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.c:EFI_SUCCESS           - The size of destination buffer and the size of scratch buffer are successful retrieved.
Tiano/EfiTianoDecompress.c:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:This        - The protocol instance pointer
Tiano/EfiTianoDecompress.c:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.c:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.c:Destination - The destination buffer to store the decompressed data
Tiano/EfiTianoDecompress.c:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.c:Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
Tiano/EfiTianoDecompress.c:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.c:EFI_SUCCESS           - Decompression is successful
Tiano/EfiTianoDecompress.c:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoDecompress.c:This        - The protocol instance pointer
Tiano/EfiTianoDecompress.c:Source      - The source buffer containing the compressed data.
Tiano/EfiTianoDecompress.c:SrcSize     - The size of source buffer
Tiano/EfiTianoDecompress.c:Destination - The destination buffer to store the decompressed data
Tiano/EfiTianoDecompress.c:DstSize     - The size of destination buffer.
Tiano/EfiTianoDecompress.c:Scratch     - The buffer used internally by the decompress routine. This  buffer is needed to store intermediate data.
Tiano/EfiTianoDecompress.c:ScratchSize - The size of scratch buffer.
Tiano/EfiTianoDecompress.c:EFI_SUCCESS           - Decompression is successful
Tiano/EfiTianoDecompress.c:EFI_INVALID_PARAMETER - The source data is corrupted
Tiano/EfiTianoDecompress.c:--*/
Tiano/EfiTianoCompress.h:Copyright (c) 2004 - 2008, Intel Corporation. All rights reserved.<BR>
Tiano/EfiTianoCompress.h:http://opensource.org/licenses/bsd-license.php
Tiano/EfiTianoCompress.h:    SrcBuffer   - The buffer storing the source data
Tiano/EfiTianoCompress.h:    SrcSize     - The size of source data
Tiano/EfiTianoCompress.h:    DstBuffer   - The buffer to store the compressed data
Tiano/EfiTianoCompress.h:    DstSize     - On input, the size of DstBuffer; On output,
Tiano/EfiTianoCompress.h:    EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
Tiano/EfiTianoCompress.h:    EFI_SUCCESS           - Compression is successful.
Tiano/EfiTianoCompress.h:    EFI_OUT_OF_RESOURCES  - No resource to complete function.
Tiano/EfiTianoCompress.h:    EFI_INVALID_PARAMETER - Parameter supplied is wrong.
Tiano/EfiTianoCompress.h:    --*/
Tiano/EfiTianoCompress.h:    SrcBuffer   - The buffer storing the source data
Tiano/EfiTianoCompress.h:    SrcSize     - The size of source data
Tiano/EfiTianoCompress.h:    DstBuffer   - The buffer to store the compressed data
Tiano/EfiTianoCompress.h:    DstSize     - On input, the size of DstBuffer; On output,
Tiano/EfiTianoCompress.h:    EFI_BUFFER_TOO_SMALL  - The DstBuffer is too small. this case,
Tiano/EfiTianoCompress.h:    EFI_SUCCESS           - Compression is successful.
Tiano/EfiTianoCompress.h:    EFI_OUT_OF_RESOURCES  - No resource to complete function.
Tiano/EfiTianoCompress.h:    EFI_INVALID_PARAMETER - Parameter supplied is wrong.
Tiano/EfiTianoCompress.h:    --*/
version.h:http://opensource.org/licenses/bsd-license.php
tags:!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
tags:AddressOfEntryPoint	peimage.h	/^    UINT32                    AddressOfEntryPoint;  \/\/ Offset to entry point -- from original optional header$/;"	m	struct:__anon31
tags:BaseOfCode	peimage.h	/^    UINT32                    BaseOfCode;           \/\/ From original image -- required for ITP debug$/;"	m	struct:__anon31
tags:CFLAGS	Makefile	/^CFLAGS        = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
tags:CFLAGS	UEFIPatch/Makefile	/^CFLAGS        = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
tags:CFLAGS	UEFIReplace/Makefile	/^CFLAGS        = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
tags:CHK_DIR_EXISTS	Makefile	/^CHK_DIR_EXISTS= test -d$/;"	m
tags:CHK_DIR_EXISTS	UEFIPatch/Makefile	/^CHK_DIR_EXISTS= test -d$/;"	m
tags:CHK_DIR_EXISTS	UEFIReplace/Makefile	/^CHK_DIR_EXISTS= test -d$/;"	m
tags:COMPRESS	Makefile	/^COMPRESS      = gzip -9f$/;"	m
tags:COMPRESS	UEFIPatch/Makefile	/^COMPRESS      = gzip -9f$/;"	m
tags:COMPRESS	UEFIReplace/Makefile	/^COMPRESS      = gzip -9f$/;"	m
tags:COPY	Makefile	/^COPY          = cp -f$/;"	m
tags:COPY	UEFIPatch/Makefile	/^COPY          = cp -f$/;"	m
tags:COPY	UEFIReplace/Makefile	/^COPY          = cp -f$/;"	m
tags:COPY_DIR	Makefile	/^COPY_DIR      = cp -f -R$/;"	m
tags:COPY_DIR	UEFIPatch/Makefile	/^COPY_DIR      = cp -f -R$/;"	m
tags:COPY_DIR	UEFIReplace/Makefile	/^COPY_DIR      = cp -f -R$/;"	m
tags:COPY_FILE	Makefile	/^COPY_FILE     = cp -f$/;"	m
tags:COPY_FILE	UEFIPatch/Makefile	/^COPY_FILE     = cp -f$/;"	m
tags:COPY_FILE	UEFIReplace/Makefile	/^COPY_FILE     = cp -f$/;"	m
tags:CXXFLAGS	Makefile	/^CXXFLAGS      = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
tags:CXXFLAGS	UEFIPatch/Makefile	/^CXXFLAGS      = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
tags:CXXFLAGS	UEFIReplace/Makefile	/^CXXFLAGS      = -pipe -Os -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
tags:DEFINES	Makefile	/^DEFINES       = -DQT_NO_DEBUG -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB$/;"	m
tags:DEFINES	UEFIPatch/Makefile	/^DEFINES       = -D_CONSOLE -DQT_NO_DEBUG -DQT_CORE_LIB$/;"	m
tags:DEFINES	UEFIReplace/Makefile	/^DEFINES       = -D_CONSOLE -DQT_NO_DEBUG -DQT_CORE_LIB$/;"	m
tags:DEL_FILE	Makefile	/^DEL_FILE      = rm -f$/;"	m
tags:DEL_FILE	UEFIPatch/Makefile	/^DEL_FILE      = rm -f$/;"	m
tags:DEL_FILE	UEFIReplace/Makefile	/^DEL_FILE      = rm -f$/;"	m
tags:DIST	Makefile	/^DIST          = \/usr\/lib\/x86_64-linux-gnu\/qt5\/mkspecs\/features\/spec_pre.prf \\$/;"	m
tags:DIST	UEFIPatch/Makefile	/^DIST          = \/usr\/lib\/x86_64-linux-gnu\/qt5\/mkspecs\/features\/spec_pre.prf \\$/;"	m
tags:DIST	UEFIReplace/Makefile	/^DIST          = \/usr\/lib\/x86_64-linux-gnu\/qt5\/mkspecs\/features\/spec_pre.prf \\$/;"	m
tags:DISTDIR	Makefile	/^DISTDIR = \/home\/lstas\/code\/damn-vulnerable-uefi\/UEFITool-0.28.0\/.tmp\/UEFITool1.0.0$/;"	m
tags:DISTDIR	UEFIPatch/Makefile	/^DISTDIR = \/home\/lstas\/code\/damn-vulnerable-uefi\/UEFITool-0.28.0\/UEFIPatch\/.tmp\/UEFIPatch1.0.0$/;"	m
tags:DISTDIR	UEFIReplace/Makefile	/^DISTDIR = \/home\/lstas\/code\/damn-vulnerable-uefi\/UEFITool-0.28.0\/UEFIReplace\/.tmp\/UEFIReplace1.0.0$/;"	m
tags:Date	peimage.h	/^    UINT8 Date[12];     \/\/ File member date - decimal$/;"	m	struct:__anon13
tags:GroupID	peimage.h	/^    UINT8 GroupID[6];   \/\/ File member group id - decimal$/;"	m	struct:__anon13
tags:INCPATH	Makefile	/^INCPATH       = -I. -I\/usr\/include\/x86_64-linux-gnu\/qt5 -I\/usr\/include\/x86_64-linux-gnu\/qt5\/QtWidgets -I\/usr\/include\/x86_64-linux-gnu\/qt5\/QtGui -I\/usr\/include\/x86_64-linux-gnu\/qt5\/QtCore -I. -I. -I\/usr\/lib\/x86_64-linux-gnu\/qt5\/mkspecs\/linux-g++$/;"	m
tags:INCPATH	UEFIPatch/Makefile	/^INCPATH       = -I. -I\/usr\/include\/x86_64-linux-gnu\/qt5 -I\/usr\/include\/x86_64-linux-gnu\/qt5\/QtCore -I. -I\/usr\/lib\/x86_64-linux-gnu\/qt5\/mkspecs\/linux-g++$/;"	m
tags:INCPATH	UEFIReplace/Makefile	/^INCPATH       = -I. -I\/usr\/include\/x86_64-linux-gnu\/qt5 -I\/usr\/include\/x86_64-linux-gnu\/qt5\/QtCore -I. -I\/usr\/lib\/x86_64-linux-gnu\/qt5\/mkspecs\/linux-g++$/;"	m
tags:INSTALL_DIR	Makefile	/^INSTALL_DIR   = cp -f -R$/;"	m
tags:INSTALL_DIR	UEFIPatch/Makefile	/^INSTALL_DIR   = cp -f -R$/;"	m
tags:INSTALL_DIR	UEFIReplace/Makefile	/^INSTALL_DIR   = cp -f -R$/;"	m
tags:INSTALL_FILE	Makefile	/^INSTALL_FILE  = install -m 644 -p$/;"	m
tags:INSTALL_FILE	UEFIPatch/Makefile	/^INSTALL_FILE  = install -m 644 -p$/;"	m
tags:INSTALL_FILE	UEFIReplace/Makefile	/^INSTALL_FILE  = install -m 644 -p$/;"	m
tags:INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = install -m 755 -p$/;"	m
tags:INSTALL_PROGRAM	UEFIPatch/Makefile	/^INSTALL_PROGRAM = install -m 755 -p$/;"	m
tags:INSTALL_PROGRAM	UEFIReplace/Makefile	/^INSTALL_PROGRAM = install -m 755 -p$/;"	m
tags:LFLAGS	Makefile	/^LFLAGS        = -Wl,-O1$/;"	m
tags:LFLAGS	UEFIPatch/Makefile	/^LFLAGS        = -Wl,-O1$/;"	m
tags:LFLAGS	UEFIReplace/Makefile	/^LFLAGS        = -Wl,-O1$/;"	m
tags:LIBS	Makefile	/^LIBS          = $(SUBLIBS) \/usr\/lib\/x86_64-linux-gnu\/libQt5Widgets.so \/usr\/lib\/x86_64-linux-gnu\/libQt5Gui.so \/usr\/lib\/x86_64-linux-gnu\/libQt5Core.so -lGL -lpthread   $/;"	m
tags:LIBS	UEFIPatch/Makefile	/^LIBS          = $(SUBLIBS) \/usr\/lib\/x86_64-linux-gnu\/libQt5Core.so -lpthread   $/;"	m
tags:LIBS	UEFIReplace/Makefile	/^LIBS          = $(SUBLIBS) \/usr\/lib\/x86_64-linux-gnu\/libQt5Core.so -lpthread   $/;"	m
tags:MKDIR	Makefile	/^MKDIR         = mkdir -p$/;"	m
tags:MKDIR	UEFIPatch/Makefile	/^MKDIR         = mkdir -p$/;"	m
tags:MKDIR	UEFIReplace/Makefile	/^MKDIR         = mkdir -p$/;"	m
tags:MOVE	Makefile	/^MOVE          = mv -f$/;"	m
tags:MOVE	UEFIPatch/Makefile	/^MOVE          = mv -f$/;"	m
tags:MOVE	UEFIReplace/Makefile	/^MOVE          = mv -f$/;"	m
tags:MatchFinder_GetIndexByte	LZMA/SDK/C/LzFind.c	/^Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }$/;"	f
tags:MatchFinder_GetNumAvailableBytes	LZMA/SDK/C/LzFind.c	/^UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }$/;"	f
tags:MatchFinder_GetPointerToCurrentPos	LZMA/SDK/C/LzFind.c	/^Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }$/;"	f
tags:Mode	peimage.h	/^    UINT8 Mode[8];      \/\/ File member mode - octal$/;"	m	struct:__anon13
tags:Name	peimage.h	/^    UINT8 Name[16];     \/\/ File member name - `\/' terminated$/;"	m	struct:__anon13
tags:NumberOfFlashChips	descriptor.h	/^    UINT32 NumberOfFlashChips : 2;      \/\/ Zero-based number of flash chips installed on board$/;"	m	struct:_FLASH_DESCRIPTOR_MAP
tags:NumberOfMasters	descriptor.h	/^    UINT32 NumberOfMasters : 2;         \/\/ Zero-based number of flash masters$/;"	m	struct:_FLASH_DESCRIPTOR_MAP
tags:NumberOfPchStraps	descriptor.h	/^    UINT32 NumberOfPchStraps : 8;       \/\/ One-based number of UINT32s to read as PCH straps, min=0, max=255 (1 Kb)$/;"	m	struct:_FLASH_DESCRIPTOR_MAP
tags:NumberOfProcStraps	descriptor.h	/^    UINT32 NumberOfProcStraps : 8;      \/\/ One-based number of UINT32s to read as processor straps, min=0, max=255 (1 Kb)$/;"	m	struct:_FLASH_DESCRIPTOR_MAP
tags:QINSTALL	Makefile	/^QINSTALL      = \/usr\/lib\/qt5\/bin\/qmake -install qinstall$/;"	m
tags:QINSTALL	UEFIPatch/Makefile	/^QINSTALL      = \/usr\/lib\/qt5\/bin\/qmake -install qinstall$/;"	m
tags:QINSTALL	UEFIReplace/Makefile	/^QINSTALL      = \/usr\/lib\/qt5\/bin\/qmake -install qinstall$/;"	m
tags:QINSTALL_PROGRAM	Makefile	/^QINSTALL_PROGRAM = \/usr\/lib\/qt5\/bin\/qmake -install qinstall -exe$/;"	m
tags:QINSTALL_PROGRAM	UEFIPatch/Makefile	/^QINSTALL_PROGRAM = \/usr\/lib\/qt5\/bin\/qmake -install qinstall -exe$/;"	m
tags:QINSTALL_PROGRAM	UEFIReplace/Makefile	/^QINSTALL_PROGRAM = \/usr\/lib\/qt5\/bin\/qmake -install qinstall -exe$/;"	m
tags:SYMLINK	Makefile	/^SYMLINK       = ln -f -s$/;"	m
tags:SYMLINK	UEFIPatch/Makefile	/^SYMLINK       = ln -f -s$/;"	m
tags:SYMLINK	UEFIReplace/Makefile	/^SYMLINK       = ln -f -s$/;"	m
tags:Size	peimage.h	/^    UINT8 Size[10];     \/\/ File member size - decimal$/;"	m	struct:__anon13
tags:TAR	Makefile	/^TAR           = tar -cf$/;"	m
tags:TAR	UEFIPatch/Makefile	/^TAR           = tar -cf$/;"	m
tags:TAR	UEFIReplace/Makefile	/^TAR           = tar -cf$/;"	m
tags:UserID	peimage.h	/^    UINT8 UserID[6];    \/\/ File member user id - decimal$/;"	m	struct:__anon13
tags:algo	LZMA/SDK/C/LzmaEnc.h	/^  int algo;        \/* 0 - fast, 1 - normal, default = 1 *\/$/;"	m	struct:_CLzmaEncProps
tags:btMode	LZMA/SDK/C/LzmaEnc.h	/^  int btMode;      \/* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 *\/$/;"	m	struct:_CLzmaEncProps
tags:dictSize	LZMA/SDK/C/LzmaEnc.h	/^  UInt32 dictSize; \/* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version$/;"	m	struct:_CLzmaEncProps
tags:mCCode	Tiano/EfiTianoCompress.c	/^              mCrcTable[UINT8_MAX + 1], mCFreq[2 * NC - 1],mCCode[NC],$/;"	v
tags:mCCode	Tiano/EfiTianoCompressLegacy.c	/^  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mCFreq	Tiano/EfiTianoCompress.c	/^              mCrcTable[UINT8_MAX + 1], mCFreq[2 * NC - 1],mCCode[NC],$/;"	v
tags:mCFreq	Tiano/EfiTianoCompressLegacy.c	/^  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mCrcTable	Tiano/EfiTianoCompress.c	/^              mCrcTable[UINT8_MAX + 1], mCFreq[2 * NC - 1],mCCode[NC],$/;"	v
tags:mCrcTable	Tiano/EfiTianoCompressLegacy.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],$/;"	v
tags:mFreq	Tiano/EfiTianoCompress.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],$/;"	v
tags:mFreq	Tiano/EfiTianoCompressLegacy.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],$/;"	v
tags:mLeft	Tiano/EfiTianoCompress.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],$/;"	v
tags:mLeft	Tiano/EfiTianoCompressLegacy.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],$/;"	v
tags:mLeft	Tiano/EfiTianoDecompress.c	/^    UINT16  mLeft[2 * NC - 1];$/;"	m	struct:__anon59	file:
tags:mLenCnt	Tiano/EfiTianoCompress.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],$/;"	v
tags:mLenCnt	Tiano/EfiTianoCompressLegacy.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],$/;"	v
tags:mPFreq	Tiano/EfiTianoCompress.c	/^              mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mPFreq	Tiano/EfiTianoCompressLegacy.c	/^  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mPTCode	Tiano/EfiTianoCompress.c	/^              mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mPTCode	Tiano/EfiTianoCompressLegacy.c	/^  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mRight	Tiano/EfiTianoCompress.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],$/;"	v
tags:mRight	Tiano/EfiTianoCompressLegacy.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],$/;"	v
tags:mRight	Tiano/EfiTianoDecompress.c	/^    UINT16  mRight[2 * NC - 1];$/;"	m	struct:__anon59	file:
tags:mSortPtr	Tiano/EfiTianoCompress.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1],$/;"	v
tags:mSortPtr	Tiano/EfiTianoCompressLegacy.c	/^STATIC UINT16 *mFreq, *mSortPtr, mLenCnt[17], mLeft[2 * NC - 1], mRight[2 * NC - 1], mCrcTable[UINT8_MAX + 1],$/;"	v
tags:mTFreq	Tiano/EfiTianoCompress.c	/^              mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:mTFreq	Tiano/EfiTianoCompressLegacy.c	/^  mCFreq[2 * NC - 1], mCCode[NC], mPFreq[2 * NP - 1], mPTCode[NPT], mTFreq[2 * NT - 1];$/;"	v
tags:posEncoders	LZMA/SDK/C/LzmaEnc.c	/^    CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];$/;"	m	struct:__anon51	file:
tags:posEncoders	LZMA/SDK/C/LzmaEnc.c	/^    CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];$/;"	m	struct:__anon52	file:
tags:writeEndMark	LZMA/SDK/C/LzmaEnc.h	/^  unsigned writeEndMark;  \/* 0 - do not write EOPM, 1 - write EOPM, default = 0 *\/$/;"	m	struct:_CLzmaEncProps
